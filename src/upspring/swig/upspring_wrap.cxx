/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.31
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */


#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    SwigValueWrapper() : tt(0) { }
    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
    SwigValueWrapper(const T& t) : tt(new T(t)) { }
    ~SwigValueWrapper() { delete tt; } 
    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
    operator T&() const { return *tt; }
    T *operator&() { return tt; }
private:
    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
};
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC)
#   if (__SUNPRO_CC <= 0x560)
#     define SWIGTEMPLATEDISAMBIGUATOR template
#   else
#     define SWIGTEMPLATEDISAMBIGUATOR 
#   endif
# else
#   define SWIGTEMPLATEDISAMBIGUATOR 
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic CAPI SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "3"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the swig runtime code.
  In 99.9% of the cases, swig just needs to declare them as 'static'.
  
  But only do this if is strictly necessary, ie, if you have problems
  with your compiler or so.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/* 
   Flags/methods for returning states.
   
   The swig conversion methods, as ConvertPtr, return and integer 
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).
   
   Use the following macros/flags to set or process the returning
   states.
   
   In old swig versions, you usually write code as:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit as:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   that seems to be the same, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }
    
   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   requires also to SWIG_ConvertPtr to return new result values, as

      int SWIG_ConvertPtr(obj, ptr,...) {         
        if (<obj is ok>) {			       
          if (<need new object>) {		       
            *ptr = <ptr to new allocated object>; 
            return SWIG_NEWOBJ;		       
          } else {				       
            *ptr = <ptr to old object>;	       
            return SWIG_OLDOBJ;		       
          } 				       
        } else {				       
          return SWIG_BADOBJ;		       
        }					       
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   swig errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call
 
      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()


 */
#define SWIG_OK                    (0) 
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))


/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) { 
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) { 
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
}
#else /* no cast-rank mode */
#  define SWIG_AddCast
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif




#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store inforomation on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (l1 - f1) - (l2 - f2);
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/* think of this as a c++ template<> or a scheme macro */
#define SWIG_TypeCheck_Template(comparison, ty)         \
  if (ty) {                                             \
    swig_cast_info *iter = ty->cast;                    \
    while (iter) {                                      \
      if (comparison) {                                 \
        if (iter == ty->cast) return iter;              \
        /* Move iter to the top of the linked list */   \
        iter->prev->next = iter->next;                  \
        if (iter->next)                                 \
          iter->next->prev = iter->prev;                \
        iter->next = ty->cast;                          \
        iter->prev = 0;                                 \
        if (ty->cast) ty->cast->prev = iter;            \
        ty->cast = iter;                                \
        return iter;                                    \
      }                                                 \
      iter = iter->next;                                \
    }                                                   \
  }                                                     \
  return 0

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  SWIG_TypeCheck_Template(strcmp(iter->type->name, c) == 0, ty);
}

/* Same as previous function, except strcmp is replaced with a pointer comparison */
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
  SWIG_TypeCheck_Template(iter->type == from, into);
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}
  
/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * luarun.swg
 *
 * This file contains the runtime support for Lua modules
 * and includes code for managing global variables and pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

#include "lua.h"
#include "lauxlib.h"
#include <malloc.h>
#include <assert.h>	/* for a few sanity tests */

/* -----------------------------------------------------------------------------
 * global swig types
 * ----------------------------------------------------------------------------- */
/* Constant table */
#define SWIG_LUA_INT     1
#define SWIG_LUA_FLOAT   2
#define SWIG_LUA_STRING  3
#define SWIG_LUA_POINTER 4
#define SWIG_LUA_BINARY  5
#define SWIG_LUA_CHAR    6

/* Structure for variable linking table */
typedef struct {
  const char *name;
  lua_CFunction get;
  lua_CFunction set;
} swig_lua_var_info;

/* Constant information structure */
typedef struct {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_lua_const_info;

typedef struct {
  const char     *name;
  lua_CFunction   method;
} swig_lua_method;

typedef struct {
  const char     *name;
  lua_CFunction   getmethod;
  lua_CFunction   setmethod;
} swig_lua_attribute;

typedef struct swig_lua_class {
  const char         *name;
  swig_type_info   **type;
  lua_CFunction       constructor;
  void              (*destructor)(void *);
  swig_lua_method        *methods;
  swig_lua_attribute     *attributes;
  struct swig_lua_class **bases;
} swig_lua_class;

/* this is the struct for wrappering all pointers in SwigLua
*/
typedef struct {
  swig_type_info   *type;
  int               own;	/* 1 if owned & must be destroyed */
  void             *ptr;
} swig_lua_userdata;

/* this is the struct for wrappering arbitary packed binary data
(currently it is only used for member fn pointers)
the data ordering is similar to swig_lua_userdata, but its currently not possible
to tell the two structres apart within Swig, other than by looking at the type
*/
typedef struct {
  swig_type_info   *type;
  int               own;	/* 1 if owned & must be destroyed */
  char data[1];            /* arbitary amount of data */    
} swig_lua_rawdata;

/* Common SWIG API */
#define SWIG_NewPointerObj(L, ptr, type, owner)            SWIG_Lua_NewPointerObj(L, (void *)ptr, type, owner)
#define SWIG_ConvertPtr(L,idx, ptr, type, flags)	       SWIG_Lua_ConvertPtr(L,idx,ptr,type,flags)
#define SWIG_MustGetPtr(L,idx, type,flags, argnum,fnname)  SWIG_Lua_MustGetPtr(L,idx, type,flags, argnum,fnname)
/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(L, idx, ptr, sz, ty)            SWIG_Lua_ConvertPacked(L, idx, ptr, sz, ty)
#define SWIG_NewMemberObj(L, ptr, sz, type)                SWIG_Lua_NewPackedObj(L, ptr, sz, type)

/* Runtime API */
#define SWIG_GetModule(clientdata) SWIG_Lua_GetModule((lua_State*)(clientdata))
#define SWIG_SetModule(clientdata, pointer) SWIG_Lua_SetModule((lua_State*) (clientdata), pointer)
#define SWIG_MODULE_CLIENTDATA_TYPE lua_State*

/* Contract support */
#define SWIG_contract_assert(expr, msg)  \
  if (!(expr)) { lua_pushstring(L, (char *) msg); goto fail; } else

/* helper #defines */
#define SWIG_fail {goto fail;}
#define SWIG_fail_arg(I) {lua_pushfstring(L,"argument %d incorrect/missing",I);goto fail;}
#define SWIG_fail_ptr(func_name,argnum,type) \
	{lua_pushfstring(L,"Error in %s, expected a %s at argument number %d\n",\
	func_name,(type && type->str)?type->str:"void*",argnum);\
	goto fail;}

#define SWIG_Lua_get_table(L,n) \
	(lua_pushstring(L, n), lua_rawget(L,-2))

#define SWIG_Lua_add_function(L,n,f) \
		   (lua_pushstring(L, n), \
			lua_pushcfunction(L, f), \
			lua_rawset(L,-3))

/* special helper for allowing 'nil' for usertypes */
#define SWIG_isptrtype(L,I) (lua_isuserdata(L,I) || lua_isnil(L,I))

#ifdef __cplusplus
/* Special helper for member function pointers 
it gets the address, casts it, then dereferences it */
#define SWIG_mem_fn_as_voidptr(a)  (*((char**)&(a)))
#endif

/* -----------------------------------------------------------------------------
 * global variable support code: modules
 * ----------------------------------------------------------------------------- */

/* the module.get method used for getting linked data */
SWIGINTERN int SWIG_Lua_module_get(lua_State* L)
{
/*	there should be 2 params passed in
	(1) table (not the meta table)
	(2) string name of the attribute
	printf("SWIG_Lua_module_get %p(%s) '%s'\n",
				lua_topointer(L,1),lua_typename(L,lua_type(L,1)),
				lua_tostring(L,2));
*/
	/* get the metatable */
	assert(lua_istable(L,1));	/* just in case */
	lua_getmetatable(L,1);	/* get the metatable */
	assert(lua_istable(L,-1));	/* just in case */
	SWIG_Lua_get_table(L,".get");	/* get the .get table */
	lua_remove(L,3);	/* remove metatable */
	if (lua_istable(L,-1))
	{
		/* look for the key in the .get table */
		lua_pushvalue(L,2);  /* key */
		lua_rawget(L,-2);
		lua_remove(L,3);	/* remove .get */
		if (lua_iscfunction(L,-1))
		{	/* found it so call the fn & return its value */
			lua_call(L,0,1);
			return 1;
		}
		lua_pop(L,1);	/* remove the top */
	}
	lua_pop(L,1);	/* remove the .get */
	lua_pushnil(L);	/* return a nil */
    return 1;
}

/* the module.set method used for setting linked data */
SWIGINTERN int SWIG_Lua_module_set(lua_State* L)
{
/*	there should be 3 params passed in
	(1) table (not the meta table)
	(2) string name of the attribute
	(3) any for the new value
*/
	/* get the metatable */
	assert(lua_istable(L,1));	/* just in case */
	lua_getmetatable(L,1);	/* get the metatable */
	assert(lua_istable(L,-1));	/* just in case */
	SWIG_Lua_get_table(L,".set");	/* get the .set table */
	lua_remove(L,4);	/* remove metatable */
	if (lua_istable(L,-1))
	{
		/* look for the key in the .set table */
		lua_pushvalue(L,2);  /* key */
		lua_rawget(L,-2);
		lua_remove(L,4);	/* remove .set */
		if (lua_iscfunction(L,-1))
		{	/* found it so call the fn & return its value */
			lua_pushvalue(L,3);  /* value */
			lua_call(L,1,0);
			return 0;
		}
		lua_pop(L,1);	/* remove the top */
	}
	lua_pop(L,1);	/* remove the .set */
    return 0;
}

/* registering a module in lua */
SWIGINTERN void  SWIG_Lua_module_begin(lua_State* L,const char* name)
{
	assert(lua_istable(L,-1));	/* just in case */
	lua_pushstring(L,name);
	lua_newtable(L);				/* the table */
	/* add meta table */
	lua_newtable(L);		/* the meta table */
	SWIG_Lua_add_function(L,"__index",SWIG_Lua_module_get);
	SWIG_Lua_add_function(L,"__newindex",SWIG_Lua_module_set);
	lua_pushstring(L,".get");
	lua_newtable(L);		/* the .get table */
	lua_rawset(L,-3);       /* add .get into metatable */
	lua_pushstring(L,".set");
	lua_newtable(L);		/* the .set table */
	lua_rawset(L,-3);       /* add .set into metatable */
	lua_setmetatable(L,-2);	/* sets meta table in module */
	lua_rawset(L,-3);                  /* add module into parent */
	SWIG_Lua_get_table(L,name);				/* get the table back out */
}

/* ending the register */
SWIGINTERN void  SWIG_Lua_module_end(lua_State* L)
{
	lua_pop(L,1);                      /* tidy stack (remove module) */
}

/* adding a linked variable to the module */
SWIGINTERN void SWIG_Lua_module_add_variable(lua_State* L,const char* name,lua_CFunction getFn,lua_CFunction setFn)
{
	assert(lua_istable(L,-1));	/* just in case */
	lua_getmetatable(L,-1);	/* get the metatable */
	assert(lua_istable(L,-1));	/* just in case */
	SWIG_Lua_get_table(L,".get"); /* find the .get table */
	assert(lua_istable(L,-1));	/* should be a table: */
	SWIG_Lua_add_function(L,name,getFn);
	lua_pop(L,1);                      /* tidy stack (remove table) */
	if (setFn)	/* if there is a set fn */
	{
		SWIG_Lua_get_table(L,".set"); /* find the .set table */
		assert(lua_istable(L,-1));	/* should be a table: */
		SWIG_Lua_add_function(L,name,setFn);
		lua_pop(L,1);                      /* tidy stack (remove table) */
	}
	lua_pop(L,1);                      /* tidy stack (remove meta) */
}

/* adding a function module */
SWIGINTERN void  SWIG_Lua_module_add_function(lua_State* L,const char* name,lua_CFunction fn)
{
	SWIG_Lua_add_function(L,name,fn);
}

/* -----------------------------------------------------------------------------
 * global variable support code: classes
 * ----------------------------------------------------------------------------- */

/* the class.get method, performs the lookup of class attributes */
SWIGINTERN int  SWIG_Lua_class_get(lua_State* L)
{
/*	there should be 2 params passed in
	(1) userdata (not the meta table)
	(2) string name of the attribute
*/
	assert(lua_isuserdata(L,-2));	/* just in case */
	lua_getmetatable(L,-2);		/* get the meta table */
	assert(lua_istable(L,-1));	/* just in case */
	SWIG_Lua_get_table(L,".get"); /* find the .get table */
	assert(lua_istable(L,-1));	/* just in case */
	/* look for the key in the .get table */
	lua_pushvalue(L,2);  /* key */
	lua_rawget(L,-2);
	lua_remove(L,-2); /* stack tidy, remove .get table */
	if (lua_iscfunction(L,-1))
	{	/* found it so call the fn & return its value */
		lua_pushvalue(L,1);  /* the userdata */
		lua_call(L,1,1);	/* 1 value in (userdata),1 out (result) */
		lua_remove(L,-2); /* stack tidy, remove metatable */
		return 1;
	}
	lua_pop(L,1);	/* remove whatever was there */
	/* ok, so try the .fn table */
	SWIG_Lua_get_table(L,".fn"); /* find the .get table */
	assert(lua_istable(L,-1));	/* just in case */
	lua_pushvalue(L,2);  /* key */
	lua_rawget(L,-2);	/* look for the fn */
	lua_remove(L,-2); /* stack tidy, remove .fn table */
	if (lua_iscfunction(L,-1))
	{	/* found it so return the fn & let lua call it */
		lua_remove(L,-2); /* stack tidy, remove metatable */
		return 1;
	}
	lua_pop(L,1);	/* remove whatever was there */
	/* NEW: looks for the __getitem() fn
	this is a user provided get fn */
	SWIG_Lua_get_table(L,"__getitem"); /* find the __getitem fn */
	if (lua_iscfunction(L,-1))	/* if its there */
	{	/* found it so call the fn & return its value */
		lua_pushvalue(L,1);  /* the userdata */
		lua_pushvalue(L,2);  /* the parameter */
		lua_call(L,2,1);	/* 2 value in (userdata),1 out (result) */
		lua_remove(L,-2); /* stack tidy, remove metatable */
		return 1;
	}
	return 0;	/* sorry not known */
}

/* the class.set method, performs the lookup of class attributes */
SWIGINTERN int  SWIG_Lua_class_set(lua_State* L)
{
/*	there should be 3 params passed in
	(1) table (not the meta table)
	(2) string name of the attribute
	(3) any for the new value
printf("SWIG_Lua_class_set %p(%s) '%s' %p(%s)\n",
			lua_topointer(L,1),lua_typename(L,lua_type(L,1)),
			lua_tostring(L,2),
			lua_topointer(L,3),lua_typename(L,lua_type(L,3)));*/

	assert(lua_isuserdata(L,1));	/* just in case */
	lua_getmetatable(L,1);		/* get the meta table */
	assert(lua_istable(L,-1));	/* just in case */

	SWIG_Lua_get_table(L,".set"); /* find the .set table */
	if (lua_istable(L,-1))
	{
		/* look for the key in the .set table */
		lua_pushvalue(L,2);  /* key */
		lua_rawget(L,-2);
		if (lua_iscfunction(L,-1))
		{	/* found it so call the fn & return its value */
			lua_pushvalue(L,1);  /* userdata */
			lua_pushvalue(L,3);  /* value */
			lua_call(L,2,0);
			return 0;
		}
		lua_pop(L,1);	/* remove the value */
	}
	lua_pop(L,1);	/* remove the value .set table */
	/* NEW: looks for the __setitem() fn
	this is a user provided set fn */
	SWIG_Lua_get_table(L,"__setitem"); /* find the fn */
	if (lua_iscfunction(L,-1))	/* if its there */
	{	/* found it so call the fn & return its value */
		lua_pushvalue(L,1);  /* the userdata */
		lua_pushvalue(L,2);  /* the parameter */
		lua_pushvalue(L,3);  /* the value */
		lua_call(L,3,0);	/* 3 values in ,0 out */
		lua_remove(L,-2); /* stack tidy, remove metatable */
		return 1;
	}
	return 0;
}

/* the class.destruct method called by the interpreter */
SWIGINTERN int  SWIG_Lua_class_destruct(lua_State* L)
{
/*	there should be 1 params passed in
	(1) userdata (not the meta table) */
	swig_lua_userdata* usr;
	swig_lua_class* clss;
	assert(lua_isuserdata(L,-1));	/* just in case */
	usr=(swig_lua_userdata*)lua_touserdata(L,-1);	/* get it */
	/* if must be destroyed & has a destructor */
	if (usr->own) /* if must be destroyed */
	{
		clss=(swig_lua_class*)usr->type->clientdata;	/* get the class */
		if (clss && clss->destructor)	/* there is a destroy fn */
		{
			clss->destructor(usr->ptr);	/* bye bye */
		}
	}
	return 0;
}

/* gets the swig class registry (or creates it) */
SWIGINTERN void  SWIG_Lua_get_class_registry(lua_State* L)
{
	/* add this all into the swig registry: */
	lua_pushstring(L,"SWIG");
	lua_rawget(L,LUA_REGISTRYINDEX);	/* get the registry */
	if (!lua_istable(L,-1))	/* not there */
	{	/* must be first time, so add it */
		lua_pop(L,1);	/* remove the result */
		lua_pushstring(L,"SWIG");
		lua_newtable(L);
		lua_rawset(L,LUA_REGISTRYINDEX);
		/* then get it */
		lua_pushstring(L,"SWIG");
		lua_rawget(L,LUA_REGISTRYINDEX);
	}
}

/* helper fn to get the classes metatable from the register */
SWIGINTERN void  SWIG_Lua_get_class_metatable(lua_State* L,const char* cname)
{
	SWIG_Lua_get_class_registry(L);	/* get the registry */
	lua_pushstring(L,cname);	/* get the name */
	lua_rawget(L,-2);		/* get it */
	lua_remove(L,-2);		/* tidy up (remove registry) */
}

/* helper add a variable to a registered class */
SWIGINTERN void  SWIG_Lua_add_class_variable(lua_State* L,const char* name,lua_CFunction getFn,lua_CFunction setFn)
{
	assert(lua_istable(L,-1));	/* just in case */
	SWIG_Lua_get_table(L,".get"); /* find the .get table */
	assert(lua_istable(L,-1));	/* just in case */
	SWIG_Lua_add_function(L,name,getFn);
	lua_pop(L,1);                      /* tidy stack (remove table) */
	if (setFn)
	{
		SWIG_Lua_get_table(L,".set"); /* find the .set table */
		assert(lua_istable(L,-1));	/* just in case */
		SWIG_Lua_add_function(L,name,setFn);
		lua_pop(L,1);                      /* tidy stack (remove table) */
	}
}

/* helper to recursively add class details (attributes & operations) */
SWIGINTERN void  SWIG_Lua_add_class_details(lua_State* L,swig_lua_class* clss)
{
	int i;
	/* call all the base classes first: we can then override these later: */
	for(i=0;clss->bases[i];i++)
	{
		SWIG_Lua_add_class_details(L,clss->bases[i]);
	}
	/* add fns */
	for(i=0;clss->attributes[i].name;i++){
		SWIG_Lua_add_class_variable(L,clss->attributes[i].name,clss->attributes[i].getmethod,clss->attributes[i].setmethod);
	}
	/* add methods to the metatable */
	SWIG_Lua_get_table(L,".fn"); /* find the .fn table */
	assert(lua_istable(L,-1));	/* just in case */
	for(i=0;clss->methods[i].name;i++){
		SWIG_Lua_add_function(L,clss->methods[i].name,clss->methods[i].method);
	}
	lua_pop(L,1);                      /* tidy stack (remove table) */
	/* 	add operator overloads
		these look ANY method which start with "__" and assume they
		are operator overloads & add them to the metatable
		(this might mess up is someone defines a method __gc (the destructor)*/
	for(i=0;clss->methods[i].name;i++){
		if (clss->methods[i].name[0]=='_' && clss->methods[i].name[1]=='_'){
			SWIG_Lua_add_function(L,clss->methods[i].name,clss->methods[i].method);
		}
	}
}

/* performs the entire class registration process */
SWIGINTERN void  SWIG_Lua_class_register(lua_State* L,swig_lua_class* clss)
{
/*	add its constructor to module with the name of the class
	so you can do MyClass(...) as well as new_MyClass(...)
	BUT only if a constructor is defined
	(this overcomes the problem of pure virtual classes without constructors)*/
	if (clss->constructor)
		SWIG_Lua_add_function(L,clss->name,clss->constructor);

	SWIG_Lua_get_class_registry(L);	/* get the registry */
	lua_pushstring(L,clss->name);	/* get the name */
	lua_newtable(L);		/* create the metatable */
	/* add string of class name called ".type" */
	lua_pushstring(L,".type");
	lua_pushstring(L,clss->name);
	lua_rawset(L,-3);
	/* add a table called ".get" */
	lua_pushstring(L,".get");
	lua_newtable(L);
	lua_rawset(L,-3);
	/* add a table called ".set" */
	lua_pushstring(L,".set");
	lua_newtable(L);
	lua_rawset(L,-3);
	/* add a table called ".fn" */
	lua_pushstring(L,".fn");
	lua_newtable(L);
	lua_rawset(L,-3);
	/* add accessor fns for using the .get,.set&.fn */
	SWIG_Lua_add_function(L,"__index",SWIG_Lua_class_get);
	SWIG_Lua_add_function(L,"__newindex",SWIG_Lua_class_set);
	SWIG_Lua_add_function(L,"__gc",SWIG_Lua_class_destruct);
	/* add it */
	lua_rawset(L,-3);	/* metatable into registry */
	lua_pop(L,1);           /* tidy stack (remove registry) */

	SWIG_Lua_get_class_metatable(L,clss->name);
	SWIG_Lua_add_class_details(L,clss);	/* recursive adding of details (atts & ops) */
	lua_pop(L,1);           /* tidy stack (remove class metatable) */
}

/* -----------------------------------------------------------------------------
 * Class/structure conversion fns
 * ----------------------------------------------------------------------------- */

/* helper to add metatable to new lua object */
SWIGINTERN void _SWIG_Lua_AddMetatable(lua_State* L,swig_type_info *type)
{
	if (type->clientdata)	/* there is clientdata: so add the metatable */
	{
		SWIG_Lua_get_class_metatable(L,((swig_lua_class*)(type->clientdata))->name);
		if (lua_istable(L,-1))
		{
			lua_setmetatable(L,-2);
		}
		else
		{
			lua_pop(L,1);
		}
	}
}

/* pushes a new object into the lua stack */
SWIGRUNTIME void SWIG_Lua_NewPointerObj(lua_State* L,void* ptr,swig_type_info *type, int own)
{
	swig_lua_userdata* usr;
	if (!ptr){
		lua_pushnil(L);
		return;
	}
	usr=(swig_lua_userdata*)lua_newuserdata(L,sizeof(swig_lua_userdata));	/* get data */
	usr->ptr=ptr;	/* set the ptr */
	usr->type=type;
	usr->own=own;
    _SWIG_Lua_AddMetatable(L,type); /* add metatable */
}

/* takes a object from the lua stack & converts it into an object of the correct type
 (if possible) */
SWIGRUNTIME int  SWIG_Lua_ConvertPtr(lua_State* L,int index,void** ptr,swig_type_info *type,int flags)
{
	swig_lua_userdata* usr;
	swig_cast_info *cast;
	if (lua_isnil(L,index)){*ptr=0; return SWIG_OK;}    /* special case: lua nil => NULL pointer */
	usr=(swig_lua_userdata*)lua_touserdata(L,index);	/* get data */
	if (usr)
	{
                if (!type)                           /* special cast void*, no casting fn */
                {
                    *ptr=usr->ptr;
                    return SWIG_OK; /* ok */
                }
		cast=SWIG_TypeCheckStruct(usr->type,type); /* performs normal type checking */
		if (cast)
		{
			*ptr=SWIG_TypeCast(cast,usr->ptr);
			return SWIG_OK;	/* ok */
		}
	}
	return SWIG_ERROR;	/* error */
}

SWIGRUNTIME void* SWIG_Lua_MustGetPtr(lua_State* L,int index,swig_type_info *type,int flags,
						int argnum,const char* func_name){
	void* result;
	if (!SWIG_IsOK(SWIG_ConvertPtr(L,index,&result,type,flags))){
		lua_pushfstring(L,"Error in %s, expected a %s at argument number %d\n",
			func_name,(type && type->str)?type->str:"void*",argnum);
		lua_error(L);
	}
	return result;
}

/* pushes a packed userdata. user for member fn pointers only */
SWIGRUNTIME void SWIG_Lua_NewPackedObj(lua_State* L,void* ptr,size_t size,swig_type_info *type)
{
	swig_lua_rawdata* raw;
	assert(ptr); /* not acceptable to pass in a NULL value */
	raw=(swig_lua_rawdata*)lua_newuserdata(L,sizeof(swig_lua_rawdata)-1+size);	/* alloc data */
	raw->type=type;
	raw->own=0;
    memcpy(raw->data,ptr,size); /* copy the data */
    _SWIG_Lua_AddMetatable(L,type); /* add metatable */
}
    
/* converts a packed userdata. user for member fn pointers only */
SWIGRUNTIME int  SWIG_Lua_ConvertPacked(lua_State* L,int index,void* ptr,size_t size,swig_type_info *type)
{
	swig_lua_rawdata* raw;
	swig_cast_info *cast;
	raw=(swig_lua_rawdata*)lua_touserdata(L,index);	/* get data */
	if (!raw) return SWIG_ERROR;	/* error */
    if (type==0 || type==raw->type) /* void* or identical type */
    {
        memcpy(ptr,raw->data,size); /* copy it */
        return SWIG_OK; /* ok */
    }
    return SWIG_ERROR;	/* error */
}

/* lua callable function to get the userdata's type */
SWIGRUNTIME int SWIG_Lua_type(lua_State* L)
{
	swig_lua_userdata* usr;
	if (!lua_isuserdata(L,1))	/* just in case */
		return 0;	/* nil reply */
	usr=(swig_lua_userdata*)lua_touserdata(L,1);	/* get data */
	lua_pushstring(L,usr->type->name);
	return 1;
}

/* lua callable function to compare userdata's value
the issue is that two userdata may point to the same thing
but to lua, they are different objects */
SWIGRUNTIME int SWIG_Lua_equal(lua_State* L)
{
	int result;
	swig_lua_userdata *usr1,*usr2;
	if (!lua_isuserdata(L,1) || !lua_isuserdata(L,2))	/* just in case */
		return 0;	/* nil reply */
	usr1=(swig_lua_userdata*)lua_touserdata(L,1);	/* get data */
	usr2=(swig_lua_userdata*)lua_touserdata(L,2);	/* get data */
	/*result=(usr1->ptr==usr2->ptr && usr1->type==usr2->type); only works if type is the same*/
	result=(usr1->ptr==usr2->ptr);
        lua_pushboolean(L,result);
	return 1;
}


/* -----------------------------------------------------------------------------
 * global variable support code: class/struct typemap functions
 * ----------------------------------------------------------------------------- */

/* Install Constants */
SWIGINTERN void
SWIG_Lua_InstallConstants(lua_State* L, swig_lua_const_info constants[]) {
  int i;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_LUA_INT:
      lua_pushstring(L,constants[i].name);
      lua_pushnumber(L,(lua_Number)constants[i].lvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_FLOAT:
      lua_pushstring(L,constants[i].name);
      lua_pushnumber(L,(lua_Number)constants[i].dvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_CHAR:
      lua_pushstring(L,constants[i].name);
      lua_pushfstring(L,"%c",(char)constants[i].lvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_STRING:
      lua_pushstring(L,constants[i].name);
      lua_pushstring(L,(char *) constants[i].pvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_POINTER:
      lua_pushstring(L,constants[i].name);
      SWIG_NewPointerObj(L,constants[i].pvalue, *(constants[i]).ptype,0);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_BINARY:
    /* TODO?? */
/*      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype)); */
      break;
    default:
      break;
    }
  }
}

/* storing/access of swig_module_info */
SWIGRUNTIME swig_module_info *
SWIG_Lua_GetModule(lua_State* L) {
  swig_module_info *ret = 0;
  lua_pushstring(L,"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  lua_rawget(L,LUA_REGISTRYINDEX);
  if (lua_islightuserdata(L,-1))
  	ret=(swig_module_info*)lua_touserdata(L,-1);
  lua_pop(L,1);	/* tidy */
  return ret;
}

SWIGRUNTIME void
SWIG_Lua_SetModule(lua_State* L, swig_module_info *module) {
  /* add this all into the Lua registry: */
  lua_pushstring(L,"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  lua_pushlightuserdata(L,(void*)module);
  lua_rawset(L,LUA_REGISTRYINDEX);
}

#ifdef __cplusplus
}
#endif

/* ------------------------------ end luarun.swg  ------------------------------ */

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13




/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_AnimProperty swig_types[0]
#define SWIGTYPE_AnimationInfo swig_types[1]
#define SWIGTYPE_Quaternion swig_types[2]
#define SWIGTYPE_Rotator swig_types[3]
#define SWIGTYPE_Triangle swig_types[4]
#define SWIGTYPE_Vector3 swig_types[5]
#define SWIGTYPE_Vertex swig_types[6]
#define SWIGTYPE_p_AnimController swig_types[7]
#define SWIGTYPE_p_AnimProperty swig_types[8]
#define SWIGTYPE_p_AnimationInfo swig_types[9]
#define SWIGTYPE_p_AnimationSequence swig_types[10]
#define SWIGTYPE_p_BaseJoint swig_types[11]
#define SWIGTYPE_p_EditorViewWindow swig_types[12]
#define SWIGTYPE_p_Geometry swig_types[13]
#define SWIGTYPE_p_HingeJoint swig_types[14]
#define SWIGTYPE_p_IEditor swig_types[15]
#define SWIGTYPE_p_IKinfo swig_types[16]
#define SWIGTYPE_p_IProgressCtl swig_types[17]
#define SWIGTYPE_p_IRenderData swig_types[18]
#define SWIGTYPE_p_IView swig_types[19]
#define SWIGTYPE_p_Matrix swig_types[20]
#define SWIGTYPE_p_MdlObject swig_types[21]
#define SWIGTYPE_p_Model swig_types[22]
#define SWIGTYPE_p_ModelDrawer swig_types[23]
#define SWIGTYPE_p_Plane swig_types[24]
#define SWIGTYPE_p_Poly swig_types[25]
#define SWIGTYPE_p_PolyMesh swig_types[26]
#define SWIGTYPE_p_Quaternion swig_types[27]
#define SWIGTYPE_p_RefPtrTTexture_t swig_types[28]
#define SWIGTYPE_p_Rotator swig_types[29]
#define SWIGTYPE_p_Texture swig_types[30]
#define SWIGTYPE_p_TextureBinding swig_types[31]
#define SWIGTYPE_p_TextureHandler swig_types[32]
#define SWIGTYPE_p_Tool swig_types[33]
#define SWIGTYPE_p_Triangle swig_types[34]
#define SWIGTYPE_p_UniversalJoint swig_types[35]
#define SWIGTYPE_p_Vector2 swig_types[36]
#define SWIGTYPE_p_Vector3 swig_types[37]
#define SWIGTYPE_p_Vector4 swig_types[38]
#define SWIGTYPE_p_Vertex swig_types[39]
#define SWIGTYPE_p_creg__ISerializer swig_types[40]
#define SWIGTYPE_p_f_float_p_void__void swig_types[41]
#define SWIGTYPE_p_f_p_MdlObject__void swig_types[42]
#define SWIGTYPE_p_f_p_Texture_p_void__void swig_types[43]
#define SWIGTYPE_p_f_r_Vertex_r_Vertex__bool swig_types[44]
#define SWIGTYPE_p_float swig_types[45]
#define SWIGTYPE_p_int swig_types[46]
#define SWIGTYPE_p_size_t swig_types[47]
#define SWIGTYPE_p_std__listTAnimProperty_t swig_types[48]
#define SWIGTYPE_p_std__listTAnimationInfo_t swig_types[49]
#define SWIGTYPE_p_std__list_iteratorTAnimProperty_t swig_types[50]
#define SWIGTYPE_p_std__list_iteratorTAnimationInfo_t swig_types[51]
#define SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t swig_types[52]
#define SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t swig_types[53]
#define SWIGTYPE_p_std__string swig_types[54]
#define SWIGTYPE_p_std__vectorTAnimProperty_p_t swig_types[55]
#define SWIGTYPE_p_std__vectorTAnimationInfo_p_t swig_types[56]
#define SWIGTYPE_p_std__vectorTEditorViewWindow_p_t swig_types[57]
#define SWIGTYPE_p_std__vectorTMdlObject_p_t swig_types[58]
#define SWIGTYPE_p_std__vectorTPolyMesh_p_t swig_types[59]
#define SWIGTYPE_p_std__vectorTPoly_p_t swig_types[60]
#define SWIGTYPE_p_std__vectorTTextureBinding_t swig_types[61]
#define SWIGTYPE_p_std__vectorTTriangle_t swig_types[62]
#define SWIGTYPE_p_std__vectorTVector3_t swig_types[63]
#define SWIGTYPE_p_std__vectorTVertex_t swig_types[64]
#define SWIGTYPE_p_std__vectorTchar_t swig_types[65]
#define SWIGTYPE_p_std__vectorTfloat_t swig_types[66]
#define SWIGTYPE_p_std__vectorTint_t swig_types[67]
#define SWIGTYPE_p_std__vectorTshort_t swig_types[68]
#define SWIGTYPE_p_uint swig_types[69]
#define SWIGTYPE_p_ulong swig_types[70]
#define SWIGTYPE_p_void swig_types[71]
#define SWIGTYPE_size_t swig_types[72]
#define SWIGTYPE_uint swig_types[73]
static swig_type_info *swig_types[75];
static swig_module_info swig_module = {swig_types, 74, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Upspring_Init
#define SWIG_name    "upspring"
#define SWIG_import  luaopen_upspring


#include "EditorIncl.h"
#include "EditorDef.h"

#include "ScriptInterface.h"
#include "../Model.h"
#include "DebugTrace.h"
//#include "../Fltk.h"


#include <vector>


#include <stdexcept>


#define SWIG_exception(a,b)\
{ lua_pushfstring(L,"%s:%s",#a,b);SWIG_fail; }


#include <stdexcept>


	#include <string>


#include <list>

namespace std {
	template<typename T>
	class list_iterator : public list<T>::iterator
	{
	public:
		list_iterator() {}
		list_iterator(const typename list<T>::iterator& li) : list<T>::iterator(li) {}
	};
	template<typename T>
	class list_reverse_iterator : public list<T>::reverse_iterator
	{
	public:
		list_reverse_iterator () {}
		list_reverse_iterator (const typename list<T>::reverse_iterator& li) : list<T>::reverse_iterator(li) {}
	};
}


SWIGINTERN int std_vector_Sl_int_Sg____getitem__(std::vector<int > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_int_Sg____setitem__(std::vector<int > *self,unsigned int idx,int val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
SWIGINTERN int std_vector_Sl_int_Sg____len(std::vector<int > *self){
				return (*self).size();
			}
SWIGINTERN float std_vector_Sl_float_Sg____getitem__(std::vector<float > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_float_Sg____setitem__(std::vector<float > *self,unsigned int idx,float val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
SWIGINTERN int std_vector_Sl_float_Sg____len(std::vector<float > *self){
				return (*self).size();
			}
SWIGINTERN char std_vector_Sl_char_Sg____getitem__(std::vector<char > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_char_Sg____setitem__(std::vector<char > *self,unsigned int idx,char val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
SWIGINTERN int std_vector_Sl_char_Sg____len(std::vector<char > *self){
				return (*self).size();
			}
SWIGINTERN short std_vector_Sl_short_Sg____getitem__(std::vector<short > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_short_Sg____setitem__(std::vector<short > *self,unsigned int idx,short val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
SWIGINTERN int std_vector_Sl_short_Sg____len(std::vector<short > *self){
				return (*self).size();
			}
SWIGINTERN void MdlObject_NewPolyMesh(MdlObject *self){
		delete self->geometry;
		self->geometry = new PolyMesh;
	}
SWIGINTERN void Model_SetRoot(Model *self,MdlObject *o){
		self->root = o;
	}
SWIGINTERN Poly *std_vector_Sl_Poly_Sm__Sg____getitem__(std::vector<Poly * > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_Poly_Sm__Sg____setitem__(std::vector<Poly * > *self,unsigned int idx,Poly *val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
SWIGINTERN int std_vector_Sl_Poly_Sm__Sg____len(std::vector<Poly * > *self){
				return (*self).size();
			}
SWIGINTERN Vertex std_vector_Sl_Vertex_Sg____getitem__(std::vector<Vertex > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_Vertex_Sg____setitem__(std::vector<Vertex > *self,unsigned int idx,Vertex val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
SWIGINTERN int std_vector_Sl_Vertex_Sg____len(std::vector<Vertex > *self){
				return (*self).size();
			}
SWIGINTERN Triangle std_vector_Sl_Triangle_Sg____getitem__(std::vector<Triangle > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_Triangle_Sg____setitem__(std::vector<Triangle > *self,unsigned int idx,Triangle val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
SWIGINTERN int std_vector_Sl_Triangle_Sg____len(std::vector<Triangle > *self){
				return (*self).size();
			}
SWIGINTERN MdlObject *std_vector_Sl_MdlObject_Sm__Sg____getitem__(std::vector<MdlObject * > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_MdlObject_Sm__Sg____setitem__(std::vector<MdlObject * > *self,unsigned int idx,MdlObject *val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
SWIGINTERN int std_vector_Sl_MdlObject_Sm__Sg____len(std::vector<MdlObject * > *self){
				return (*self).size();
			}
SWIGINTERN AnimationInfo *std_vector_Sl_AnimationInfo_Sm__Sg____getitem__(std::vector<AnimationInfo * > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_AnimationInfo_Sm__Sg____setitem__(std::vector<AnimationInfo * > *self,unsigned int idx,AnimationInfo *val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
SWIGINTERN int std_vector_Sl_AnimationInfo_Sm__Sg____len(std::vector<AnimationInfo * > *self){
				return (*self).size();
			}
SWIGINTERN int std_list_Sl_AnimationInfo_Sg____len(std::list<AnimationInfo > *self){
				return (*self).size();
			}
SWIGINTERN AnimationInfo std_list_iterator_Sl_AnimationInfo_Sg__value(std::list_iterator<AnimationInfo > *self){ return *(*self); }
SWIGINTERN void std_list_iterator_Sl_AnimationInfo_Sg__next(std::list_iterator<AnimationInfo > *self){ ++(*self); }
SWIGINTERN void std_list_iterator_Sl_AnimationInfo_Sg__prev(std::list_iterator<AnimationInfo > *self){ --(*self); }
SWIGINTERN bool std_list_iterator_Sl_AnimationInfo_Sg__operator_Se__Se_(std::list_iterator<AnimationInfo > *self,std::list_iterator<AnimationInfo > const &li){ return (list<AnimationInfo>::iterator)li == (list<AnimationInfo>::iterator)*self; }
SWIGINTERN AnimationInfo std_list_reverse_iterator_Sl_AnimationInfo_Sg__value(std::list_reverse_iterator<AnimationInfo > *self){ return *(*self); }
SWIGINTERN void std_list_reverse_iterator_Sl_AnimationInfo_Sg__next(std::list_reverse_iterator<AnimationInfo > *self){ ++(*self); }
SWIGINTERN void std_list_reverse_iterator_Sl_AnimationInfo_Sg__prev(std::list_reverse_iterator<AnimationInfo > *self){ --(*self); }
SWIGINTERN bool std_list_reverse_iterator_Sl_AnimationInfo_Sg__operator_Se__Se_(std::list_reverse_iterator<AnimationInfo > *self,std::list_reverse_iterator<AnimationInfo > const &li){ return (list<AnimationInfo>::reverse_iterator)li == (list<AnimationInfo>::reverse_iterator)*self; }
SWIGINTERN int std_list_Sl_AnimProperty_Sg____len(std::list<AnimProperty > *self){
				return (*self).size();
			}
SWIGINTERN AnimProperty std_list_iterator_Sl_AnimProperty_Sg__value(std::list_iterator<AnimProperty > *self){ return *(*self); }
SWIGINTERN void std_list_iterator_Sl_AnimProperty_Sg__next(std::list_iterator<AnimProperty > *self){ ++(*self); }
SWIGINTERN void std_list_iterator_Sl_AnimProperty_Sg__prev(std::list_iterator<AnimProperty > *self){ --(*self); }
SWIGINTERN bool std_list_iterator_Sl_AnimProperty_Sg__operator_Se__Se_(std::list_iterator<AnimProperty > *self,std::list_iterator<AnimProperty > const &li){ return (list<AnimProperty>::iterator)li == (list<AnimProperty>::iterator)*self; }
SWIGINTERN AnimProperty std_list_reverse_iterator_Sl_AnimProperty_Sg__value(std::list_reverse_iterator<AnimProperty > *self){ return *(*self); }
SWIGINTERN void std_list_reverse_iterator_Sl_AnimProperty_Sg__next(std::list_reverse_iterator<AnimProperty > *self){ ++(*self); }
SWIGINTERN void std_list_reverse_iterator_Sl_AnimProperty_Sg__prev(std::list_reverse_iterator<AnimProperty > *self){ --(*self); }
SWIGINTERN bool std_list_reverse_iterator_Sl_AnimProperty_Sg__operator_Se__Se_(std::list_reverse_iterator<AnimProperty > *self,std::list_reverse_iterator<AnimProperty > const &li){ return (list<AnimProperty>::reverse_iterator)li == (list<AnimProperty>::reverse_iterator)*self; }
SWIGINTERN AnimProperty *std_vector_Sl_AnimProperty_Sm__Sg____getitem__(std::vector<AnimProperty * > *self,unsigned int idx){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__getitem__()");
				return (*self)[idx];
			}
SWIGINTERN void std_vector_Sl_AnimProperty_Sm__Sg____setitem__(std::vector<AnimProperty * > *self,unsigned int idx,AnimProperty *val){
				if (idx>=self->size())
					throw std::out_of_range("in vector::__setitem__()");
				(*self)[idx]=val;
			}
SWIGINTERN int std_vector_Sl_AnimProperty_Sm__Sg____len(std::vector<AnimProperty * > *self){
				return (*self).size();
			}

Model* upsGetModel() { return upsGetEditor()->GetMdl(); }
MdlObject* upsGetRootObj() { return upsGetEditor()->GetMdl()->root; }
void upsUpdateViews() { upsGetEditor()->Update(); }
bool _upsFileSaveDlg (const char *msg, const char *pattern, string& fn) { return FileSaveDlg(msg, pattern, fn); }
bool _upsFileOpenDlg (const char *msg, const char *pattern, string& fn) { return FileOpenDlg(msg, pattern, fn); }


#define ANIMTYPE_FLOAT 0
#define ANIMTYPE_VECTOR3 1
#define ANIMTYPE_ROTATION 2
#define ANIMTYPE_OTHER 3

int upsAnimGetType(AnimProperty& prop) 
{
	switch(prop.controller->GetType()) {
	case AnimController::ANIMKEY_Float: return ANIMTYPE_FLOAT;
	case AnimController::ANIMKEY_Vector3: return ANIMTYPE_VECTOR3;
	case AnimController::ANIMKEY_Quat: return ANIMTYPE_ROTATION;
	case AnimController::ANIMKEY_Other: return ANIMTYPE_OTHER;
	}
	return -1;
}

int upsAnimGetKeyIndex(AnimProperty& prop, float time) 
{
	return prop.GetKeyIndex(time);
}

int upsAnimGetNumKeys(AnimProperty& prop) 
{
	return prop.NumKeys();
}

float upsAnimGetKeyTime(AnimProperty& prop, int key) 
{
	if(key<0) key=0;
	if(key>=prop.NumKeys()) key=prop.NumKeys()-1;
	return prop.GetKeyTime(key);
}

float upsAnimGetFloatKey(AnimProperty& prop, int key) 
{
	if(key<0) key=0;
	if(key>=prop.NumKeys()) key=prop.NumKeys()-1;
	if (prop.controller->GetType() == AnimController::ANIMKEY_Float)
		return *(float*)prop.GetKeyData(key);
	return 0.0f;
}

Vector3 upsAnimGetVector3Key(AnimProperty& prop, int key) 
{
	if(key<0) key=0;
	if(key>=prop.NumKeys()) key=prop.NumKeys()-1;
	if (prop.controller->GetType() == AnimController::ANIMKEY_Vector3)
		return *(Vector3*)prop.GetKeyData(key);
	return Vector3();
}

Vector3 upsAnimGetRotationKey(AnimProperty& prop, int key) 
{
	if(key<0) key=0;
	if(key>=prop.NumKeys()) key=prop.NumKeys()-1;
	if (prop.controller->GetType() == AnimController::ANIMKEY_Quat) {
		Quaternion q = *(Quaternion*)prop.GetKeyData(key);
		Rotator rot;
		rot.SetQuat(q);
		return rot.GetEuler();
	} else if(prop.controller->GetType() == AnimController::ANIMKEY_Vector3) {
		Vector3 v = *(Vector3*)prop.GetKeyData(key);
		return v;
	}
	return Vector3();
}


void upsAnimInsertVectorKey(AnimProperty& prop, float time, Vector3 v) 
{
	switch(prop.controller->GetType()) {
	case AnimController::ANIMKEY_Vector3:
		prop.InsertKey(&v, time);
		break;
	case AnimController::ANIMKEY_Quat: {
		Rotator rot;
		rot.SetEuler(v);
		Quaternion q = rot.GetQuat();
		prop.InsertKey(&q, time);
		break; }
	}
}

void upsAnimInsertRotatorKey(AnimProperty& prop, float time, Rotator r)
{
	if (prop.controller->GetType() == AnimController::ANIMKEY_Quat) {
		Quaternion q = r.GetQuat();
		prop.InsertKey(&q, time);
	}
	else if (prop.controller->GetType() == AnimController::ANIMKEY_Vector3) {
		Vector3 v = r.GetEuler();
		prop.InsertKey(&v, time);
	}
}

void upsAnimInsertFloatKey(AnimProperty& prop, float time, float val) 
{
	if (prop.controller->GetType() == AnimController::ANIMKEY_Float)
		prop.InsertKey(&val, time);
}




#ifdef __cplusplus
extern "C" {
#endif
static int _wrap_new_cppstring__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  std::string *result = 0 ;
  
  result = (std::string *)new std::string();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__string,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_cppstring__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  char *arg1 = (char *) 0 ;
  std::string *result = 0 ;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  arg1 = (char *)lua_tostring(L, 1);
  result = (std::string *)new std::string((char const *)arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__string,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_cppstring(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_cppstring__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_cppstring__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_cppstring'");
  lua_error(L);return 0;
}


static int _wrap_cppstring_size(lua_State* L) {
  int SWIG_arg = -1;
  std::string *arg1 = (std::string *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("cppstring_size",1,SWIGTYPE_p_std__string);
  }
  
  result = (unsigned int)((std::string const *)arg1)->size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_cppstring_length(lua_State* L) {
  int SWIG_arg = -1;
  std::string *arg1 = (std::string *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("cppstring_length",1,SWIGTYPE_p_std__string);
  }
  
  result = (unsigned int)((std::string const *)arg1)->length();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_cppstring_empty(lua_State* L) {
  int SWIG_arg = -1;
  std::string *arg1 = (std::string *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("cppstring_empty",1,SWIGTYPE_p_std__string);
  }
  
  result = (bool)((std::string const *)arg1)->empty();
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_cppstring_c_str(lua_State* L) {
  int SWIG_arg = -1;
  std::string *arg1 = (std::string *) 0 ;
  char *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("cppstring_c_str",1,SWIGTYPE_p_std__string);
  }
  
  result = (char *)((std::string const *)arg1)->c_str();
  SWIG_arg=0;
  lua_pushstring(L,(const char*)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_cppstring_data(lua_State* L) {
  int SWIG_arg = -1;
  std::string *arg1 = (std::string *) 0 ;
  char *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("cppstring_data",1,SWIGTYPE_p_std__string);
  }
  
  result = (char *)((std::string const *)arg1)->data();
  SWIG_arg=0;
  lua_pushstring(L,(const char*)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_cppstring_assign(lua_State* L) {
  int SWIG_arg = -1;
  std::string *arg1 = (std::string *) 0 ;
  char *arg2 = (char *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("cppstring_assign",1,SWIGTYPE_p_std__string);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  (arg1)->assign((char const *)arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_cppstring(lua_State* L) {
  int SWIG_arg = -1;
  std::string *arg1 = (std::string *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("delete_cppstring",1,SWIGTYPE_p_std__string);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_cppstring(void *obj) {
std::string *arg1 = (std::string *) obj;
delete arg1;
}
static swig_lua_method swig_std_string_methods[] = {
    {"size", _wrap_cppstring_size}, 
    {"length", _wrap_cppstring_length}, 
    {"empty", _wrap_cppstring_empty}, 
    {"c_str", _wrap_cppstring_c_str}, 
    {"data", _wrap_cppstring_data}, 
    {"assign", _wrap_cppstring_assign}, 
    {0,0}
};
static swig_lua_attribute swig_std_string_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_string_bases[] = {0};
swig_lua_class _wrap_class_std_string = { "cppstring", &SWIGTYPE_p_std__string,_wrap_new_cppstring, swig_delete_cppstring, swig_std_string_methods, swig_std_string_attributes, swig_std_string_bases };

static int _wrap_new_IntArray__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<int > *result = 0 ;
  
  result = (std::vector<int > *)new std::vector<int >();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTint_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_IntArray__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  std::vector<int > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector<int > *)new std::vector<int >(arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTint_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_IntArray__SWIG_2(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<int > *arg1 = 0 ;
  std::vector<int > *result = 0 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTint_t,0))){
    SWIG_fail_ptr("new_IntArray",1,SWIGTYPE_p_std__vectorTint_t);
  }
  
  result = (std::vector<int > *)new std::vector<int >((std::vector<int > const &)*arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTint_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_IntArray__SWIG_3(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  int arg2 ;
  std::vector<int > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  result = (std::vector<int > *)new std::vector<int >(arg1,arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTint_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_IntArray(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_IntArray__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorTint_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_IntArray__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_IntArray__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_IntArray__SWIG_3(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_IntArray'");
  lua_error(L);return 0;
}


static int _wrap_IntArray_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTint_t,0))){
    SWIG_fail_ptr("IntArray_size",1,SWIGTYPE_p_std__vectorTint_t);
  }
  
  result = (unsigned int)((std::vector<int > const *)arg1)->size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IntArray_max_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTint_t,0))){
    SWIG_fail_ptr("IntArray_max_size",1,SWIGTYPE_p_std__vectorTint_t);
  }
  
  result = (unsigned int)((std::vector<int > const *)arg1)->max_size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IntArray_empty(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTint_t,0))){
    SWIG_fail_ptr("IntArray_empty",1,SWIGTYPE_p_std__vectorTint_t);
  }
  
  result = (bool)((std::vector<int > const *)arg1)->empty();
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IntArray_clear(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTint_t,0))){
    SWIG_fail_ptr("IntArray_clear",1,SWIGTYPE_p_std__vectorTint_t);
  }
  
  (arg1)->clear();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IntArray_push_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  int arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTint_t,0))){
    SWIG_fail_ptr("IntArray_push_back",1,SWIGTYPE_p_std__vectorTint_t);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->push_back(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IntArray_pop_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTint_t,0))){
    SWIG_fail_ptr("IntArray_pop_back",1,SWIGTYPE_p_std__vectorTint_t);
  }
  
  (arg1)->pop_back();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IntArray_front(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTint_t,0))){
    SWIG_fail_ptr("IntArray_front",1,SWIGTYPE_p_std__vectorTint_t);
  }
  
  result = (int)((std::vector<int > const *)arg1)->front();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IntArray_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTint_t,0))){
    SWIG_fail_ptr("IntArray_back",1,SWIGTYPE_p_std__vectorTint_t);
  }
  
  result = (int)((std::vector<int > const *)arg1)->back();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IntArray___getitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  unsigned int arg2 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTint_t,0))){
    SWIG_fail_ptr("IntArray___getitem",1,SWIGTYPE_p_std__vectorTint_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  try {
    result = (int)std_vector_Sl_int_Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IntArray___setitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTint_t,0))){
    SWIG_fail_ptr("IntArray___setitem",1,SWIGTYPE_p_std__vectorTint_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  try {
    std_vector_Sl_int_Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IntArray___len(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTint_t,0))){
    SWIG_fail_ptr("IntArray___len",1,SWIGTYPE_p_std__vectorTint_t);
  }
  
  result = (int)std_vector_Sl_int_Sg____len(arg1);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_IntArray(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<int > *arg1 = (std::vector<int > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTint_t,0))){
    SWIG_fail_ptr("delete_IntArray",1,SWIGTYPE_p_std__vectorTint_t);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_IntArray(void *obj) {
std::vector<int > *arg1 = (std::vector<int > *) obj;
delete arg1;
}
static swig_lua_method swig_std_vector_Sl_int_Sg__methods[] = {
    {"size", _wrap_IntArray_size}, 
    {"max_size", _wrap_IntArray_max_size}, 
    {"empty", _wrap_IntArray_empty}, 
    {"clear", _wrap_IntArray_clear}, 
    {"push_back", _wrap_IntArray_push_back}, 
    {"pop_back", _wrap_IntArray_pop_back}, 
    {"front", _wrap_IntArray_front}, 
    {"back", _wrap_IntArray_back}, 
    {"__getitem", _wrap_IntArray___getitem}, 
    {"__setitem", _wrap_IntArray___setitem}, 
    {"__len", _wrap_IntArray___len}, 
    {0,0}
};
static swig_lua_attribute swig_std_vector_Sl_int_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_vector_Sl_int_Sg__bases[] = {0};
swig_lua_class _wrap_class_std_vector_Sl_int_Sg_ = { "IntArray", &SWIGTYPE_p_std__vectorTint_t,_wrap_new_IntArray, swig_delete_IntArray, swig_std_vector_Sl_int_Sg__methods, swig_std_vector_Sl_int_Sg__attributes, swig_std_vector_Sl_int_Sg__bases };

static int _wrap_new_FloatArray__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<float > *result = 0 ;
  
  result = (std::vector<float > *)new std::vector<float >();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTfloat_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_FloatArray__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  std::vector<float > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector<float > *)new std::vector<float >(arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTfloat_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_FloatArray__SWIG_2(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<float > *arg1 = 0 ;
  std::vector<float > *result = 0 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTfloat_t,0))){
    SWIG_fail_ptr("new_FloatArray",1,SWIGTYPE_p_std__vectorTfloat_t);
  }
  
  result = (std::vector<float > *)new std::vector<float >((std::vector<float > const &)*arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTfloat_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_FloatArray__SWIG_3(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  float arg2 ;
  std::vector<float > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  result = (std::vector<float > *)new std::vector<float >(arg1,arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTfloat_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_FloatArray(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_FloatArray__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorTfloat_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_FloatArray__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_FloatArray__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_FloatArray__SWIG_3(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_FloatArray'");
  lua_error(L);return 0;
}


static int _wrap_FloatArray_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<float > *arg1 = (std::vector<float > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTfloat_t,0))){
    SWIG_fail_ptr("FloatArray_size",1,SWIGTYPE_p_std__vectorTfloat_t);
  }
  
  result = (unsigned int)((std::vector<float > const *)arg1)->size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FloatArray_max_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<float > *arg1 = (std::vector<float > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTfloat_t,0))){
    SWIG_fail_ptr("FloatArray_max_size",1,SWIGTYPE_p_std__vectorTfloat_t);
  }
  
  result = (unsigned int)((std::vector<float > const *)arg1)->max_size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FloatArray_empty(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<float > *arg1 = (std::vector<float > *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTfloat_t,0))){
    SWIG_fail_ptr("FloatArray_empty",1,SWIGTYPE_p_std__vectorTfloat_t);
  }
  
  result = (bool)((std::vector<float > const *)arg1)->empty();
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FloatArray_clear(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<float > *arg1 = (std::vector<float > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTfloat_t,0))){
    SWIG_fail_ptr("FloatArray_clear",1,SWIGTYPE_p_std__vectorTfloat_t);
  }
  
  (arg1)->clear();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FloatArray_push_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<float > *arg1 = (std::vector<float > *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTfloat_t,0))){
    SWIG_fail_ptr("FloatArray_push_back",1,SWIGTYPE_p_std__vectorTfloat_t);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->push_back(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FloatArray_pop_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<float > *arg1 = (std::vector<float > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTfloat_t,0))){
    SWIG_fail_ptr("FloatArray_pop_back",1,SWIGTYPE_p_std__vectorTfloat_t);
  }
  
  (arg1)->pop_back();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FloatArray_front(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<float > *arg1 = (std::vector<float > *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTfloat_t,0))){
    SWIG_fail_ptr("FloatArray_front",1,SWIGTYPE_p_std__vectorTfloat_t);
  }
  
  result = (float)((std::vector<float > const *)arg1)->front();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FloatArray_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<float > *arg1 = (std::vector<float > *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTfloat_t,0))){
    SWIG_fail_ptr("FloatArray_back",1,SWIGTYPE_p_std__vectorTfloat_t);
  }
  
  result = (float)((std::vector<float > const *)arg1)->back();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FloatArray___getitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<float > *arg1 = (std::vector<float > *) 0 ;
  unsigned int arg2 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTfloat_t,0))){
    SWIG_fail_ptr("FloatArray___getitem",1,SWIGTYPE_p_std__vectorTfloat_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  try {
    result = (float)std_vector_Sl_float_Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FloatArray___setitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<float > *arg1 = (std::vector<float > *) 0 ;
  unsigned int arg2 ;
  float arg3 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTfloat_t,0))){
    SWIG_fail_ptr("FloatArray___setitem",1,SWIGTYPE_p_std__vectorTfloat_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  try {
    std_vector_Sl_float_Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FloatArray___len(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<float > *arg1 = (std::vector<float > *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTfloat_t,0))){
    SWIG_fail_ptr("FloatArray___len",1,SWIGTYPE_p_std__vectorTfloat_t);
  }
  
  result = (int)std_vector_Sl_float_Sg____len(arg1);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_FloatArray(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<float > *arg1 = (std::vector<float > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTfloat_t,0))){
    SWIG_fail_ptr("delete_FloatArray",1,SWIGTYPE_p_std__vectorTfloat_t);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_FloatArray(void *obj) {
std::vector<float > *arg1 = (std::vector<float > *) obj;
delete arg1;
}
static swig_lua_method swig_std_vector_Sl_float_Sg__methods[] = {
    {"size", _wrap_FloatArray_size}, 
    {"max_size", _wrap_FloatArray_max_size}, 
    {"empty", _wrap_FloatArray_empty}, 
    {"clear", _wrap_FloatArray_clear}, 
    {"push_back", _wrap_FloatArray_push_back}, 
    {"pop_back", _wrap_FloatArray_pop_back}, 
    {"front", _wrap_FloatArray_front}, 
    {"back", _wrap_FloatArray_back}, 
    {"__getitem", _wrap_FloatArray___getitem}, 
    {"__setitem", _wrap_FloatArray___setitem}, 
    {"__len", _wrap_FloatArray___len}, 
    {0,0}
};
static swig_lua_attribute swig_std_vector_Sl_float_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_vector_Sl_float_Sg__bases[] = {0};
swig_lua_class _wrap_class_std_vector_Sl_float_Sg_ = { "FloatArray", &SWIGTYPE_p_std__vectorTfloat_t,_wrap_new_FloatArray, swig_delete_FloatArray, swig_std_vector_Sl_float_Sg__methods, swig_std_vector_Sl_float_Sg__attributes, swig_std_vector_Sl_float_Sg__bases };

static int _wrap_new_CharArray__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<char > *result = 0 ;
  
  result = (std::vector<char > *)new std::vector<char >();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTchar_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CharArray__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  std::vector<char > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector<char > *)new std::vector<char >(arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTchar_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CharArray__SWIG_2(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<char > *arg1 = 0 ;
  std::vector<char > *result = 0 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTchar_t,0))){
    SWIG_fail_ptr("new_CharArray",1,SWIGTYPE_p_std__vectorTchar_t);
  }
  
  result = (std::vector<char > *)new std::vector<char >((std::vector<char > const &)*arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTchar_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CharArray__SWIG_3(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  char arg2 ;
  std::vector<char > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  arg2 = ((char*)lua_tostring(L, 2))[0];
  result = (std::vector<char > *)new std::vector<char >(arg1,arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTchar_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_CharArray(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_CharArray__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorTchar_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_CharArray__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_CharArray__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]) && (lua_strlen(L,argv[1])==1);
      }
      if (_v) {
        return _wrap_new_CharArray__SWIG_3(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_CharArray'");
  lua_error(L);return 0;
}


static int _wrap_CharArray_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<char > *arg1 = (std::vector<char > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTchar_t,0))){
    SWIG_fail_ptr("CharArray_size",1,SWIGTYPE_p_std__vectorTchar_t);
  }
  
  result = (unsigned int)((std::vector<char > const *)arg1)->size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CharArray_max_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<char > *arg1 = (std::vector<char > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTchar_t,0))){
    SWIG_fail_ptr("CharArray_max_size",1,SWIGTYPE_p_std__vectorTchar_t);
  }
  
  result = (unsigned int)((std::vector<char > const *)arg1)->max_size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CharArray_empty(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<char > *arg1 = (std::vector<char > *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTchar_t,0))){
    SWIG_fail_ptr("CharArray_empty",1,SWIGTYPE_p_std__vectorTchar_t);
  }
  
  result = (bool)((std::vector<char > const *)arg1)->empty();
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CharArray_clear(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<char > *arg1 = (std::vector<char > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTchar_t,0))){
    SWIG_fail_ptr("CharArray_clear",1,SWIGTYPE_p_std__vectorTchar_t);
  }
  
  (arg1)->clear();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CharArray_push_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<char > *arg1 = (std::vector<char > *) 0 ;
  char arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTchar_t,0))){
    SWIG_fail_ptr("CharArray_push_back",1,SWIGTYPE_p_std__vectorTchar_t);
  }
  
  arg2 = ((char*)lua_tostring(L, 2))[0];
  (arg1)->push_back(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CharArray_pop_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<char > *arg1 = (std::vector<char > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTchar_t,0))){
    SWIG_fail_ptr("CharArray_pop_back",1,SWIGTYPE_p_std__vectorTchar_t);
  }
  
  (arg1)->pop_back();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CharArray_front(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<char > *arg1 = (std::vector<char > *) 0 ;
  char result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTchar_t,0))){
    SWIG_fail_ptr("CharArray_front",1,SWIGTYPE_p_std__vectorTchar_t);
  }
  
  result = (char)((std::vector<char > const *)arg1)->front();
  SWIG_arg=0;
  lua_pushfstring(L,"%c",result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CharArray_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<char > *arg1 = (std::vector<char > *) 0 ;
  char result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTchar_t,0))){
    SWIG_fail_ptr("CharArray_back",1,SWIGTYPE_p_std__vectorTchar_t);
  }
  
  result = (char)((std::vector<char > const *)arg1)->back();
  SWIG_arg=0;
  lua_pushfstring(L,"%c",result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CharArray___getitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<char > *arg1 = (std::vector<char > *) 0 ;
  unsigned int arg2 ;
  char result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTchar_t,0))){
    SWIG_fail_ptr("CharArray___getitem",1,SWIGTYPE_p_std__vectorTchar_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  try {
    result = (char)std_vector_Sl_char_Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  lua_pushfstring(L,"%c",result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CharArray___setitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<char > *arg1 = (std::vector<char > *) 0 ;
  unsigned int arg2 ;
  char arg3 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isstring(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTchar_t,0))){
    SWIG_fail_ptr("CharArray___setitem",1,SWIGTYPE_p_std__vectorTchar_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  arg3 = ((char*)lua_tostring(L, 3))[0];
  try {
    std_vector_Sl_char_Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CharArray___len(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<char > *arg1 = (std::vector<char > *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTchar_t,0))){
    SWIG_fail_ptr("CharArray___len",1,SWIGTYPE_p_std__vectorTchar_t);
  }
  
  result = (int)std_vector_Sl_char_Sg____len(arg1);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_CharArray(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<char > *arg1 = (std::vector<char > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTchar_t,0))){
    SWIG_fail_ptr("delete_CharArray",1,SWIGTYPE_p_std__vectorTchar_t);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_CharArray(void *obj) {
std::vector<char > *arg1 = (std::vector<char > *) obj;
delete arg1;
}
static swig_lua_method swig_std_vector_Sl_char_Sg__methods[] = {
    {"size", _wrap_CharArray_size}, 
    {"max_size", _wrap_CharArray_max_size}, 
    {"empty", _wrap_CharArray_empty}, 
    {"clear", _wrap_CharArray_clear}, 
    {"push_back", _wrap_CharArray_push_back}, 
    {"pop_back", _wrap_CharArray_pop_back}, 
    {"front", _wrap_CharArray_front}, 
    {"back", _wrap_CharArray_back}, 
    {"__getitem", _wrap_CharArray___getitem}, 
    {"__setitem", _wrap_CharArray___setitem}, 
    {"__len", _wrap_CharArray___len}, 
    {0,0}
};
static swig_lua_attribute swig_std_vector_Sl_char_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_vector_Sl_char_Sg__bases[] = {0};
swig_lua_class _wrap_class_std_vector_Sl_char_Sg_ = { "CharArray", &SWIGTYPE_p_std__vectorTchar_t,_wrap_new_CharArray, swig_delete_CharArray, swig_std_vector_Sl_char_Sg__methods, swig_std_vector_Sl_char_Sg__attributes, swig_std_vector_Sl_char_Sg__bases };

static int _wrap_new_ShortArray__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<short > *result = 0 ;
  
  result = (std::vector<short > *)new std::vector<short >();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTshort_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ShortArray__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  std::vector<short > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector<short > *)new std::vector<short >(arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTshort_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ShortArray__SWIG_2(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<short > *arg1 = 0 ;
  std::vector<short > *result = 0 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTshort_t,0))){
    SWIG_fail_ptr("new_ShortArray",1,SWIGTYPE_p_std__vectorTshort_t);
  }
  
  result = (std::vector<short > *)new std::vector<short >((std::vector<short > const &)*arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTshort_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ShortArray__SWIG_3(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  short arg2 ;
  std::vector<short > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  arg2 = (short)lua_tonumber(L, 2);
  result = (std::vector<short > *)new std::vector<short >(arg1,arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTshort_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ShortArray(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_ShortArray__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorTshort_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_ShortArray__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_ShortArray__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_ShortArray__SWIG_3(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_ShortArray'");
  lua_error(L);return 0;
}


static int _wrap_ShortArray_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<short > *arg1 = (std::vector<short > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTshort_t,0))){
    SWIG_fail_ptr("ShortArray_size",1,SWIGTYPE_p_std__vectorTshort_t);
  }
  
  result = (unsigned int)((std::vector<short > const *)arg1)->size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShortArray_max_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<short > *arg1 = (std::vector<short > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTshort_t,0))){
    SWIG_fail_ptr("ShortArray_max_size",1,SWIGTYPE_p_std__vectorTshort_t);
  }
  
  result = (unsigned int)((std::vector<short > const *)arg1)->max_size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShortArray_empty(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<short > *arg1 = (std::vector<short > *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTshort_t,0))){
    SWIG_fail_ptr("ShortArray_empty",1,SWIGTYPE_p_std__vectorTshort_t);
  }
  
  result = (bool)((std::vector<short > const *)arg1)->empty();
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShortArray_clear(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<short > *arg1 = (std::vector<short > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTshort_t,0))){
    SWIG_fail_ptr("ShortArray_clear",1,SWIGTYPE_p_std__vectorTshort_t);
  }
  
  (arg1)->clear();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShortArray_push_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<short > *arg1 = (std::vector<short > *) 0 ;
  short arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTshort_t,0))){
    SWIG_fail_ptr("ShortArray_push_back",1,SWIGTYPE_p_std__vectorTshort_t);
  }
  
  arg2 = (short)lua_tonumber(L, 2);
  (arg1)->push_back(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShortArray_pop_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<short > *arg1 = (std::vector<short > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTshort_t,0))){
    SWIG_fail_ptr("ShortArray_pop_back",1,SWIGTYPE_p_std__vectorTshort_t);
  }
  
  (arg1)->pop_back();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShortArray_front(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<short > *arg1 = (std::vector<short > *) 0 ;
  short result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTshort_t,0))){
    SWIG_fail_ptr("ShortArray_front",1,SWIGTYPE_p_std__vectorTshort_t);
  }
  
  result = (short)((std::vector<short > const *)arg1)->front();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShortArray_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<short > *arg1 = (std::vector<short > *) 0 ;
  short result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTshort_t,0))){
    SWIG_fail_ptr("ShortArray_back",1,SWIGTYPE_p_std__vectorTshort_t);
  }
  
  result = (short)((std::vector<short > const *)arg1)->back();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShortArray___getitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<short > *arg1 = (std::vector<short > *) 0 ;
  unsigned int arg2 ;
  short result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTshort_t,0))){
    SWIG_fail_ptr("ShortArray___getitem",1,SWIGTYPE_p_std__vectorTshort_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  try {
    result = (short)std_vector_Sl_short_Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShortArray___setitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<short > *arg1 = (std::vector<short > *) 0 ;
  unsigned int arg2 ;
  short arg3 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTshort_t,0))){
    SWIG_fail_ptr("ShortArray___setitem",1,SWIGTYPE_p_std__vectorTshort_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  arg3 = (short)lua_tonumber(L, 3);
  try {
    std_vector_Sl_short_Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ShortArray___len(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<short > *arg1 = (std::vector<short > *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTshort_t,0))){
    SWIG_fail_ptr("ShortArray___len",1,SWIGTYPE_p_std__vectorTshort_t);
  }
  
  result = (int)std_vector_Sl_short_Sg____len(arg1);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_ShortArray(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<short > *arg1 = (std::vector<short > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTshort_t,0))){
    SWIG_fail_ptr("delete_ShortArray",1,SWIGTYPE_p_std__vectorTshort_t);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ShortArray(void *obj) {
std::vector<short > *arg1 = (std::vector<short > *) obj;
delete arg1;
}
static swig_lua_method swig_std_vector_Sl_short_Sg__methods[] = {
    {"size", _wrap_ShortArray_size}, 
    {"max_size", _wrap_ShortArray_max_size}, 
    {"empty", _wrap_ShortArray_empty}, 
    {"clear", _wrap_ShortArray_clear}, 
    {"push_back", _wrap_ShortArray_push_back}, 
    {"pop_back", _wrap_ShortArray_pop_back}, 
    {"front", _wrap_ShortArray_front}, 
    {"back", _wrap_ShortArray_back}, 
    {"__getitem", _wrap_ShortArray___getitem}, 
    {"__setitem", _wrap_ShortArray___setitem}, 
    {"__len", _wrap_ShortArray___len}, 
    {0,0}
};
static swig_lua_attribute swig_std_vector_Sl_short_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_vector_Sl_short_Sg__bases[] = {0};
swig_lua_class _wrap_class_std_vector_Sl_short_Sg_ = { "ShortArray", &SWIGTYPE_p_std__vectorTshort_t,_wrap_new_ShortArray, swig_delete_ShortArray, swig_std_vector_Sl_short_Sg__methods, swig_std_vector_Sl_short_Sg__attributes, swig_std_vector_Sl_short_Sg__bases };

static int _wrap_d_trace(lua_State* L) {
  int SWIG_arg = -1;
  char *arg1 = (char *) 0 ;
  void *arg2 = 0 ;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  arg1 = (char *)lua_tostring(L, 1);
  d_trace((char const *)arg1,arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_d_puts(lua_State* L) {
  int SWIG_arg = -1;
  char *arg1 = (char *) 0 ;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  arg1 = (char *)lua_tostring(L, 1);
  d_puts((char const *)arg1);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_d_assert(lua_State* L) {
  int SWIG_arg = -1;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  d_assert(arg1,arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_d_clearlog(lua_State* L) {
  int SWIG_arg = -1;
  
  d_clearlog();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_d_setlogfile(lua_State* L) {
  int SWIG_arg = -1;
  char *arg1 = (char *) 0 ;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  arg1 = (char *)lua_tostring(L, 1);
  d_setlogfile((char const *)arg1);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector3__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *result = 0 ;
  
  result = (Vector3 *)new Vector3();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector3__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  Vector3 *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (Vector3 *)new Vector3(arg1,arg2,arg3);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector3(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Vector3__SWIG_0(L);
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_Vector3__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_Vector3'");
  lua_error(L);return 0;
}


static int _wrap_Vector3_set__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!lua_isnumber(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_set",1,SWIGTYPE_p_Vector3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->set(arg2,arg3,arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_set__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  float *arg2 = (float *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_set",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vector3_set",2,SWIGTYPE_p_float);
  }
  
  (arg1)->set(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_set(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector3_set__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Vector3_set__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Vector3_set'");
  lua_error(L);return 0;
}


static int _wrap_Vector3_sub(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_sub",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_sub",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->sub((Vector3 const *)arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_mul(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_mul",1,SWIGTYPE_p_Vector3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->mul(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_add(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_add",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_add",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->add((Vector3 const *)arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_dot__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_dot",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_dot",2,SWIGTYPE_p_Vector3);
  }
  
  result = (float)(arg1)->dot((Vector3 const *)arg2);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_dot__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_dot",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_dot",2,SWIGTYPE_p_Vector3);
  }
  
  result = (float)(arg1)->dot((Vector3 const &)*arg2);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_dot(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector3_dot__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector3_dot__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Vector3_dot'");
  lua_error(L);return 0;
}


static int _wrap_Vector3___add(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = 0 ;
  Vector3 result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3___add",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3___add",2,SWIGTYPE_p_Vector3);
  }
  
  result = ((Vector3 const *)arg1)->operator +((Vector3 const &)*arg2);
  SWIG_arg=0;
  {
    Vector3 * resultptr = new Vector3((Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___sub(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = 0 ;
  Vector3 result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3___sub",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3___sub",2,SWIGTYPE_p_Vector3);
  }
  
  result = ((Vector3 const *)arg1)->operator -((Vector3 const &)*arg2);
  SWIG_arg=0;
  {
    Vector3 * resultptr = new Vector3((Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___mul__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  float arg2 ;
  Vector3 result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3___mul",1,SWIGTYPE_p_Vector3);
  }
  
  arg2 = (float const)lua_tonumber(L, 2);
  result = ((Vector3 const *)arg1)->operator *(arg2);
  SWIG_arg=0;
  {
    Vector3 * resultptr = new Vector3((Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___mul__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = 0 ;
  Vector3 result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3___mul",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3___mul",2,SWIGTYPE_p_Vector3);
  }
  
  result = ((Vector3 const *)arg1)->operator *((Vector3 const &)*arg2);
  SWIG_arg=0;
  {
    Vector3 * resultptr = new Vector3((Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___mul(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector3___mul__SWIG_1(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Vector3___mul__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Vector3___mul'");
  lua_error(L);return 0;
}


static int _wrap_Vector3___eq(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3___eq",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3___eq",2,SWIGTYPE_p_Vector3);
  }
  
  result = (bool)((Vector3 const *)arg1)->operator ==((Vector3 const &)*arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___unm(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3___unm",1,SWIGTYPE_p_Vector3);
  }
  
  result = ((Vector3 const *)arg1)->operator -();
  SWIG_arg=0;
  {
    Vector3 * resultptr = new Vector3((Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3___div(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  float arg2 ;
  Vector3 result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3___div",1,SWIGTYPE_p_Vector3);
  }
  
  arg2 = (float const)lua_tonumber(L, 2);
  result = ((Vector3 const *)arg1)->operator /(arg2);
  SWIG_arg=0;
  {
    Vector3 * resultptr = new Vector3((Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_crossproduct(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = 0 ;
  Vector3 result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_crossproduct",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_crossproduct",2,SWIGTYPE_p_Vector3);
  }
  
  result = ((Vector3 const *)arg1)->crossproduct((Vector3 const &)*arg2);
  SWIG_arg=0;
  {
    Vector3 * resultptr = new Vector3((Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_length(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_length",1,SWIGTYPE_p_Vector3);
  }
  
  result = (float)((Vector3 const *)arg1)->length();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_project(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = 0 ;
  Vector3 result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_project",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_project",2,SWIGTYPE_p_Vector3);
  }
  
  result = ((Vector3 const *)arg1)->project((Vector3 const &)*arg2);
  SWIG_arg=0;
  {
    Vector3 * resultptr = new Vector3((Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_projectf(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_projectf",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_projectf",2,SWIGTYPE_p_Vector3);
  }
  
  result = (float)((Vector3 const *)arg1)->projectf((Vector3 const &)*arg2);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_normalize(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_normalize",1,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->normalize();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_distance(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  Vector3 *arg3 = (Vector3 *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_distance",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_distance",2,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_distance",3,SWIGTYPE_p_Vector3);
  }
  
  result = (float)((Vector3 const *)arg1)->distance((Vector3 const *)arg2,(Vector3 const *)arg3);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_get_normal(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  Vector3 *arg3 = (Vector3 *) 0 ;
  Vector3 *arg4 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_get_normal",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_get_normal",2,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_get_normal",3,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_get_normal",4,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->get_normal((Vector3 const *)arg2,(Vector3 const *)arg3,(Vector3 const *)arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_getf(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  float *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_getf",1,SWIGTYPE_p_Vector3);
  }
  
  result = (float *)(arg1)->getf();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_incboundingmin(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_incboundingmin",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_incboundingmin",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->incboundingmin((Vector3 const *)arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_incboundingmax(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_incboundingmax",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_incboundingmax",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->incboundingmax((Vector3 const *)arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_epsilon_compare(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  float arg3 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_epsilon_compare",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_epsilon_compare",2,SWIGTYPE_p_Vector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (bool)((Vector3 const *)arg1)->epsilon_compare((Vector3 const *)arg2,arg3);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_copy__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  float *arg2 = (float *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_copy",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Vector3_copy",2,SWIGTYPE_p_float);
  }
  
  ((Vector3 const *)arg1)->copy(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_copy__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_copy",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_copy",2,SWIGTYPE_p_Vector3);
  }
  
  ((Vector3 const *)arg1)->copy(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_copy(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector3_copy__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Vector3_copy__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Vector3_copy'");
  lua_error(L);return 0;
}


static int _wrap_Vector3_x_set(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_x_set",1,SWIGTYPE_p_Vector3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_x_get(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_x_get",1,SWIGTYPE_p_Vector3);
  }
  
  result = (float) ((arg1)->x);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_y_set(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_y_set",1,SWIGTYPE_p_Vector3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_y_get(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_y_get",1,SWIGTYPE_p_Vector3);
  }
  
  result = (float) ((arg1)->y);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_z_set(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_z_set",1,SWIGTYPE_p_Vector3);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->z = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector3_z_get(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vector3_z_get",1,SWIGTYPE_p_Vector3);
  }
  
  result = (float) ((arg1)->z);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_Vector3(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("delete_Vector3",1,SWIGTYPE_p_Vector3);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Vector3(void *obj) {
Vector3 *arg1 = (Vector3 *) obj;
delete arg1;
}
static swig_lua_method swig_Vector3_methods[] = {
    {"set", _wrap_Vector3_set}, 
    {"sub", _wrap_Vector3_sub}, 
    {"mul", _wrap_Vector3_mul}, 
    {"add", _wrap_Vector3_add}, 
    {"dot", _wrap_Vector3_dot}, 
    {"__add", _wrap_Vector3___add}, 
    {"__sub", _wrap_Vector3___sub}, 
    {"__mul", _wrap_Vector3___mul}, 
    {"__eq", _wrap_Vector3___eq}, 
    {"__unm", _wrap_Vector3___unm}, 
    {"__div", _wrap_Vector3___div}, 
    {"crossproduct", _wrap_Vector3_crossproduct}, 
    {"length", _wrap_Vector3_length}, 
    {"project", _wrap_Vector3_project}, 
    {"projectf", _wrap_Vector3_projectf}, 
    {"normalize", _wrap_Vector3_normalize}, 
    {"distance", _wrap_Vector3_distance}, 
    {"get_normal", _wrap_Vector3_get_normal}, 
    {"getf", _wrap_Vector3_getf}, 
    {"incboundingmin", _wrap_Vector3_incboundingmin}, 
    {"incboundingmax", _wrap_Vector3_incboundingmax}, 
    {"epsilon_compare", _wrap_Vector3_epsilon_compare}, 
    {"copy", _wrap_Vector3_copy}, 
    {0,0}
};
static swig_lua_attribute swig_Vector3_attributes[] = {
    { "x",_wrap_Vector3_x_get, _wrap_Vector3_x_set},
    { "y",_wrap_Vector3_y_get, _wrap_Vector3_y_set},
    { "z",_wrap_Vector3_z_get, _wrap_Vector3_z_set},
    {0,0,0}
};
static swig_lua_class *swig_Vector3_bases[] = {0};
swig_lua_class _wrap_class_Vector3 = { "Vector3", &SWIGTYPE_p_Vector3,_wrap_new_Vector3, swig_delete_Vector3, swig_Vector3_methods, swig_Vector3_attributes, swig_Vector3_bases };

static int _wrap_new_Vector2__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  float arg1 ;
  float arg2 ;
  Vector2 *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  result = (Vector2 *)new Vector2(arg1,arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector2,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector2__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Vector2 *result = 0 ;
  
  result = (Vector2 *)new Vector2();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector2,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector2(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Vector2__SWIG_1(L);
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_Vector2__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_Vector2'");
  lua_error(L);return 0;
}


static int _wrap_Vector2_x_set(lua_State* L) {
  int SWIG_arg = -1;
  Vector2 *arg1 = (Vector2 *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector2,0))){
    SWIG_fail_ptr("Vector2_x_set",1,SWIGTYPE_p_Vector2);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_x_get(lua_State* L) {
  int SWIG_arg = -1;
  Vector2 *arg1 = (Vector2 *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector2,0))){
    SWIG_fail_ptr("Vector2_x_get",1,SWIGTYPE_p_Vector2);
  }
  
  result = (float) ((arg1)->x);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_y_set(lua_State* L) {
  int SWIG_arg = -1;
  Vector2 *arg1 = (Vector2 *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector2,0))){
    SWIG_fail_ptr("Vector2_y_set",1,SWIGTYPE_p_Vector2);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector2_y_get(lua_State* L) {
  int SWIG_arg = -1;
  Vector2 *arg1 = (Vector2 *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector2,0))){
    SWIG_fail_ptr("Vector2_y_get",1,SWIGTYPE_p_Vector2);
  }
  
  result = (float) ((arg1)->y);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_Vector2(lua_State* L) {
  int SWIG_arg = -1;
  Vector2 *arg1 = (Vector2 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector2,0))){
    SWIG_fail_ptr("delete_Vector2",1,SWIGTYPE_p_Vector2);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Vector2(void *obj) {
Vector2 *arg1 = (Vector2 *) obj;
delete arg1;
}
static swig_lua_method swig_Vector2_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_Vector2_attributes[] = {
    { "x",_wrap_Vector2_x_get, _wrap_Vector2_x_set},
    { "y",_wrap_Vector2_y_get, _wrap_Vector2_y_set},
    {0,0,0}
};
static swig_lua_class *swig_Vector2_bases[] = {0};
swig_lua_class _wrap_class_Vector2 = { "Vector2", &SWIGTYPE_p_Vector2,_wrap_new_Vector2, swig_delete_Vector2, swig_Vector2_methods, swig_Vector2_attributes, swig_Vector2_bases };

static int _wrap_new_Vector4__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  Vector4 *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!lua_isnumber(L,4)) SWIG_fail_arg(4);
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (Vector4 *)new Vector4(arg1,arg2,arg3,arg4);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector4,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  Vector4 *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (Vector4 *)new Vector4(arg1,arg2,arg3);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector4,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4__SWIG_2(lua_State* L) {
  int SWIG_arg = -1;
  float arg1 ;
  float arg2 ;
  Vector4 *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  result = (Vector4 *)new Vector4(arg1,arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector4,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4__SWIG_3(lua_State* L) {
  int SWIG_arg = -1;
  float arg1 ;
  Vector4 *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  arg1 = (float)lua_tonumber(L, 1);
  result = (Vector4 *)new Vector4(arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector4,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4__SWIG_4(lua_State* L) {
  int SWIG_arg = -1;
  Vector4 *result = 0 ;
  
  result = (Vector4 *)new Vector4();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector4,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Vector4(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Vector4__SWIG_4(L);
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_Vector4__SWIG_3(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_Vector4__SWIG_2(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_Vector4__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_Vector4__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_Vector4'");
  lua_error(L);return 0;
}


static int _wrap_Vector4_x_set(lua_State* L) {
  int SWIG_arg = -1;
  Vector4 *arg1 = (Vector4 *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector4,0))){
    SWIG_fail_ptr("Vector4_x_set",1,SWIGTYPE_p_Vector4);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_x_get(lua_State* L) {
  int SWIG_arg = -1;
  Vector4 *arg1 = (Vector4 *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector4,0))){
    SWIG_fail_ptr("Vector4_x_get",1,SWIGTYPE_p_Vector4);
  }
  
  result = (float) ((arg1)->x);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_y_set(lua_State* L) {
  int SWIG_arg = -1;
  Vector4 *arg1 = (Vector4 *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector4,0))){
    SWIG_fail_ptr("Vector4_y_set",1,SWIGTYPE_p_Vector4);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_y_get(lua_State* L) {
  int SWIG_arg = -1;
  Vector4 *arg1 = (Vector4 *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector4,0))){
    SWIG_fail_ptr("Vector4_y_get",1,SWIGTYPE_p_Vector4);
  }
  
  result = (float) ((arg1)->y);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_z_set(lua_State* L) {
  int SWIG_arg = -1;
  Vector4 *arg1 = (Vector4 *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector4,0))){
    SWIG_fail_ptr("Vector4_z_set",1,SWIGTYPE_p_Vector4);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->z = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_z_get(lua_State* L) {
  int SWIG_arg = -1;
  Vector4 *arg1 = (Vector4 *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector4,0))){
    SWIG_fail_ptr("Vector4_z_get",1,SWIGTYPE_p_Vector4);
  }
  
  result = (float) ((arg1)->z);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_w_set(lua_State* L) {
  int SWIG_arg = -1;
  Vector4 *arg1 = (Vector4 *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector4,0))){
    SWIG_fail_ptr("Vector4_w_set",1,SWIGTYPE_p_Vector4);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->w = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vector4_w_get(lua_State* L) {
  int SWIG_arg = -1;
  Vector4 *arg1 = (Vector4 *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector4,0))){
    SWIG_fail_ptr("Vector4_w_get",1,SWIGTYPE_p_Vector4);
  }
  
  result = (float) ((arg1)->w);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_Vector4(lua_State* L) {
  int SWIG_arg = -1;
  Vector4 *arg1 = (Vector4 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector4,0))){
    SWIG_fail_ptr("delete_Vector4",1,SWIGTYPE_p_Vector4);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Vector4(void *obj) {
Vector4 *arg1 = (Vector4 *) obj;
delete arg1;
}
static swig_lua_method swig_Vector4_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_Vector4_attributes[] = {
    { "x",_wrap_Vector4_x_get, _wrap_Vector4_x_set},
    { "y",_wrap_Vector4_y_get, _wrap_Vector4_y_set},
    { "z",_wrap_Vector4_z_get, _wrap_Vector4_z_set},
    { "w",_wrap_Vector4_w_get, _wrap_Vector4_w_set},
    {0,0,0}
};
static swig_lua_class *swig_Vector4_bases[] = {0};
swig_lua_class _wrap_class_Vector4 = { "Vector4", &SWIGTYPE_p_Vector4,_wrap_new_Vector4, swig_delete_Vector4, swig_Vector4_methods, swig_Vector4_attributes, swig_Vector4_bases };

static int _wrap_Plane_a_set(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_a_set",1,SWIGTYPE_p_Plane);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->a = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Plane_a_get(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_a_get",1,SWIGTYPE_p_Plane);
  }
  
  result = (float) ((arg1)->a);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Plane_b_set(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_b_set",1,SWIGTYPE_p_Plane);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->b = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Plane_b_get(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_b_get",1,SWIGTYPE_p_Plane);
  }
  
  result = (float) ((arg1)->b);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Plane_c_set(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_c_set",1,SWIGTYPE_p_Plane);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->c = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Plane_c_get(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_c_get",1,SWIGTYPE_p_Plane);
  }
  
  result = (float) ((arg1)->c);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Plane_d_set(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_d_set",1,SWIGTYPE_p_Plane);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->d = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Plane_d_get(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_d_get",1,SWIGTYPE_p_Plane);
  }
  
  result = (float) ((arg1)->d);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Plane__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Plane *result = 0 ;
  
  result = (Plane *)new Plane();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Plane,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Plane__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  Plane *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!lua_isnumber(L,4)) SWIG_fail_arg(4);
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (Plane *)new Plane(arg1,arg2,arg3,arg4);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Plane,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Plane__SWIG_2(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 arg1 ;
  float arg2 ;
  Plane *result = 0 ;
  Vector3 *argp1 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&argp1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("new_Plane",1,SWIGTYPE_Vector3);
  }
  arg1 = *argp1;
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (Plane *)new Plane(arg1,arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Plane,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Plane(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Plane__SWIG_0(L);
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_Vector3, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_new_Plane__SWIG_2(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_Plane__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_Plane'");
  lua_error(L);return 0;
}


static int _wrap_Plane_Dis__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_Dis",1,SWIGTYPE_p_Plane);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Plane_Dis",2,SWIGTYPE_p_Vector3);
  }
  
  result = (float)((Plane const *)arg1)->Dis((Vector3 const *)arg2);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Plane_Dis__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!lua_isnumber(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_Dis",1,SWIGTYPE_p_Plane);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (float)((Plane const *)arg1)->Dis(arg2,arg3,arg4);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Plane_Dis(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Plane, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Plane_Dis__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Plane, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Plane_Dis__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Plane_Dis'");
  lua_error(L);return 0;
}


static int _wrap_Plane_EpsilonCompare(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  Plane *arg2 = 0 ;
  float arg3 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_EpsilonCompare",1,SWIGTYPE_p_Plane);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_EpsilonCompare",2,SWIGTYPE_p_Plane);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (bool)(arg1)->EpsilonCompare((Plane const &)*arg2,arg3);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Plane_MakePlane(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  Vector3 *arg2 = 0 ;
  Vector3 *arg3 = 0 ;
  Vector3 *arg4 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  if(!lua_isuserdata(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_MakePlane",1,SWIGTYPE_p_Plane);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Plane_MakePlane",2,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Plane_MakePlane",3,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Plane_MakePlane",4,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->MakePlane((Vector3 const &)*arg2,(Vector3 const &)*arg3,(Vector3 const &)*arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Plane_Inverse(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_Inverse",1,SWIGTYPE_p_Plane);
  }
  
  (arg1)->Inverse();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Plane_SetVec(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  Vector3 arg2 ;
  Vector3 *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_SetVec",1,SWIGTYPE_p_Plane);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Plane_SetVec",2,SWIGTYPE_Vector3);
  }
  arg2 = *argp2;
  
  (arg1)->SetVec(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Plane_CalcDis(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_CalcDis",1,SWIGTYPE_p_Plane);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Plane_CalcDis",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->CalcDis((Vector3 const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Plane_copy(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  Plane *arg2 = (Plane *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_copy",1,SWIGTYPE_p_Plane);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_copy",2,SWIGTYPE_p_Plane);
  }
  
  (arg1)->copy(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Plane_GetVector(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_GetVector",1,SWIGTYPE_p_Plane);
  }
  
  {
    Vector3 &_result_ref = (arg1)->GetVector();
    result = (Vector3 *) &_result_ref;
  }
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Plane_GetCenter(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  Vector3 result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("Plane_GetCenter",1,SWIGTYPE_p_Plane);
  }
  
  result = (arg1)->GetCenter();
  SWIG_arg=0;
  {
    Vector3 * resultptr = new Vector3((Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_Plane(lua_State* L) {
  int SWIG_arg = -1;
  Plane *arg1 = (Plane *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Plane,0))){
    SWIG_fail_ptr("delete_Plane",1,SWIGTYPE_p_Plane);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Plane(void *obj) {
Plane *arg1 = (Plane *) obj;
delete arg1;
}
static swig_lua_method swig_Plane_methods[] = {
    {"Dis", _wrap_Plane_Dis}, 
    {"EpsilonCompare", _wrap_Plane_EpsilonCompare}, 
    {"MakePlane", _wrap_Plane_MakePlane}, 
    {"Inverse", _wrap_Plane_Inverse}, 
    {"SetVec", _wrap_Plane_SetVec}, 
    {"CalcDis", _wrap_Plane_CalcDis}, 
    {"copy", _wrap_Plane_copy}, 
    {"GetVector", _wrap_Plane_GetVector}, 
    {"GetCenter", _wrap_Plane_GetCenter}, 
    {0,0}
};
static swig_lua_attribute swig_Plane_attributes[] = {
    { "a",_wrap_Plane_a_get, _wrap_Plane_a_set},
    { "b",_wrap_Plane_b_get, _wrap_Plane_b_set},
    { "c",_wrap_Plane_c_get, _wrap_Plane_c_set},
    { "d",_wrap_Plane_d_get, _wrap_Plane_d_set},
    {0,0,0}
};
static swig_lua_class *swig_Plane_bases[] = {0};
swig_lua_class _wrap_class_Plane = { "Plane", &SWIGTYPE_p_Plane,_wrap_new_Plane, swig_delete_Plane, swig_Plane_methods, swig_Plane_attributes, swig_Plane_bases };

static int _wrap_new_Matrix(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *result = 0 ;
  
  result = (Matrix *)new Matrix();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Matrix,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_vector_rotation(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = 0 ;
  float arg3 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_vector_rotation",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_vector_rotation",2,SWIGTYPE_p_Vector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->vector_rotation((Vector3 const &)*arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_translation__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!lua_isnumber(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_translation",1,SWIGTYPE_p_Matrix);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->translation(arg2,arg3,arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_translation__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_translation",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_translation",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->translation((Vector3 const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_translation(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Matrix_translation__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Matrix_translation__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Matrix_translation'");
  lua_error(L);return 0;
}


static int _wrap_Matrix_addtranslation(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_addtranslation",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_addtranslation",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->addtranslation((Vector3 const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_addscale__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_addscale",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_addscale",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->addscale((Vector3 const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_addscale__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!lua_isnumber(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_addscale",1,SWIGTYPE_p_Matrix);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->addscale(arg2,arg3,arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_addscale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Matrix_addscale__SWIG_0(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Matrix_addscale__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Matrix_addscale'");
  lua_error(L);return 0;
}


static int _wrap_Matrix_scale__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!lua_isnumber(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_scale",1,SWIGTYPE_p_Matrix);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->scale(arg2,arg3,arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_scale__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_scale",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_scale",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->scale((Vector3 const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_scale(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Matrix_scale__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Matrix_scale__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Matrix_scale'");
  lua_error(L);return 0;
}


static int _wrap_Matrix_camera(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  Vector3 *arg3 = (Vector3 *) 0 ;
  Vector3 *arg4 = (Vector3 *) 0 ;
  Vector3 *arg5 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg(4);
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg(5);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_camera",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_camera",2,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_camera",3,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_camera",4,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_camera",5,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->camera(arg2,arg3,arg4,arg5);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_transpose(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Matrix *arg2 = (Matrix *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_transpose",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_transpose",2,SWIGTYPE_p_Matrix);
  }
  
  ((Matrix const *)arg1)->transpose(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_apply__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  Vector3 *arg3 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_apply",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_apply",2,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_apply",3,SWIGTYPE_p_Vector3);
  }
  
  ((Matrix const *)arg1)->apply((Vector3 const *)arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_apply__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector4 *arg2 = (Vector4 *) 0 ;
  Vector4 *arg3 = (Vector4 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_apply",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector4,0))){
    SWIG_fail_ptr("Matrix_apply",2,SWIGTYPE_p_Vector4);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Vector4,0))){
    SWIG_fail_ptr("Matrix_apply",3,SWIGTYPE_p_Vector4);
  }
  
  ((Matrix const *)arg1)->apply((Vector4 const *)arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_apply(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Matrix_apply__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Vector4, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Vector4, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Matrix_apply__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Matrix_apply'");
  lua_error(L);return 0;
}


static int _wrap_Matrix_multiply__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Matrix *arg2 = 0 ;
  Matrix *arg3 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_multiply",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_multiply",2,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_multiply",3,SWIGTYPE_p_Matrix);
  }
  
  ((Matrix const *)arg1)->multiply((Matrix const &)*arg2,*arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_camera_pos(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_camera_pos",1,SWIGTYPE_p_Matrix);
  }
  
  result = ((Matrix const *)arg1)->camera_pos();
  SWIG_arg=0;
  {
    Vector3 * resultptr = new Vector3((Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix___mul__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Matrix *arg2 = 0 ;
  Matrix result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix___mul",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix___mul",2,SWIGTYPE_p_Matrix);
  }
  
  result = (arg1)->operator *((Matrix const &)*arg2);
  SWIG_arg=0;
  {
    Matrix * resultptr = new Matrix((Matrix &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Matrix,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix___mul__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  float arg2 ;
  Matrix result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix___mul",1,SWIGTYPE_p_Matrix);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (arg1)->operator *(arg2);
  SWIG_arg=0;
  {
    Matrix * resultptr = new Matrix((Matrix &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Matrix,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix___mul(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Matrix___mul__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Matrix___mul__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Matrix___mul'");
  lua_error(L);return 0;
}


static int _wrap_Matrix_align(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  Vector3 *arg3 = (Vector3 *) 0 ;
  Vector3 *arg4 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_align",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_align",2,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_align",3,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_align",4,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->align(arg2,arg3,arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_xrotate(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_xrotate",1,SWIGTYPE_p_Matrix);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->xrotate(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_yrotate(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_yrotate",1,SWIGTYPE_p_Matrix);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->yrotate(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_zrotate(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_zrotate",1,SWIGTYPE_p_Matrix);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->zrotate(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_eulerZXY__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!lua_isnumber(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_eulerZXY",1,SWIGTYPE_p_Matrix);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->eulerZXY(arg2,arg3,arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_eulerZXY__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_eulerZXY",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_eulerZXY",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->eulerZXY((Vector3 const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_eulerZXY(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Matrix_eulerZXY__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Matrix_eulerZXY__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Matrix_eulerZXY'");
  lua_error(L);return 0;
}


static int _wrap_Matrix_eulerYXZ__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!lua_isnumber(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_eulerYXZ",1,SWIGTYPE_p_Matrix);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->eulerYXZ(arg2,arg3,arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_eulerYXZ__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_eulerYXZ",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_eulerYXZ",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->eulerYXZ((Vector3 const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_eulerYXZ(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Matrix_eulerYXZ__SWIG_1(L);
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_Matrix_eulerYXZ__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Matrix_eulerYXZ'");
  lua_error(L);return 0;
}


static int _wrap_Matrix_calcEulerZXY(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_calcEulerZXY",1,SWIGTYPE_p_Matrix);
  }
  
  result = ((Matrix const *)arg1)->calcEulerZXY();
  SWIG_arg=0;
  {
    Vector3 * resultptr = new Vector3((Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_calcEulerYXZ(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_calcEulerYXZ",1,SWIGTYPE_p_Matrix);
  }
  
  result = ((Matrix const *)arg1)->calcEulerYXZ();
  SWIG_arg=0;
  {
    Vector3 * resultptr = new Vector3((Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_makequat(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Quaternion *arg2 = (Quaternion *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_makequat",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Matrix_makequat",2,SWIGTYPE_p_Quaternion);
  }
  
  ((Matrix const *)arg1)->makequat(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_identity(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_identity",1,SWIGTYPE_p_Matrix);
  }
  
  (arg1)->identity();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_clear(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_clear",1,SWIGTYPE_p_Matrix);
  }
  
  (arg1)->clear();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_inverse(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Matrix *arg2 = 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_inverse",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_inverse",2,SWIGTYPE_p_Matrix);
  }
  
  result = (bool)((Matrix const *)arg1)->inverse(*arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_determinant(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_determinant",1,SWIGTYPE_p_Matrix);
  }
  
  result = (float)((Matrix const *)arg1)->determinant();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_adjoint(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Matrix result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_adjoint",1,SWIGTYPE_p_Matrix);
  }
  
  result = ((Matrix const *)arg1)->adjoint();
  SWIG_arg=0;
  {
    Matrix * resultptr = new Matrix((Matrix &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Matrix,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_copy__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  float *arg2 = (float *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_copy",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Matrix_copy",2,SWIGTYPE_p_float);
  }
  
  (arg1)->copy(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_copy__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Matrix *arg2 = (Matrix *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_copy",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_copy",2,SWIGTYPE_p_Matrix);
  }
  
  (arg1)->copy(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_copy(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_float, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Matrix_copy__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Matrix_copy__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Matrix_copy'");
  lua_error(L);return 0;
}


static int _wrap_Matrix_perspective_lh(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!lua_isnumber(L,4)) SWIG_fail_arg(4);
  if(!lua_isnumber(L,5)) SWIG_fail_arg(5);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_perspective_lh",1,SWIGTYPE_p_Matrix);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  (arg1)->perspective_lh(arg2,arg3,arg4,arg5);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_multiply__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_multiply",1,SWIGTYPE_p_Matrix);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->multiply(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_multiply(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Matrix_multiply__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Matrix_multiply__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Matrix_multiply'");
  lua_error(L);return 0;
}


static int _wrap_Matrix_v__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  int arg2 ;
  int arg3 ;
  float *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_v",1,SWIGTYPE_p_Matrix);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  {
    float &_result_ref = (arg1)->v(arg2,arg3);
    result = (float *) &_result_ref;
  }
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_t__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  int arg2 ;
  float *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_t",1,SWIGTYPE_p_Matrix);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  {
    float &_result_ref = (arg1)->t(arg2);
    result = (float *) &_result_ref;
  }
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_v__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  int arg2 ;
  int arg3 ;
  float *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_v",1,SWIGTYPE_p_Matrix);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  {
    float const &_result_ref = ((Matrix const *)arg1)->v(arg2,arg3);
    result = (float *) &_result_ref;
  }
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) *result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_v(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Matrix_v__SWIG_0(L);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_Matrix_v__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Matrix_v'");
  lua_error(L);return 0;
}


static int _wrap_Matrix_t__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  int arg2 ;
  float *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_t",1,SWIGTYPE_p_Matrix);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  {
    float const &_result_ref = ((Matrix const *)arg1)->t(arg2);
    result = (float *) &_result_ref;
  }
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) *result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_t(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Matrix_t__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_Matrix_t__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Matrix_t'");
  lua_error(L);return 0;
}


static int _wrap_Matrix___call__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  size_t arg2 ;
  float *result = 0 ;
  size_t *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix___call",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_size_t,0))){
    SWIG_fail_ptr("Matrix___call",2,SWIGTYPE_size_t);
  }
  arg2 = *argp2;
  
  {
    float &_result_ref = (arg1)->operator ()(arg2);
    result = (float *) &_result_ref;
  }
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix___call__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  size_t arg2 ;
  float *result = 0 ;
  size_t *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix___call",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_size_t,0))){
    SWIG_fail_ptr("Matrix___call",2,SWIGTYPE_size_t);
  }
  arg2 = *argp2;
  
  {
    float const &_result_ref = ((Matrix const *)arg1)->operator ()(arg2);
    result = (float *) &_result_ref;
  }
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) *result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix___call(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_size_t, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Matrix___call__SWIG_0(L);
      }
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_size_t, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Matrix___call__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Matrix___call'");
  lua_error(L);return 0;
}


static int _wrap_Matrix_getx__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_getx",1,SWIGTYPE_p_Matrix);
  }
  
  result = (Vector3 *)(arg1)->getx();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_gety__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_gety",1,SWIGTYPE_p_Matrix);
  }
  
  result = (Vector3 *)(arg1)->gety();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_getz__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_getz",1,SWIGTYPE_p_Matrix);
  }
  
  result = (Vector3 *)(arg1)->getz();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_getw__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_getw",1,SWIGTYPE_p_Matrix);
  }
  
  result = (Vector3 *)(arg1)->getw();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_getx__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_getx",1,SWIGTYPE_p_Matrix);
  }
  
  result = (Vector3 *)((Matrix const *)arg1)->getx();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_getx(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Matrix_getx__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Matrix_getx__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Matrix_getx'");
  lua_error(L);return 0;
}


static int _wrap_Matrix_gety__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_gety",1,SWIGTYPE_p_Matrix);
  }
  
  result = (Vector3 *)((Matrix const *)arg1)->gety();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_gety(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Matrix_gety__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Matrix_gety__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Matrix_gety'");
  lua_error(L);return 0;
}


static int _wrap_Matrix_getz__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_getz",1,SWIGTYPE_p_Matrix);
  }
  
  result = (Vector3 *)((Matrix const *)arg1)->getz();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_getz(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Matrix_getz__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Matrix_getz__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Matrix_getz'");
  lua_error(L);return 0;
}


static int _wrap_Matrix_getw__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_getw",1,SWIGTYPE_p_Matrix);
  }
  
  result = (Vector3 *)((Matrix const *)arg1)->getw();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_getw(lua_State* L) {
  int argc;
  int argv[2]={
    1,2
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Matrix_getw__SWIG_0(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Matrix, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Matrix_getw__SWIG_1(L);
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Matrix_getw'");
  lua_error(L);return 0;
}


static int _wrap_Matrix_getcx(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_getcx",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_getcx",2,SWIGTYPE_p_Vector3);
  }
  
  ((Matrix const *)arg1)->getcx(*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_getcy(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_getcy",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_getcy",2,SWIGTYPE_p_Vector3);
  }
  
  ((Matrix const *)arg1)->getcy(*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_getcz(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_getcz",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_getcz",2,SWIGTYPE_p_Vector3);
  }
  
  ((Matrix const *)arg1)->getcz(*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_getcw(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_getcw",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_getcw",2,SWIGTYPE_p_Vector3);
  }
  
  ((Matrix const *)arg1)->getcw(*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_setcx(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_setcx",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_setcx",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->setcx((Vector3 const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_setcy(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_setcy",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_setcy",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->setcy((Vector3 const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_setcz(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_setcz",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_setcz",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->setcz((Vector3 const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_setcw(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_setcw",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Matrix_setcw",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->setcw((Vector3 const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_m_set(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  float *arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_m_set",1,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Matrix_m_set",2,SWIGTYPE_p_float);
  }
  
  {
    size_t ii;
    float *b = (float *) arg1->m;
    for (ii = 0; ii < (size_t)16; ii++) b[ii] = *((float *) arg2 + ii);
  }
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Matrix_m_get(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  float *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Matrix_m_get",1,SWIGTYPE_p_Matrix);
  }
  
  result = (float *)(float *) ((arg1)->m);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_Matrix(lua_State* L) {
  int SWIG_arg = -1;
  Matrix *arg1 = (Matrix *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("delete_Matrix",1,SWIGTYPE_p_Matrix);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Matrix(void *obj) {
Matrix *arg1 = (Matrix *) obj;
delete arg1;
}
static swig_lua_method swig_Matrix_methods[] = {
    {"vector_rotation", _wrap_Matrix_vector_rotation}, 
    {"translation", _wrap_Matrix_translation}, 
    {"addtranslation", _wrap_Matrix_addtranslation}, 
    {"addscale", _wrap_Matrix_addscale}, 
    {"scale", _wrap_Matrix_scale}, 
    {"camera", _wrap_Matrix_camera}, 
    {"transpose", _wrap_Matrix_transpose}, 
    {"apply", _wrap_Matrix_apply}, 
    {"camera_pos", _wrap_Matrix_camera_pos}, 
    {"__mul", _wrap_Matrix___mul}, 
    {"align", _wrap_Matrix_align}, 
    {"xrotate", _wrap_Matrix_xrotate}, 
    {"yrotate", _wrap_Matrix_yrotate}, 
    {"zrotate", _wrap_Matrix_zrotate}, 
    {"eulerZXY", _wrap_Matrix_eulerZXY}, 
    {"eulerYXZ", _wrap_Matrix_eulerYXZ}, 
    {"calcEulerZXY", _wrap_Matrix_calcEulerZXY}, 
    {"calcEulerYXZ", _wrap_Matrix_calcEulerYXZ}, 
    {"makequat", _wrap_Matrix_makequat}, 
    {"identity", _wrap_Matrix_identity}, 
    {"clear", _wrap_Matrix_clear}, 
    {"inverse", _wrap_Matrix_inverse}, 
    {"determinant", _wrap_Matrix_determinant}, 
    {"adjoint", _wrap_Matrix_adjoint}, 
    {"copy", _wrap_Matrix_copy}, 
    {"perspective_lh", _wrap_Matrix_perspective_lh}, 
    {"multiply", _wrap_Matrix_multiply}, 
    {"v", _wrap_Matrix_v}, 
    {"t", _wrap_Matrix_t}, 
    {"__call", _wrap_Matrix___call}, 
    {"getx", _wrap_Matrix_getx}, 
    {"gety", _wrap_Matrix_gety}, 
    {"getz", _wrap_Matrix_getz}, 
    {"getw", _wrap_Matrix_getw}, 
    {"getcx", _wrap_Matrix_getcx}, 
    {"getcy", _wrap_Matrix_getcy}, 
    {"getcz", _wrap_Matrix_getcz}, 
    {"getcw", _wrap_Matrix_getcw}, 
    {"setcx", _wrap_Matrix_setcx}, 
    {"setcy", _wrap_Matrix_setcy}, 
    {"setcz", _wrap_Matrix_setcz}, 
    {"setcw", _wrap_Matrix_setcw}, 
    {0,0}
};
static swig_lua_attribute swig_Matrix_attributes[] = {
    { "m",_wrap_Matrix_m_get, _wrap_Matrix_m_set},
    {0,0,0}
};
static swig_lua_class *swig_Matrix_bases[] = {0};
swig_lua_class _wrap_class_Matrix = { "Matrix", &SWIGTYPE_p_Matrix,_wrap_new_Matrix, swig_delete_Matrix, swig_Matrix_methods, swig_Matrix_attributes, swig_Matrix_bases };

static int _wrap_new_Quaternion__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *result = 0 ;
  
  result = (Quaternion *)new Quaternion();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Quaternion,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Quaternion__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  Quaternion *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!lua_isnumber(L,4)) SWIG_fail_arg(4);
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  result = (Quaternion *)new Quaternion(arg1,arg2,arg3,arg4);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Quaternion,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Quaternion(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_Quaternion__SWIG_0(L);
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            return _wrap_new_Quaternion__SWIG_1(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_Quaternion'");
  lua_error(L);return 0;
}


static int _wrap_Quaternion_identity(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_identity",1,SWIGTYPE_p_Quaternion);
  }
  
  (arg1)->identity();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_copy(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  Quaternion *arg2 = (Quaternion *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_copy",1,SWIGTYPE_p_Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_copy",2,SWIGTYPE_p_Quaternion);
  }
  
  ((Quaternion const *)arg1)->copy(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_normal(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_normal",1,SWIGTYPE_p_Quaternion);
  }
  
  result = (float)((Quaternion const *)arg1)->normal();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_conjugate__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_conjugate",1,SWIGTYPE_p_Quaternion);
  }
  
  (arg1)->conjugate();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_conjugate__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  Quaternion *arg2 = (Quaternion *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_conjugate",1,SWIGTYPE_p_Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_conjugate",2,SWIGTYPE_p_Quaternion);
  }
  
  ((Quaternion const *)arg1)->conjugate(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_conjugate(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_Quaternion_conjugate__SWIG_0(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Quaternion, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Quaternion_conjugate__SWIG_1(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Quaternion_conjugate'");
  lua_error(L);return 0;
}


static int _wrap_Quaternion_normalize(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_normalize",1,SWIGTYPE_p_Quaternion);
  }
  
  (arg1)->normalize();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion___mul(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  Quaternion *arg2 = 0 ;
  Quaternion result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion___mul",1,SWIGTYPE_p_Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion___mul",2,SWIGTYPE_p_Quaternion);
  }
  
  result = (arg1)->operator *((Quaternion const &)*arg2);
  SWIG_arg=0;
  {
    Quaternion * resultptr = new Quaternion((Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_mul(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  Quaternion *arg2 = (Quaternion *) 0 ;
  Quaternion *arg3 = (Quaternion *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_mul",1,SWIGTYPE_p_Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_mul",2,SWIGTYPE_p_Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_mul",3,SWIGTYPE_p_Quaternion);
  }
  
  ((Quaternion const *)arg1)->mul((Quaternion const *)arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_xrotate(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_xrotate",1,SWIGTYPE_p_Quaternion);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->xrotate(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_yrotate(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_yrotate",1,SWIGTYPE_p_Quaternion);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->yrotate(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_zrotate(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_zrotate",1,SWIGTYPE_p_Quaternion);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->zrotate(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_rotation(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!lua_isnumber(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_rotation",1,SWIGTYPE_p_Quaternion);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  (arg1)->rotation(arg2,arg3,arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_vector_rot(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  float arg3 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_vector_rot",1,SWIGTYPE_p_Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Quaternion_vector_rot",2,SWIGTYPE_p_Vector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->vector_rot(arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_slerp(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  Quaternion *arg2 = (Quaternion *) 0 ;
  float arg3 ;
  Quaternion *arg4 = (Quaternion *) 0 ;
  Quaternion::SlerpType arg5 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg(4);
  if(!lua_isnumber(L,5)) SWIG_fail_arg(5);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_slerp",1,SWIGTYPE_p_Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_slerp",2,SWIGTYPE_p_Quaternion);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_slerp",4,SWIGTYPE_p_Quaternion);
  }
  
  arg5 = (Quaternion::SlerpType)(int)lua_tonumber(L, 5);
  ((Quaternion const *)arg1)->slerp((Quaternion const *)arg2,arg3,arg4,arg5);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_apply__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  float *arg5 = (float *) 0 ;
  float *arg6 = (float *) 0 ;
  float *arg7 = (float *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!lua_isnumber(L,4)) SWIG_fail_arg(4);
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg(5);
  if(!SWIG_isptrtype(L,6)) SWIG_fail_arg(6);
  if(!SWIG_isptrtype(L,7)) SWIG_fail_arg(7);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_apply",1,SWIGTYPE_p_Quaternion);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Quaternion_apply",5,SWIGTYPE_p_float);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Quaternion_apply",6,SWIGTYPE_p_float);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,7,(void**)&arg7,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Quaternion_apply",7,SWIGTYPE_p_float);
  }
  
  ((Quaternion const *)arg1)->apply(arg2,arg3,arg4,arg5,arg6,arg7);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_apply__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  Vector3 *arg3 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_apply",1,SWIGTYPE_p_Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Quaternion_apply",2,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Quaternion_apply",3,SWIGTYPE_p_Vector3);
  }
  
  ((Quaternion const *)arg1)->apply(arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_apply(lua_State* L) {
  int argc;
  int argv[8]={
    1,2,3,4,5,6,7,8
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Quaternion_apply__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Quaternion, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            _v = lua_isnumber(L,argv[3]);
          }
          if (_v) {
            {
              void *ptr;
              if (SWIG_isptrtype(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_float, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                void *ptr;
                if (SWIG_isptrtype(L,argv[5])==0 || SWIG_ConvertPtr(L,argv[5], (void **) &ptr, SWIGTYPE_p_float, 0)) {
                  _v = 0;
                } else {
                  _v = 1;
                }
              }
              if (_v) {
                {
                  void *ptr;
                  if (SWIG_isptrtype(L,argv[6])==0 || SWIG_ConvertPtr(L,argv[6], (void **) &ptr, SWIGTYPE_p_float, 0)) {
                    _v = 0;
                  } else {
                    _v = 1;
                  }
                }
                if (_v) {
                  return _wrap_Quaternion_apply__SWIG_0(L);
                }
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Quaternion_apply'");
  lua_error(L);return 0;
}


static int _wrap_Quaternion_makematrix(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  Matrix *arg2 = (Matrix *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_makematrix",1,SWIGTYPE_p_Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Quaternion_makematrix",2,SWIGTYPE_p_Matrix);
  }
  
  ((Quaternion const *)arg1)->makematrix(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_inverse(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  Quaternion *arg2 = (Quaternion *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_inverse",1,SWIGTYPE_p_Quaternion);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_inverse",2,SWIGTYPE_p_Quaternion);
  }
  
  ((Quaternion const *)arg1)->inverse(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_x_set(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_x_set",1,SWIGTYPE_p_Quaternion);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_x_get(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_x_get",1,SWIGTYPE_p_Quaternion);
  }
  
  result = (float) ((arg1)->x);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_y_set(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_y_set",1,SWIGTYPE_p_Quaternion);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_y_get(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_y_get",1,SWIGTYPE_p_Quaternion);
  }
  
  result = (float) ((arg1)->y);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_z_set(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_z_set",1,SWIGTYPE_p_Quaternion);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->z = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_z_get(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_z_get",1,SWIGTYPE_p_Quaternion);
  }
  
  result = (float) ((arg1)->z);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_w_set(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_w_set",1,SWIGTYPE_p_Quaternion);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->w = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Quaternion_w_get(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Quaternion_w_get",1,SWIGTYPE_p_Quaternion);
  }
  
  result = (float) ((arg1)->w);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_Quaternion(lua_State* L) {
  int SWIG_arg = -1;
  Quaternion *arg1 = (Quaternion *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("delete_Quaternion",1,SWIGTYPE_p_Quaternion);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Quaternion(void *obj) {
Quaternion *arg1 = (Quaternion *) obj;
delete arg1;
}
static swig_lua_method swig_Quaternion_methods[] = {
    {"identity", _wrap_Quaternion_identity}, 
    {"copy", _wrap_Quaternion_copy}, 
    {"normal", _wrap_Quaternion_normal}, 
    {"conjugate", _wrap_Quaternion_conjugate}, 
    {"normalize", _wrap_Quaternion_normalize}, 
    {"__mul", _wrap_Quaternion___mul}, 
    {"mul", _wrap_Quaternion_mul}, 
    {"xrotate", _wrap_Quaternion_xrotate}, 
    {"yrotate", _wrap_Quaternion_yrotate}, 
    {"zrotate", _wrap_Quaternion_zrotate}, 
    {"rotation", _wrap_Quaternion_rotation}, 
    {"vector_rot", _wrap_Quaternion_vector_rot}, 
    {"slerp", _wrap_Quaternion_slerp}, 
    {"apply", _wrap_Quaternion_apply}, 
    {"makematrix", _wrap_Quaternion_makematrix}, 
    {"inverse", _wrap_Quaternion_inverse}, 
    {0,0}
};
static swig_lua_attribute swig_Quaternion_attributes[] = {
    { "x",_wrap_Quaternion_x_get, _wrap_Quaternion_x_set},
    { "y",_wrap_Quaternion_y_get, _wrap_Quaternion_y_set},
    { "z",_wrap_Quaternion_z_get, _wrap_Quaternion_z_set},
    { "w",_wrap_Quaternion_w_get, _wrap_Quaternion_w_set},
    {0,0,0}
};
static swig_lua_class *swig_Quaternion_bases[] = {0};
swig_lua_class _wrap_class_Quaternion = { "Quaternion", &SWIGTYPE_p_Quaternion,_wrap_new_Quaternion, swig_delete_Quaternion, swig_Quaternion_methods, swig_Quaternion_attributes, swig_Quaternion_bases };

static int _wrap_SamePoint(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  float arg3 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("SamePoint",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("SamePoint",2,SWIGTYPE_p_Vector3);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (bool)Math::SamePoint((Vector3 const *)arg1,(Vector3 const *)arg2,arg3);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NearestBoxVertex(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  Vector3 *arg3 = (Vector3 *) 0 ;
  Vector3 *arg4 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("NearestBoxVertex",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("NearestBoxVertex",2,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("NearestBoxVertex",3,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("NearestBoxVertex",4,SWIGTYPE_p_Vector3);
  }
  
  Math::NearestBoxVertex((Vector3 const *)arg1,(Vector3 const *)arg2,(Vector3 const *)arg3,arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ComputeOrientation__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  Vector3 *arg4 = (Vector3 *) 0 ;
  Vector3 *arg5 = (Vector3 *) 0 ;
  Vector3 *arg6 = (Vector3 *) 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg(4);
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg(5);
  if(!SWIG_isptrtype(L,6)) SWIG_fail_arg(6);
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("ComputeOrientation",4,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("ComputeOrientation",5,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("ComputeOrientation",6,SWIGTYPE_p_Vector3);
  }
  
  Math::ComputeOrientation(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ComputeOrientation__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  Vector3 *arg4 = (Vector3 *) 0 ;
  Vector3 *arg5 = (Vector3 *) 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg(4);
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg(5);
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("ComputeOrientation",4,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("ComputeOrientation",5,SWIGTYPE_p_Vector3);
  }
  
  Math::ComputeOrientation(arg1,arg2,arg3,arg4,arg5);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ComputeOrientation__SWIG_2(lua_State* L) {
  int SWIG_arg = -1;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  Vector3 *arg4 = (Vector3 *) 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg(4);
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("ComputeOrientation",4,SWIGTYPE_p_Vector3);
  }
  
  Math::ComputeOrientation(arg1,arg2,arg3,arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ComputeOrientation__SWIG_3(lua_State* L) {
  int SWIG_arg = -1;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  Math::ComputeOrientation(arg1,arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ComputeOrientation(lua_State* L) {
  int argc;
  int argv[7]={
    1,2,3,4,5,6,7
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_ComputeOrientation__SWIG_3(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (SWIG_isptrtype(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_ComputeOrientation__SWIG_2(L);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (SWIG_isptrtype(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (SWIG_isptrtype(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              return _wrap_ComputeOrientation__SWIG_1(L);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          {
            void *ptr;
            if (SWIG_isptrtype(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            {
              void *ptr;
              if (SWIG_isptrtype(L,argv[4])==0 || SWIG_ConvertPtr(L,argv[4], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
                _v = 0;
              } else {
                _v = 1;
              }
            }
            if (_v) {
              {
                void *ptr;
                if (SWIG_isptrtype(L,argv[5])==0 || SWIG_ConvertPtr(L,argv[5], (void **) &ptr, SWIGTYPE_p_Vector3, 0)) {
                  _v = 0;
                } else {
                  _v = 1;
                }
              }
              if (_v) {
                return _wrap_ComputeOrientation__SWIG_0(L);
              }
            }
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'ComputeOrientation'");
  lua_error(L);return 0;
}


static int _wrap_NearestBoxPoint(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = (Vector3 *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  Vector3 *arg3 = (Vector3 *) 0 ;
  Vector3 *arg4 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("NearestBoxPoint",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("NearestBoxPoint",2,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("NearestBoxPoint",3,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("NearestBoxPoint",4,SWIGTYPE_p_Vector3);
  }
  
  Math::NearestBoxPoint((Vector3 const *)arg1,(Vector3 const *)arg2,(Vector3 const *)arg3,arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GetTransform(lua_State* L) {
  int SWIG_arg = -1;
  Vector3 *arg1 = 0 ;
  Vector3 *arg2 = 0 ;
  Vector3 *arg3 = 0 ;
  Matrix result;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("GetTransform",1,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("GetTransform",2,SWIGTYPE_p_Vector3);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("GetTransform",3,SWIGTYPE_p_Vector3);
  }
  
  result = Math::GetTransform((Vector3 const &)*arg1,(Vector3 const &)*arg2,(Vector3 const &)*arg3);
  SWIG_arg=0;
  {
    Matrix * resultptr = new Matrix((Matrix &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Matrix,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Triangle(lua_State* L) {
  int SWIG_arg = -1;
  Triangle *result = 0 ;
  
  result = (Triangle *)new Triangle();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Triangle,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Triangle_vrt_set(lua_State* L) {
  int SWIG_arg = -1;
  Triangle *arg1 = (Triangle *) 0 ;
  int *arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Triangle,0))){
    SWIG_fail_ptr("Triangle_vrt_set",1,SWIGTYPE_p_Triangle);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("Triangle_vrt_set",2,SWIGTYPE_p_int);
  }
  
  {
    size_t ii;
    int *b = (int *) arg1->vrt;
    for (ii = 0; ii < (size_t)3; ii++) b[ii] = *((int *) arg2 + ii);
  }
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Triangle_vrt_get(lua_State* L) {
  int SWIG_arg = -1;
  Triangle *arg1 = (Triangle *) 0 ;
  int *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Triangle,0))){
    SWIG_fail_ptr("Triangle_vrt_get",1,SWIGTYPE_p_Triangle);
  }
  
  result = (int *)(int *) ((arg1)->vrt);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_int,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_Triangle(lua_State* L) {
  int SWIG_arg = -1;
  Triangle *arg1 = (Triangle *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Triangle,0))){
    SWIG_fail_ptr("delete_Triangle",1,SWIGTYPE_p_Triangle);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Triangle(void *obj) {
Triangle *arg1 = (Triangle *) obj;
delete arg1;
}
static swig_lua_method swig_Triangle_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_Triangle_attributes[] = {
    { "vrt",_wrap_Triangle_vrt_get, _wrap_Triangle_vrt_set},
    {0,0,0}
};
static swig_lua_class *swig_Triangle_bases[] = {0};
swig_lua_class _wrap_class_Triangle = { "Triangle", &SWIGTYPE_p_Triangle,_wrap_new_Triangle, swig_delete_Triangle, swig_Triangle_methods, swig_Triangle_attributes, swig_Triangle_bases };

static int _wrap_Vertex_pos_set(lua_State* L) {
  int SWIG_arg = -1;
  Vertex *arg1 = (Vertex *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vertex,0))){
    SWIG_fail_ptr("Vertex_pos_set",1,SWIGTYPE_p_Vertex);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vertex_pos_set",2,SWIGTYPE_p_Vector3);
  }
  
  if (arg1) (arg1)->pos = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vertex_pos_get(lua_State* L) {
  int SWIG_arg = -1;
  Vertex *arg1 = (Vertex *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vertex,0))){
    SWIG_fail_ptr("Vertex_pos_get",1,SWIGTYPE_p_Vertex);
  }
  
  result = (Vector3 *)& ((arg1)->pos);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vertex_normal_set(lua_State* L) {
  int SWIG_arg = -1;
  Vertex *arg1 = (Vertex *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vertex,0))){
    SWIG_fail_ptr("Vertex_normal_set",1,SWIGTYPE_p_Vertex);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Vertex_normal_set",2,SWIGTYPE_p_Vector3);
  }
  
  if (arg1) (arg1)->normal = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vertex_normal_get(lua_State* L) {
  int SWIG_arg = -1;
  Vertex *arg1 = (Vertex *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vertex,0))){
    SWIG_fail_ptr("Vertex_normal_get",1,SWIGTYPE_p_Vertex);
  }
  
  result = (Vector3 *)& ((arg1)->normal);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vertex_tc_set(lua_State* L) {
  int SWIG_arg = -1;
  Vertex *arg1 = (Vertex *) 0 ;
  Vector2 *arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vertex,0))){
    SWIG_fail_ptr("Vertex_tc_set",1,SWIGTYPE_p_Vertex);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector2,0))){
    SWIG_fail_ptr("Vertex_tc_set",2,SWIGTYPE_p_Vector2);
  }
  
  {
    size_t ii;
    Vector2 *b = (Vector2 *) arg1->tc;
    for (ii = 0; ii < (size_t)1; ii++) b[ii] = *((Vector2 *) arg2 + ii);
  }
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Vertex_tc_get(lua_State* L) {
  int SWIG_arg = -1;
  Vertex *arg1 = (Vertex *) 0 ;
  Vector2 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vertex,0))){
    SWIG_fail_ptr("Vertex_tc_get",1,SWIGTYPE_p_Vertex);
  }
  
  result = (Vector2 *)(Vector2 *) ((arg1)->tc);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector2,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_Vertex(lua_State* L) {
  int SWIG_arg = -1;
  Vertex *arg1 = (Vertex *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vertex,0))){
    SWIG_fail_ptr("delete_Vertex",1,SWIGTYPE_p_Vertex);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Vertex(void *obj) {
Vertex *arg1 = (Vertex *) obj;
delete arg1;
}
static swig_lua_method swig_Vertex_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_Vertex_attributes[] = {
    { "pos",_wrap_Vertex_pos_get, _wrap_Vertex_pos_set},
    { "normal",_wrap_Vertex_normal_get, _wrap_Vertex_normal_set},
    { "tc",_wrap_Vertex_tc_get, _wrap_Vertex_tc_set},
    {0,0,0}
};
static swig_lua_class *swig_Vertex_bases[] = {0};
swig_lua_class _wrap_class_Vertex = { "Vertex", &SWIGTYPE_p_Vertex,0, swig_delete_Vertex, swig_Vertex_methods, swig_Vertex_attributes, swig_Vertex_bases };

static int _wrap_new_Poly(lua_State* L) {
  int SWIG_arg = -1;
  Poly *result = 0 ;
  
  result = (Poly *)new Poly();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Poly,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_Poly(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("delete_Poly",1,SWIGTYPE_p_Poly);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_CalcPlane(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  std::vector<Vertex > *arg2 = 0 ;
  Plane result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_CalcPlane",1,SWIGTYPE_p_Poly);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorTVertex_t,0))){
    SWIG_fail_ptr("Poly_CalcPlane",2,SWIGTYPE_p_std__vectorTVertex_t);
  }
  
  result = (arg1)->CalcPlane((std::vector<Vertex > const &)*arg2);
  SWIG_arg=0;
  {
    Plane * resultptr = new Plane((Plane &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Plane,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_Flip(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_Flip",1,SWIGTYPE_p_Poly);
  }
  
  (arg1)->Flip();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_Clone(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  Poly *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_Clone",1,SWIGTYPE_p_Poly);
  }
  
  result = (Poly *)(arg1)->Clone();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Poly,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_RotateVerts(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_RotateVerts",1,SWIGTYPE_p_Poly);
  }
  
  (arg1)->RotateVerts();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_verts_set(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  std::vector<int > *arg2 = (std::vector<int > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_verts_set",1,SWIGTYPE_p_Poly);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorTint_t,0))){
    SWIG_fail_ptr("Poly_verts_set",2,SWIGTYPE_p_std__vectorTint_t);
  }
  
  if (arg1) (arg1)->verts = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_verts_get(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  std::vector<int > *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_verts_get",1,SWIGTYPE_p_Poly);
  }
  
  result = (std::vector<int > *)& ((arg1)->verts);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTint_t,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_texname_set(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_texname_set",1,SWIGTYPE_p_Poly);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  if (arg1) (arg1)->texname = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_texname_get(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  std::string *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_texname_get",1,SWIGTYPE_p_Poly);
  }
  
  {
    std::string const &_result_ref =  ((arg1)->texname);
    result = (std::string *) &_result_ref;
  }
  SWIG_arg=0;
  lua_pushlstring(L,result->data(),result->size()); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_color_set(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_color_set",1,SWIGTYPE_p_Poly);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Poly_color_set",2,SWIGTYPE_p_Vector3);
  }
  
  if (arg1) (arg1)->color = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_color_get(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_color_get",1,SWIGTYPE_p_Poly);
  }
  
  result = (Vector3 *)& ((arg1)->color);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_taColor_set(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  int arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_taColor_set",1,SWIGTYPE_p_Poly);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->taColor = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_taColor_get(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_taColor_get",1,SWIGTYPE_p_Poly);
  }
  
  result = (int) ((arg1)->taColor);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_texture_set(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  RefPtr<Texture > *arg2 = (RefPtr<Texture > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_texture_set",1,SWIGTYPE_p_Poly);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_RefPtrTTexture_t,0))){
    SWIG_fail_ptr("Poly_texture_set",2,SWIGTYPE_p_RefPtrTTexture_t);
  }
  
  if (arg1) (arg1)->texture = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_texture_get(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  RefPtr<Texture > *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_texture_get",1,SWIGTYPE_p_Poly);
  }
  
  result = (RefPtr<Texture > *)& ((arg1)->texture);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_RefPtrTTexture_t,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_isCurved_set(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  bool arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isboolean(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_isCurved_set",1,SWIGTYPE_p_Poly);
  }
  
  arg2 = (bool)lua_toboolean(L, 2);
  if (arg1) (arg1)->isCurved = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_isCurved_get(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_isCurved_get",1,SWIGTYPE_p_Poly);
  }
  
  result = (bool) ((arg1)->isCurved);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_isSelected_set(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  bool arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isboolean(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_isSelected_set",1,SWIGTYPE_p_Poly);
  }
  
  arg2 = (bool)lua_toboolean(L, 2);
  if (arg1) (arg1)->isSelected = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Poly_isSelected_get(lua_State* L) {
  int SWIG_arg = -1;
  Poly *arg1 = (Poly *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("Poly_isSelected_get",1,SWIGTYPE_p_Poly);
  }
  
  result = (bool) ((arg1)->isSelected);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Poly(void *obj) {
Poly *arg1 = (Poly *) obj;
delete arg1;
}
static swig_lua_method swig_Poly_methods[] = {
    {"CalcPlane", _wrap_Poly_CalcPlane}, 
    {"Flip", _wrap_Poly_Flip}, 
    {"Clone", _wrap_Poly_Clone}, 
    {"RotateVerts", _wrap_Poly_RotateVerts}, 
    {0,0}
};
static swig_lua_attribute swig_Poly_attributes[] = {
    { "verts",_wrap_Poly_verts_get, _wrap_Poly_verts_set},
    { "texname",_wrap_Poly_texname_get, _wrap_Poly_texname_set},
    { "color",_wrap_Poly_color_get, _wrap_Poly_color_set},
    { "taColor",_wrap_Poly_taColor_get, _wrap_Poly_taColor_set},
    { "texture",_wrap_Poly_texture_get, _wrap_Poly_texture_set},
    { "isCurved",_wrap_Poly_isCurved_get, _wrap_Poly_isCurved_set},
    { "isSelected",_wrap_Poly_isSelected_get, _wrap_Poly_isSelected_set},
    {0,0,0}
};
static swig_lua_class *swig_Poly_bases[] = {0};
swig_lua_class _wrap_class_Poly = { "Poly", &SWIGTYPE_p_Poly,_wrap_new_Poly, swig_delete_Poly, swig_Poly_methods, swig_Poly_attributes, swig_Poly_bases };

static int _wrap_delete_BaseJoint(lua_State* L) {
  int SWIG_arg = -1;
  BaseJoint *arg1 = (BaseJoint *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_BaseJoint,0))){
    SWIG_fail_ptr("delete_BaseJoint",1,SWIGTYPE_p_BaseJoint);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_BaseJoint(void *obj) {
BaseJoint *arg1 = (BaseJoint *) obj;
delete arg1;
}
static swig_lua_method swig_BaseJoint_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_BaseJoint_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_BaseJoint_bases[] = {0};
swig_lua_class _wrap_class_BaseJoint = { "BaseJoint", &SWIGTYPE_p_BaseJoint,0, swig_delete_BaseJoint, swig_BaseJoint_methods, swig_BaseJoint_attributes, swig_BaseJoint_bases };

static int _wrap_HingeJoint_axis_set(lua_State* L) {
  int SWIG_arg = -1;
  HingeJoint *arg1 = (HingeJoint *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_HingeJoint,0))){
    SWIG_fail_ptr("HingeJoint_axis_set",1,SWIGTYPE_p_HingeJoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("HingeJoint_axis_set",2,SWIGTYPE_p_Vector3);
  }
  
  if (arg1) (arg1)->axis = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HingeJoint_axis_get(lua_State* L) {
  int SWIG_arg = -1;
  HingeJoint *arg1 = (HingeJoint *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_HingeJoint,0))){
    SWIG_fail_ptr("HingeJoint_axis_get",1,SWIGTYPE_p_HingeJoint);
  }
  
  result = (Vector3 *)& ((arg1)->axis);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_HingeJoint(lua_State* L) {
  int SWIG_arg = -1;
  HingeJoint *arg1 = (HingeJoint *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_HingeJoint,0))){
    SWIG_fail_ptr("delete_HingeJoint",1,SWIGTYPE_p_HingeJoint);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_HingeJoint(void *obj) {
HingeJoint *arg1 = (HingeJoint *) obj;
delete arg1;
}
static swig_lua_method swig_HingeJoint_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_HingeJoint_attributes[] = {
    { "axis",_wrap_HingeJoint_axis_get, _wrap_HingeJoint_axis_set},
    {0,0,0}
};
static swig_lua_class *swig_HingeJoint_bases[] = {&_wrap_class_BaseJoint,0};
swig_lua_class _wrap_class_HingeJoint = { "HingeJoint", &SWIGTYPE_p_HingeJoint,0, swig_delete_HingeJoint, swig_HingeJoint_methods, swig_HingeJoint_attributes, swig_HingeJoint_bases };

static int _wrap_UniversalJoint_axis_set(lua_State* L) {
  int SWIG_arg = -1;
  UniversalJoint *arg1 = (UniversalJoint *) 0 ;
  Vector3 *arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_UniversalJoint,0))){
    SWIG_fail_ptr("UniversalJoint_axis_set",1,SWIGTYPE_p_UniversalJoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("UniversalJoint_axis_set",2,SWIGTYPE_p_Vector3);
  }
  
  {
    size_t ii;
    Vector3 *b = (Vector3 *) arg1->axis;
    for (ii = 0; ii < (size_t)2; ii++) b[ii] = *((Vector3 *) arg2 + ii);
  }
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UniversalJoint_axis_get(lua_State* L) {
  int SWIG_arg = -1;
  UniversalJoint *arg1 = (UniversalJoint *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_UniversalJoint,0))){
    SWIG_fail_ptr("UniversalJoint_axis_get",1,SWIGTYPE_p_UniversalJoint);
  }
  
  result = (Vector3 *)(Vector3 *) ((arg1)->axis);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_UniversalJoint(lua_State* L) {
  int SWIG_arg = -1;
  UniversalJoint *arg1 = (UniversalJoint *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_UniversalJoint,0))){
    SWIG_fail_ptr("delete_UniversalJoint",1,SWIGTYPE_p_UniversalJoint);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_UniversalJoint(void *obj) {
UniversalJoint *arg1 = (UniversalJoint *) obj;
delete arg1;
}
static swig_lua_method swig_UniversalJoint_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_UniversalJoint_attributes[] = {
    { "axis",_wrap_UniversalJoint_axis_get, _wrap_UniversalJoint_axis_set},
    {0,0,0}
};
static swig_lua_class *swig_UniversalJoint_bases[] = {&_wrap_class_BaseJoint,0};
swig_lua_class _wrap_class_UniversalJoint = { "UniversalJoint", &SWIGTYPE_p_UniversalJoint,0, swig_delete_UniversalJoint, swig_UniversalJoint_methods, swig_UniversalJoint_attributes, swig_UniversalJoint_bases };

static int _wrap_new_IKinfo(lua_State* L) {
  int SWIG_arg = -1;
  IKinfo *result = 0 ;
  
  result = (IKinfo *)new IKinfo();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_IKinfo,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_IKinfo(lua_State* L) {
  int SWIG_arg = -1;
  IKinfo *arg1 = (IKinfo *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IKinfo,0))){
    SWIG_fail_ptr("delete_IKinfo",1,SWIGTYPE_p_IKinfo);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IKinfo_jointType_set(lua_State* L) {
  int SWIG_arg = -1;
  IKinfo *arg1 = (IKinfo *) 0 ;
  IKJointType arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IKinfo,0))){
    SWIG_fail_ptr("IKinfo_jointType_set",1,SWIGTYPE_p_IKinfo);
  }
  
  arg2 = (IKJointType)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->jointType = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IKinfo_jointType_get(lua_State* L) {
  int SWIG_arg = -1;
  IKinfo *arg1 = (IKinfo *) 0 ;
  IKJointType result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IKinfo,0))){
    SWIG_fail_ptr("IKinfo_jointType_get",1,SWIGTYPE_p_IKinfo);
  }
  
  result = (IKJointType) ((arg1)->jointType);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IKinfo_joint_set(lua_State* L) {
  int SWIG_arg = -1;
  IKinfo *arg1 = (IKinfo *) 0 ;
  BaseJoint *arg2 = (BaseJoint *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IKinfo,0))){
    SWIG_fail_ptr("IKinfo_joint_set",1,SWIGTYPE_p_IKinfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_BaseJoint,0))){
    SWIG_fail_ptr("IKinfo_joint_set",2,SWIGTYPE_p_BaseJoint);
  }
  
  if (arg1) (arg1)->joint = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IKinfo_joint_get(lua_State* L) {
  int SWIG_arg = -1;
  IKinfo *arg1 = (IKinfo *) 0 ;
  BaseJoint *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IKinfo,0))){
    SWIG_fail_ptr("IKinfo_joint_get",1,SWIGTYPE_p_IKinfo);
  }
  
  result = (BaseJoint *) ((arg1)->joint);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_BaseJoint,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_IKinfo(void *obj) {
IKinfo *arg1 = (IKinfo *) obj;
delete arg1;
}
static swig_lua_method swig_IKinfo_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_IKinfo_attributes[] = {
    { "jointType",_wrap_IKinfo_jointType_get, _wrap_IKinfo_jointType_set},
    { "joint",_wrap_IKinfo_joint_get, _wrap_IKinfo_joint_set},
    {0,0,0}
};
static swig_lua_class *swig_IKinfo_bases[] = {0};
swig_lua_class _wrap_class_IKinfo = { "IKinfo", &SWIGTYPE_p_IKinfo,_wrap_new_IKinfo, swig_delete_IKinfo, swig_IKinfo_methods, swig_IKinfo_attributes, swig_IKinfo_bases };

static int _wrap_delete_IRenderData(lua_State* L) {
  int SWIG_arg = -1;
  IRenderData *arg1 = (IRenderData *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IRenderData,0))){
    SWIG_fail_ptr("delete_IRenderData",1,SWIGTYPE_p_IRenderData);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IRenderData_Invalidate(lua_State* L) {
  int SWIG_arg = -1;
  IRenderData *arg1 = (IRenderData *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IRenderData,0))){
    SWIG_fail_ptr("IRenderData_Invalidate",1,SWIGTYPE_p_IRenderData);
  }
  
  (arg1)->Invalidate();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_IRenderData(void *obj) {
IRenderData *arg1 = (IRenderData *) obj;
delete arg1;
}
static swig_lua_method swig_IRenderData_methods[] = {
    {"Invalidate", _wrap_IRenderData_Invalidate}, 
    {0,0}
};
static swig_lua_attribute swig_IRenderData_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_IRenderData_bases[] = {0};
swig_lua_class _wrap_class_IRenderData = { "IRenderData", &SWIGTYPE_p_IRenderData,0, swig_delete_IRenderData, swig_IRenderData_methods, swig_IRenderData_attributes, swig_IRenderData_bases };

static int _wrap_new_Rotator(lua_State* L) {
  int SWIG_arg = -1;
  Rotator *result = 0 ;
  
  result = (Rotator *)new Rotator();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Rotator,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rotator_AddEulerAbsolute(lua_State* L) {
  int SWIG_arg = -1;
  Rotator *arg1 = (Rotator *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Rotator,0))){
    SWIG_fail_ptr("Rotator_AddEulerAbsolute",1,SWIGTYPE_p_Rotator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Rotator_AddEulerAbsolute",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->AddEulerAbsolute((Vector3 const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rotator_AddEulerRelative(lua_State* L) {
  int SWIG_arg = -1;
  Rotator *arg1 = (Rotator *) 0 ;
  Vector3 *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Rotator,0))){
    SWIG_fail_ptr("Rotator_AddEulerRelative",1,SWIGTYPE_p_Rotator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Rotator_AddEulerRelative",2,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->AddEulerRelative((Vector3 const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rotator_GetEuler(lua_State* L) {
  int SWIG_arg = -1;
  Rotator *arg1 = (Rotator *) 0 ;
  Vector3 result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Rotator,0))){
    SWIG_fail_ptr("Rotator_GetEuler",1,SWIGTYPE_p_Rotator);
  }
  
  result = (arg1)->GetEuler();
  SWIG_arg=0;
  {
    Vector3 * resultptr = new Vector3((Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rotator_SetEuler(lua_State* L) {
  int SWIG_arg = -1;
  Rotator *arg1 = (Rotator *) 0 ;
  Vector3 arg2 ;
  Vector3 *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Rotator,0))){
    SWIG_fail_ptr("Rotator_SetEuler",1,SWIGTYPE_p_Rotator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Rotator_SetEuler",2,SWIGTYPE_Vector3);
  }
  arg2 = *argp2;
  
  (arg1)->SetEuler(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rotator_ToMatrix(lua_State* L) {
  int SWIG_arg = -1;
  Rotator *arg1 = (Rotator *) 0 ;
  Matrix *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Rotator,0))){
    SWIG_fail_ptr("Rotator_ToMatrix",1,SWIGTYPE_p_Rotator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Rotator_ToMatrix",2,SWIGTYPE_p_Matrix);
  }
  
  (arg1)->ToMatrix(*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rotator_FromMatrix(lua_State* L) {
  int SWIG_arg = -1;
  Rotator *arg1 = (Rotator *) 0 ;
  Matrix *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Rotator,0))){
    SWIG_fail_ptr("Rotator_FromMatrix",1,SWIGTYPE_p_Rotator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Rotator_FromMatrix",2,SWIGTYPE_p_Matrix);
  }
  
  (arg1)->FromMatrix((Matrix const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rotator_GetQuat(lua_State* L) {
  int SWIG_arg = -1;
  Rotator *arg1 = (Rotator *) 0 ;
  Quaternion result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Rotator,0))){
    SWIG_fail_ptr("Rotator_GetQuat",1,SWIGTYPE_p_Rotator);
  }
  
  result = (arg1)->GetQuat();
  SWIG_arg=0;
  {
    Quaternion * resultptr = new Quaternion((Quaternion &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Quaternion,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rotator_SetQuat(lua_State* L) {
  int SWIG_arg = -1;
  Rotator *arg1 = (Rotator *) 0 ;
  Quaternion arg2 ;
  Quaternion *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Rotator,0))){
    SWIG_fail_ptr("Rotator_SetQuat",1,SWIGTYPE_p_Rotator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Quaternion,0))){
    SWIG_fail_ptr("Rotator_SetQuat",2,SWIGTYPE_Quaternion);
  }
  arg2 = *argp2;
  
  (arg1)->SetQuat(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rotator_euler_set(lua_State* L) {
  int SWIG_arg = -1;
  Rotator *arg1 = (Rotator *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Rotator,0))){
    SWIG_fail_ptr("Rotator_euler_set",1,SWIGTYPE_p_Rotator);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Rotator_euler_set",2,SWIGTYPE_p_Vector3);
  }
  
  if (arg1) (arg1)->euler = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rotator_euler_get(lua_State* L) {
  int SWIG_arg = -1;
  Rotator *arg1 = (Rotator *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Rotator,0))){
    SWIG_fail_ptr("Rotator_euler_get",1,SWIGTYPE_p_Rotator);
  }
  
  result = (Vector3 *)& ((arg1)->euler);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rotator_eulerInterp_set(lua_State* L) {
  int SWIG_arg = -1;
  Rotator *arg1 = (Rotator *) 0 ;
  bool arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isboolean(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Rotator,0))){
    SWIG_fail_ptr("Rotator_eulerInterp_set",1,SWIGTYPE_p_Rotator);
  }
  
  arg2 = (bool)lua_toboolean(L, 2);
  if (arg1) (arg1)->eulerInterp = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Rotator_eulerInterp_get(lua_State* L) {
  int SWIG_arg = -1;
  Rotator *arg1 = (Rotator *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Rotator,0))){
    SWIG_fail_ptr("Rotator_eulerInterp_get",1,SWIGTYPE_p_Rotator);
  }
  
  result = (bool) ((arg1)->eulerInterp);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_Rotator(lua_State* L) {
  int SWIG_arg = -1;
  Rotator *arg1 = (Rotator *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Rotator,0))){
    SWIG_fail_ptr("delete_Rotator",1,SWIGTYPE_p_Rotator);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Rotator(void *obj) {
Rotator *arg1 = (Rotator *) obj;
delete arg1;
}
static swig_lua_method swig_Rotator_methods[] = {
    {"AddEulerAbsolute", _wrap_Rotator_AddEulerAbsolute}, 
    {"AddEulerRelative", _wrap_Rotator_AddEulerRelative}, 
    {"GetEuler", _wrap_Rotator_GetEuler}, 
    {"SetEuler", _wrap_Rotator_SetEuler}, 
    {"ToMatrix", _wrap_Rotator_ToMatrix}, 
    {"FromMatrix", _wrap_Rotator_FromMatrix}, 
    {"GetQuat", _wrap_Rotator_GetQuat}, 
    {"SetQuat", _wrap_Rotator_SetQuat}, 
    {0,0}
};
static swig_lua_attribute swig_Rotator_attributes[] = {
    { "euler",_wrap_Rotator_euler_get, _wrap_Rotator_euler_set},
    { "eulerInterp",_wrap_Rotator_eulerInterp_get, _wrap_Rotator_eulerInterp_set},
    {0,0,0}
};
static swig_lua_class *swig_Rotator_bases[] = {0};
swig_lua_class _wrap_class_Rotator = { "Rotator", &SWIGTYPE_p_Rotator,_wrap_new_Rotator, swig_delete_Rotator, swig_Rotator_methods, swig_Rotator_attributes, swig_Rotator_bases };

static int _wrap_delete_Geometry(lua_State* L) {
  int SWIG_arg = -1;
  Geometry *arg1 = (Geometry *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Geometry,0))){
    SWIG_fail_ptr("delete_Geometry",1,SWIGTYPE_p_Geometry);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Geometry_Draw(lua_State* L) {
  int SWIG_arg = -1;
  Geometry *arg1 = (Geometry *) 0 ;
  ModelDrawer *arg2 = (ModelDrawer *) 0 ;
  Model *arg3 = (Model *) 0 ;
  MdlObject *arg4 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Geometry,0))){
    SWIG_fail_ptr("Geometry_Draw",1,SWIGTYPE_p_Geometry);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ModelDrawer,0))){
    SWIG_fail_ptr("Geometry_Draw",2,SWIGTYPE_p_ModelDrawer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Geometry_Draw",3,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("Geometry_Draw",4,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->Draw(arg2,arg3,arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Geometry_Clone(lua_State* L) {
  int SWIG_arg = -1;
  Geometry *arg1 = (Geometry *) 0 ;
  Geometry *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Geometry,0))){
    SWIG_fail_ptr("Geometry_Clone",1,SWIGTYPE_p_Geometry);
  }
  
  result = (Geometry *)(arg1)->Clone();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Geometry,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Geometry_Transform(lua_State* L) {
  int SWIG_arg = -1;
  Geometry *arg1 = (Geometry *) 0 ;
  Matrix *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Geometry,0))){
    SWIG_fail_ptr("Geometry_Transform",1,SWIGTYPE_p_Geometry);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Geometry_Transform",2,SWIGTYPE_p_Matrix);
  }
  
  (arg1)->Transform((Matrix const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Geometry_ToPolyMesh(lua_State* L) {
  int SWIG_arg = -1;
  Geometry *arg1 = (Geometry *) 0 ;
  PolyMesh *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Geometry,0))){
    SWIG_fail_ptr("Geometry_ToPolyMesh",1,SWIGTYPE_p_Geometry);
  }
  
  result = (PolyMesh *)(arg1)->ToPolyMesh();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PolyMesh,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Geometry_InvalidateRenderData(lua_State* L) {
  int SWIG_arg = -1;
  Geometry *arg1 = (Geometry *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Geometry,0))){
    SWIG_fail_ptr("Geometry_InvalidateRenderData",1,SWIGTYPE_p_Geometry);
  }
  
  (arg1)->InvalidateRenderData();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Geometry_CalculateRadius(lua_State* L) {
  int SWIG_arg = -1;
  Geometry *arg1 = (Geometry *) 0 ;
  float *arg2 = 0 ;
  Matrix *arg3 = 0 ;
  Vector3 *arg4 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  if(!lua_isuserdata(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Geometry,0))){
    SWIG_fail_ptr("Geometry_CalculateRadius",1,SWIGTYPE_p_Geometry);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("Geometry_CalculateRadius",2,SWIGTYPE_p_float);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("Geometry_CalculateRadius",3,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Geometry_CalculateRadius",4,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->CalculateRadius(*arg2,(Matrix const &)*arg3,(Vector3 const &)*arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Geometry(void *obj) {
Geometry *arg1 = (Geometry *) obj;
delete arg1;
}
static swig_lua_method swig_Geometry_methods[] = {
    {"Draw", _wrap_Geometry_Draw}, 
    {"Clone", _wrap_Geometry_Clone}, 
    {"Transform", _wrap_Geometry_Transform}, 
    {"ToPolyMesh", _wrap_Geometry_ToPolyMesh}, 
    {"InvalidateRenderData", _wrap_Geometry_InvalidateRenderData}, 
    {"CalculateRadius", _wrap_Geometry_CalculateRadius}, 
    {0,0}
};
static swig_lua_attribute swig_Geometry_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_Geometry_bases[] = {0};
swig_lua_class _wrap_class_Geometry = { "Geometry", &SWIGTYPE_p_Geometry,0, swig_delete_Geometry, swig_Geometry_methods, swig_Geometry_attributes, swig_Geometry_bases };

static int _wrap_delete_PolyMesh(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("delete_PolyMesh",1,SWIGTYPE_p_PolyMesh);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_verts_set(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  std::vector<Vertex > *arg2 = (std::vector<Vertex > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_verts_set",1,SWIGTYPE_p_PolyMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorTVertex_t,0))){
    SWIG_fail_ptr("PolyMesh_verts_set",2,SWIGTYPE_p_std__vectorTVertex_t);
  }
  
  if (arg1) (arg1)->verts = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_verts_get(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  std::vector<Vertex > *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_verts_get",1,SWIGTYPE_p_PolyMesh);
  }
  
  result = (std::vector<Vertex > *)& ((arg1)->verts);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTVertex_t,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_poly_set(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  std::vector<Poly * > *arg2 = (std::vector<Poly * > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_poly_set",1,SWIGTYPE_p_PolyMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorTPoly_p_t,0))){
    SWIG_fail_ptr("PolyMesh_poly_set",2,SWIGTYPE_p_std__vectorTPoly_p_t);
  }
  
  if (arg1) (arg1)->poly = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_poly_get(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  std::vector<Poly * > *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_poly_get",1,SWIGTYPE_p_PolyMesh);
  }
  
  result = (std::vector<Poly * > *)& ((arg1)->poly);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTPoly_p_t,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_Draw(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  ModelDrawer *arg2 = (ModelDrawer *) 0 ;
  Model *arg3 = (Model *) 0 ;
  MdlObject *arg4 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_Draw",1,SWIGTYPE_p_PolyMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ModelDrawer,0))){
    SWIG_fail_ptr("PolyMesh_Draw",2,SWIGTYPE_p_ModelDrawer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("PolyMesh_Draw",3,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("PolyMesh_Draw",4,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->Draw(arg2,arg3,arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_Clone(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  Geometry *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_Clone",1,SWIGTYPE_p_PolyMesh);
  }
  
  result = (Geometry *)(arg1)->Clone();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Geometry,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_Transform(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  Matrix *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_Transform",1,SWIGTYPE_p_PolyMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("PolyMesh_Transform",2,SWIGTYPE_p_Matrix);
  }
  
  (arg1)->Transform((Matrix const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_ToPolyMesh(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  PolyMesh *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_ToPolyMesh",1,SWIGTYPE_p_PolyMesh);
  }
  
  result = (PolyMesh *)(arg1)->ToPolyMesh();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PolyMesh,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_MakeTris(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  std::vector<Triangle > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_MakeTris",1,SWIGTYPE_p_PolyMesh);
  }
  
  result = (arg1)->MakeTris();
  SWIG_arg=0;
  {
    std::vector<Triangle > * resultptr = new std::vector<Triangle >((std::vector<Triangle > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorTTriangle_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_IsEqualVertexTC(lua_State* L) {
  int SWIG_arg = -1;
  Vertex *arg1 = 0 ;
  Vertex *arg2 = 0 ;
  bool result;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vertex,0))){
    SWIG_fail_ptr("PolyMesh_IsEqualVertexTC",1,SWIGTYPE_p_Vertex);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vertex,0))){
    SWIG_fail_ptr("PolyMesh_IsEqualVertexTC",2,SWIGTYPE_p_Vertex);
  }
  
  result = (bool)PolyMesh::IsEqualVertexTC(*arg1,*arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_IsEqualVertexTCNormal(lua_State* L) {
  int SWIG_arg = -1;
  Vertex *arg1 = 0 ;
  Vertex *arg2 = 0 ;
  bool result;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Vertex,0))){
    SWIG_fail_ptr("PolyMesh_IsEqualVertexTCNormal",1,SWIGTYPE_p_Vertex);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vertex,0))){
    SWIG_fail_ptr("PolyMesh_IsEqualVertexTCNormal",2,SWIGTYPE_p_Vertex);
  }
  
  result = (bool)PolyMesh::IsEqualVertexTCNormal(*arg1,*arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_OptimizeVertices(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  PolyMesh::IsEqualVertexCB arg2 = (PolyMesh::IsEqualVertexCB) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_OptimizeVertices",1,SWIGTYPE_p_PolyMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_f_r_Vertex_r_Vertex__bool,0))){
    SWIG_fail_ptr("PolyMesh_OptimizeVertices",2,SWIGTYPE_p_f_r_Vertex_r_Vertex__bool);
  }
  
  (arg1)->OptimizeVertices(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_Optimize(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  PolyMesh::IsEqualVertexCB arg2 = (PolyMesh::IsEqualVertexCB) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_Optimize",1,SWIGTYPE_p_PolyMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_f_r_Vertex_r_Vertex__bool,0))){
    SWIG_fail_ptr("PolyMesh_Optimize",2,SWIGTYPE_p_f_r_Vertex_r_Vertex__bool);
  }
  
  (arg1)->Optimize(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_MoveGeometry(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  PolyMesh *arg2 = (PolyMesh *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_MoveGeometry",1,SWIGTYPE_p_PolyMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_MoveGeometry",2,SWIGTYPE_p_PolyMesh);
  }
  
  (arg1)->MoveGeometry(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_FlipPolygons(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_FlipPolygons",1,SWIGTYPE_p_PolyMesh);
  }
  
  (arg1)->FlipPolygons();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_CalculateRadius(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  float *arg2 = 0 ;
  Matrix *arg3 = 0 ;
  Vector3 *arg4 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  if(!lua_isuserdata(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_CalculateRadius",1,SWIGTYPE_p_PolyMesh);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("PolyMesh_CalculateRadius",2,SWIGTYPE_p_float);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("PolyMesh_CalculateRadius",3,SWIGTYPE_p_Matrix);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("PolyMesh_CalculateRadius",4,SWIGTYPE_p_Vector3);
  }
  
  (arg1)->CalculateRadius(*arg2,(Matrix const &)*arg3,(Vector3 const &)*arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_CalculateNormals(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_CalculateNormals",1,SWIGTYPE_p_PolyMesh);
  }
  
  (arg1)->CalculateNormals();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyMesh_CalculateNormals2(lua_State* L) {
  int SWIG_arg = -1;
  PolyMesh *arg1 = (PolyMesh *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PolyMesh,0))){
    SWIG_fail_ptr("PolyMesh_CalculateNormals2",1,SWIGTYPE_p_PolyMesh);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->CalculateNormals2(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_PolyMesh(void *obj) {
PolyMesh *arg1 = (PolyMesh *) obj;
delete arg1;
}
static swig_lua_method swig_PolyMesh_methods[] = {
    {"Draw", _wrap_PolyMesh_Draw}, 
    {"Clone", _wrap_PolyMesh_Clone}, 
    {"Transform", _wrap_PolyMesh_Transform}, 
    {"ToPolyMesh", _wrap_PolyMesh_ToPolyMesh}, 
    {"MakeTris", _wrap_PolyMesh_MakeTris}, 
    {"OptimizeVertices", _wrap_PolyMesh_OptimizeVertices}, 
    {"Optimize", _wrap_PolyMesh_Optimize}, 
    {"MoveGeometry", _wrap_PolyMesh_MoveGeometry}, 
    {"FlipPolygons", _wrap_PolyMesh_FlipPolygons}, 
    {"CalculateRadius", _wrap_PolyMesh_CalculateRadius}, 
    {"CalculateNormals", _wrap_PolyMesh_CalculateNormals}, 
    {"CalculateNormals2", _wrap_PolyMesh_CalculateNormals2}, 
    {0,0}
};
static swig_lua_attribute swig_PolyMesh_attributes[] = {
    { "verts",_wrap_PolyMesh_verts_get, _wrap_PolyMesh_verts_set},
    { "poly",_wrap_PolyMesh_poly_get, _wrap_PolyMesh_poly_set},
    {0,0,0}
};
static swig_lua_class *swig_PolyMesh_bases[] = {&_wrap_class_Geometry,0};
swig_lua_class _wrap_class_PolyMesh = { "PolyMesh", &SWIGTYPE_p_PolyMesh,0, swig_delete_PolyMesh, swig_PolyMesh_methods, swig_PolyMesh_attributes, swig_PolyMesh_bases };

static int _wrap_new_MdlObject(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *result = 0 ;
  
  result = (MdlObject *)new MdlObject();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MdlObject,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_MdlObject(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("delete_MdlObject",1,SWIGTYPE_p_MdlObject);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_IsEmpty(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_IsEmpty",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (bool)(arg1)->IsEmpty();
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_Dump__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  int arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_Dump",1,SWIGTYPE_p_MdlObject);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  (arg1)->Dump(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_Dump__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_Dump",1,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->Dump();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_Dump(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_MdlObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_MdlObject_Dump__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_MdlObject, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_MdlObject_Dump__SWIG_0(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'MdlObject_Dump'");
  lua_error(L);return 0;
}


static int _wrap_MdlObject_MergeChild(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  MdlObject *arg2 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_MergeChild",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_MergeChild",2,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->MergeChild(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_FullMerge(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_FullMerge",1,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->FullMerge();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_GetTransform(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  Matrix *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_GetTransform",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("MdlObject_GetTransform",2,SWIGTYPE_p_Matrix);
  }
  
  (arg1)->GetTransform(*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_GetFullTransform(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  Matrix *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_GetFullTransform",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("MdlObject_GetFullTransform",2,SWIGTYPE_p_Matrix);
  }
  
  (arg1)->GetFullTransform(*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_GetChildObjects(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  std::vector<MdlObject * > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_GetChildObjects",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (arg1)->GetChildObjects();
  SWIG_arg=0;
  {
    std::vector<MdlObject * > * resultptr = new std::vector<MdlObject * >((std::vector<MdlObject * > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorTMdlObject_p_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_UnlinkFromParent(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_UnlinkFromParent",1,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->UnlinkFromParent();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_LinkToParent(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  MdlObject *arg2 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_LinkToParent",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_LinkToParent",2,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->LinkToParent(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_FlipPolygons(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_FlipPolygons",1,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->FlipPolygons();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_Load3DOTextures(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  TextureHandler *arg2 = (TextureHandler *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_Load3DOTextures",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_TextureHandler,0))){
    SWIG_fail_ptr("MdlObject_Load3DOTextures",2,SWIGTYPE_p_TextureHandler);
  }
  
  (arg1)->Load3DOTextures(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_HasSelectedParent(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_HasSelectedParent",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (bool)(arg1)->HasSelectedParent();
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_ApplyTransform(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  bool arg2 ;
  bool arg3 ;
  bool arg4 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isboolean(L,2)) SWIG_fail_arg(2);
  if(!lua_isboolean(L,3)) SWIG_fail_arg(3);
  if(!lua_isboolean(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_ApplyTransform",1,SWIGTYPE_p_MdlObject);
  }
  
  arg2 = (bool)lua_toboolean(L, 2);
  arg3 = (bool)lua_toboolean(L, 3);
  arg4 = (bool)lua_toboolean(L, 4);
  (arg1)->ApplyTransform(arg2,arg3,arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_ApplyParentSpaceTransform(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  Matrix *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_ApplyParentSpaceTransform",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("MdlObject_ApplyParentSpaceTransform",2,SWIGTYPE_p_Matrix);
  }
  
  (arg1)->ApplyParentSpaceTransform((Matrix const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_TransformVertices(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  Matrix *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_TransformVertices",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("MdlObject_TransformVertices",2,SWIGTYPE_p_Matrix);
  }
  
  (arg1)->TransformVertices((Matrix const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_ApproximateOffset(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_ApproximateOffset",1,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->ApproximateOffset();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_SetPropertiesFromMatrix(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  Matrix *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_SetPropertiesFromMatrix",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("MdlObject_SetPropertiesFromMatrix",2,SWIGTYPE_p_Matrix);
  }
  
  (arg1)->SetPropertiesFromMatrix(*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_Transform(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  Matrix *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_Transform",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Matrix,0))){
    SWIG_fail_ptr("MdlObject_Transform",2,SWIGTYPE_p_Matrix);
  }
  
  (arg1)->Transform((Matrix const &)*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_InvalidateRenderData(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_InvalidateRenderData",1,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->InvalidateRenderData();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_NormalizeNormals(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_NormalizeNormals",1,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->NormalizeNormals();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_MoveOrigin(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  Vector3 arg2 ;
  Vector3 *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_MoveOrigin",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("MdlObject_MoveOrigin",2,SWIGTYPE_Vector3);
  }
  arg2 = *argp2;
  
  (arg1)->MoveOrigin(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_AddChild(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  MdlObject *arg2 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_AddChild",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_AddChild",2,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->AddChild(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_RemoveChild(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  MdlObject *arg2 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_RemoveChild",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_RemoveChild",2,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->RemoveChild(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_GetPolyMesh(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  PolyMesh *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_GetPolyMesh",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (PolyMesh *)(arg1)->GetPolyMesh();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PolyMesh,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_ToPolyMesh(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  PolyMesh *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_ToPolyMesh",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (PolyMesh *)(arg1)->ToPolyMesh();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PolyMesh,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_GetOrCreatePolyMesh(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  PolyMesh *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_GetOrCreatePolyMesh",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (PolyMesh *)(arg1)->GetOrCreatePolyMesh();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PolyMesh,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_InitAnimationInfo(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_InitAnimationInfo",1,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->InitAnimationInfo();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_UpdateAnimation(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_UpdateAnimation",1,SWIGTYPE_p_MdlObject);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->UpdateAnimation(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_Clone(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  MdlObject *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_Clone",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (MdlObject *)(arg1)->Clone();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MdlObject,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_position_set(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_position_set",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("MdlObject_position_set",2,SWIGTYPE_p_Vector3);
  }
  
  if (arg1) (arg1)->position = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_position_get(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_position_get",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (Vector3 *)& ((arg1)->position);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_rotation_set(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  Rotator *arg2 = (Rotator *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_rotation_set",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Rotator,0))){
    SWIG_fail_ptr("MdlObject_rotation_set",2,SWIGTYPE_p_Rotator);
  }
  
  if (arg1) (arg1)->rotation = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_rotation_get(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  Rotator *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_rotation_get",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (Rotator *)& ((arg1)->rotation);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Rotator,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_scale_set(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_scale_set",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("MdlObject_scale_set",2,SWIGTYPE_p_Vector3);
  }
  
  if (arg1) (arg1)->scale = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_scale_get(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_scale_get",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (Vector3 *)& ((arg1)->scale);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_geometry_set(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  Geometry *arg2 = (Geometry *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_geometry_set",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Geometry,0))){
    SWIG_fail_ptr("MdlObject_geometry_set",2,SWIGTYPE_p_Geometry);
  }
  
  if (arg1) (arg1)->geometry = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_geometry_get(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  Geometry *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_geometry_get",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (Geometry *) ((arg1)->geometry);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Geometry,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_animInfo_set(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  AnimationInfo *arg2 = (AnimationInfo *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_animInfo_set",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("MdlObject_animInfo_set",2,SWIGTYPE_p_AnimationInfo);
  }
  
  if (arg1) (arg1)->animInfo = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_animInfo_get(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  AnimationInfo *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_animInfo_get",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (AnimationInfo *)& ((arg1)->animInfo);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_AnimationInfo,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_name_set(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_name_set",1,SWIGTYPE_p_MdlObject);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  if (arg1) (arg1)->name = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_name_get(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  std::string *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_name_get",1,SWIGTYPE_p_MdlObject);
  }
  
  {
    std::string const &_result_ref =  ((arg1)->name);
    result = (std::string *) &_result_ref;
  }
  SWIG_arg=0;
  lua_pushlstring(L,result->data(),result->size()); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_isSelected_set(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  bool arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isboolean(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_isSelected_set",1,SWIGTYPE_p_MdlObject);
  }
  
  arg2 = (bool)lua_toboolean(L, 2);
  if (arg1) (arg1)->isSelected = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_isSelected_get(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_isSelected_get",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (bool) ((arg1)->isSelected);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_isOpen_set(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  bool arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isboolean(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_isOpen_set",1,SWIGTYPE_p_MdlObject);
  }
  
  arg2 = (bool)lua_toboolean(L, 2);
  if (arg1) (arg1)->isOpen = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_isOpen_get(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_isOpen_get",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (bool) ((arg1)->isOpen);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_ikInfo_set(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  IKinfo *arg2 = (IKinfo *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_ikInfo_set",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_IKinfo,0))){
    SWIG_fail_ptr("MdlObject_ikInfo_set",2,SWIGTYPE_p_IKinfo);
  }
  
  if (arg1) (arg1)->ikInfo = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_ikInfo_get(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  IKinfo *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_ikInfo_get",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (IKinfo *)& ((arg1)->ikInfo);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_IKinfo,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_parent_set(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  MdlObject *arg2 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_parent_set",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_parent_set",2,SWIGTYPE_p_MdlObject);
  }
  
  if (arg1) (arg1)->parent = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_parent_get(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  MdlObject *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_parent_get",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (MdlObject *) ((arg1)->parent);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MdlObject,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_childs_set(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  std::vector<MdlObject * > *arg2 = (std::vector<MdlObject * > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_childs_set",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorTMdlObject_p_t,0))){
    SWIG_fail_ptr("MdlObject_childs_set",2,SWIGTYPE_p_std__vectorTMdlObject_p_t);
  }
  
  if (arg1) (arg1)->childs = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_childs_get(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  std::vector<MdlObject * > *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_childs_get",1,SWIGTYPE_p_MdlObject);
  }
  
  result = (std::vector<MdlObject * > *)& ((arg1)->childs);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTMdlObject_p_t,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MdlObject_NewPolyMesh(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("MdlObject_NewPolyMesh",1,SWIGTYPE_p_MdlObject);
  }
  
  MdlObject_NewPolyMesh(arg1);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_MdlObject(void *obj) {
MdlObject *arg1 = (MdlObject *) obj;
delete arg1;
}
static swig_lua_method swig_MdlObject_methods[] = {
    {"IsEmpty", _wrap_MdlObject_IsEmpty}, 
    {"Dump", _wrap_MdlObject_Dump}, 
    {"MergeChild", _wrap_MdlObject_MergeChild}, 
    {"FullMerge", _wrap_MdlObject_FullMerge}, 
    {"GetTransform", _wrap_MdlObject_GetTransform}, 
    {"GetFullTransform", _wrap_MdlObject_GetFullTransform}, 
    {"GetChildObjects", _wrap_MdlObject_GetChildObjects}, 
    {"UnlinkFromParent", _wrap_MdlObject_UnlinkFromParent}, 
    {"LinkToParent", _wrap_MdlObject_LinkToParent}, 
    {"FlipPolygons", _wrap_MdlObject_FlipPolygons}, 
    {"Load3DOTextures", _wrap_MdlObject_Load3DOTextures}, 
    {"HasSelectedParent", _wrap_MdlObject_HasSelectedParent}, 
    {"ApplyTransform", _wrap_MdlObject_ApplyTransform}, 
    {"ApplyParentSpaceTransform", _wrap_MdlObject_ApplyParentSpaceTransform}, 
    {"TransformVertices", _wrap_MdlObject_TransformVertices}, 
    {"ApproximateOffset", _wrap_MdlObject_ApproximateOffset}, 
    {"SetPropertiesFromMatrix", _wrap_MdlObject_SetPropertiesFromMatrix}, 
    {"Transform", _wrap_MdlObject_Transform}, 
    {"InvalidateRenderData", _wrap_MdlObject_InvalidateRenderData}, 
    {"NormalizeNormals", _wrap_MdlObject_NormalizeNormals}, 
    {"MoveOrigin", _wrap_MdlObject_MoveOrigin}, 
    {"AddChild", _wrap_MdlObject_AddChild}, 
    {"RemoveChild", _wrap_MdlObject_RemoveChild}, 
    {"GetPolyMesh", _wrap_MdlObject_GetPolyMesh}, 
    {"ToPolyMesh", _wrap_MdlObject_ToPolyMesh}, 
    {"GetOrCreatePolyMesh", _wrap_MdlObject_GetOrCreatePolyMesh}, 
    {"InitAnimationInfo", _wrap_MdlObject_InitAnimationInfo}, 
    {"UpdateAnimation", _wrap_MdlObject_UpdateAnimation}, 
    {"Clone", _wrap_MdlObject_Clone}, 
    {"NewPolyMesh", _wrap_MdlObject_NewPolyMesh}, 
    {0,0}
};
static swig_lua_attribute swig_MdlObject_attributes[] = {
    { "position",_wrap_MdlObject_position_get, _wrap_MdlObject_position_set},
    { "rotation",_wrap_MdlObject_rotation_get, _wrap_MdlObject_rotation_set},
    { "scale",_wrap_MdlObject_scale_get, _wrap_MdlObject_scale_set},
    { "geometry",_wrap_MdlObject_geometry_get, _wrap_MdlObject_geometry_set},
    { "animInfo",_wrap_MdlObject_animInfo_get, _wrap_MdlObject_animInfo_set},
    { "name",_wrap_MdlObject_name_get, _wrap_MdlObject_name_set},
    { "isSelected",_wrap_MdlObject_isSelected_get, _wrap_MdlObject_isSelected_set},
    { "isOpen",_wrap_MdlObject_isOpen_get, _wrap_MdlObject_isOpen_set},
    { "ikInfo",_wrap_MdlObject_ikInfo_get, _wrap_MdlObject_ikInfo_set},
    { "parent",_wrap_MdlObject_parent_get, _wrap_MdlObject_parent_set},
    { "childs",_wrap_MdlObject_childs_get, _wrap_MdlObject_childs_set},
    {0,0,0}
};
static swig_lua_class *swig_MdlObject_bases[] = {0};
swig_lua_class _wrap_class_MdlObject = { "MdlObject", &SWIGTYPE_p_MdlObject,_wrap_new_MdlObject, swig_delete_MdlObject, swig_MdlObject_methods, swig_MdlObject_attributes, swig_MdlObject_bases };

static int _wrap_IterateObjects(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *arg1 = (MdlObject *) 0 ;
  void (*arg2)(MdlObject *) = (void (*)(MdlObject *)) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("IterateObjects",1,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_f_p_MdlObject__void,0))){
    SWIG_fail_ptr("IterateObjects",2,SWIGTYPE_p_f_p_MdlObject__void);
  }
  
  IterateObjects(arg1,arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_IProgressCtl(lua_State* L) {
  int SWIG_arg = -1;
  IProgressCtl *result = 0 ;
  
  result = (IProgressCtl *)new IProgressCtl();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_IProgressCtl,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IProgressCtl_Update(lua_State* L) {
  int SWIG_arg = -1;
  IProgressCtl *arg1 = (IProgressCtl *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("IProgressCtl_Update",1,SWIGTYPE_p_IProgressCtl);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->Update(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IProgressCtl_cb_set(lua_State* L) {
  int SWIG_arg = -1;
  IProgressCtl *arg1 = (IProgressCtl *) 0 ;
  void (*arg2)(float,void *) = (void (*)(float,void *)) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("IProgressCtl_cb_set",1,SWIGTYPE_p_IProgressCtl);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_f_float_p_void__void,0))){
    SWIG_fail_ptr("IProgressCtl_cb_set",2,SWIGTYPE_p_f_float_p_void__void);
  }
  
  if (arg1) (arg1)->cb = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IProgressCtl_cb_get(lua_State* L) {
  int SWIG_arg = -1;
  IProgressCtl *arg1 = (IProgressCtl *) 0 ;
  void (*result)(float,void *) = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("IProgressCtl_cb_get",1,SWIGTYPE_p_IProgressCtl);
  }
  
  result = (void (*)(float,void *)) ((arg1)->cb);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_f_float_p_void__void,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IProgressCtl_data_set(lua_State* L) {
  int SWIG_arg = -1;
  IProgressCtl *arg1 = (IProgressCtl *) 0 ;
  void *arg2 = (void *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("IProgressCtl_data_set",1,SWIGTYPE_p_IProgressCtl);
  }
  
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"IProgressCtl_data_set");
  if (arg1) (arg1)->data = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IProgressCtl_data_get(lua_State* L) {
  int SWIG_arg = -1;
  IProgressCtl *arg1 = (IProgressCtl *) 0 ;
  void *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("IProgressCtl_data_get",1,SWIGTYPE_p_IProgressCtl);
  }
  
  result = (void *) ((arg1)->data);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_IProgressCtl(lua_State* L) {
  int SWIG_arg = -1;
  IProgressCtl *arg1 = (IProgressCtl *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("delete_IProgressCtl",1,SWIGTYPE_p_IProgressCtl);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_IProgressCtl(void *obj) {
IProgressCtl *arg1 = (IProgressCtl *) obj;
delete arg1;
}
static swig_lua_method swig_IProgressCtl_methods[] = {
    {"Update", _wrap_IProgressCtl_Update}, 
    {0,0}
};
static swig_lua_attribute swig_IProgressCtl_attributes[] = {
    { "cb",_wrap_IProgressCtl_cb_get, _wrap_IProgressCtl_cb_set},
    { "data",_wrap_IProgressCtl_data_get, _wrap_IProgressCtl_data_set},
    {0,0,0}
};
static swig_lua_class *swig_IProgressCtl_bases[] = {0};
swig_lua_class _wrap_class_IProgressCtl = { "IProgressCtl", &SWIGTYPE_p_IProgressCtl,_wrap_new_IProgressCtl, swig_delete_IProgressCtl, swig_IProgressCtl_methods, swig_IProgressCtl_attributes, swig_IProgressCtl_bases };

static int _wrap_TextureBinding_name_set(lua_State* L) {
  int SWIG_arg = -1;
  TextureBinding *arg1 = (TextureBinding *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_TextureBinding,0))){
    SWIG_fail_ptr("TextureBinding_name_set",1,SWIGTYPE_p_TextureBinding);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  if (arg1) (arg1)->name = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBinding_name_get(lua_State* L) {
  int SWIG_arg = -1;
  TextureBinding *arg1 = (TextureBinding *) 0 ;
  std::string *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_TextureBinding,0))){
    SWIG_fail_ptr("TextureBinding_name_get",1,SWIGTYPE_p_TextureBinding);
  }
  
  {
    std::string const &_result_ref =  ((arg1)->name);
    result = (std::string *) &_result_ref;
  }
  SWIG_arg=0;
  lua_pushlstring(L,result->data(),result->size()); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBinding_SetTexture(lua_State* L) {
  int SWIG_arg = -1;
  TextureBinding *arg1 = (TextureBinding *) 0 ;
  Texture *arg2 = (Texture *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_TextureBinding,0))){
    SWIG_fail_ptr("TextureBinding_SetTexture",1,SWIGTYPE_p_TextureBinding);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Texture,0))){
    SWIG_fail_ptr("TextureBinding_SetTexture",2,SWIGTYPE_p_Texture);
  }
  
  (arg1)->SetTexture(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TextureBinding_GetTexture(lua_State* L) {
  int SWIG_arg = -1;
  TextureBinding *arg1 = (TextureBinding *) 0 ;
  Texture *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_TextureBinding,0))){
    SWIG_fail_ptr("TextureBinding_GetTexture",1,SWIGTYPE_p_TextureBinding);
  }
  
  result = (Texture *)(arg1)->GetTexture();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Texture,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_TextureBinding(lua_State* L) {
  int SWIG_arg = -1;
  TextureBinding *arg1 = (TextureBinding *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_TextureBinding,0))){
    SWIG_fail_ptr("delete_TextureBinding",1,SWIGTYPE_p_TextureBinding);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_TextureBinding(void *obj) {
TextureBinding *arg1 = (TextureBinding *) obj;
delete arg1;
}
static swig_lua_method swig_TextureBinding_methods[] = {
    {"SetTexture", _wrap_TextureBinding_SetTexture}, 
    {"GetTexture", _wrap_TextureBinding_GetTexture}, 
    {0,0}
};
static swig_lua_attribute swig_TextureBinding_attributes[] = {
    { "name",_wrap_TextureBinding_name_get, _wrap_TextureBinding_name_set},
    {0,0,0}
};
static swig_lua_class *swig_TextureBinding_bases[] = {0};
swig_lua_class _wrap_class_TextureBinding = { "TextureBinding", &SWIGTYPE_p_TextureBinding,0, swig_delete_TextureBinding, swig_TextureBinding_methods, swig_TextureBinding_attributes, swig_TextureBinding_bases };

static int _wrap_new_Model(lua_State* L) {
  int SWIG_arg = -1;
  Model *result = 0 ;
  
  result = (Model *)new Model();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Model,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_Model(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("delete_Model",1,SWIGTYPE_p_Model);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_PostLoad(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_PostLoad",1,SWIGTYPE_p_Model);
  }
  
  (arg1)->PostLoad();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_Load3DO__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  char *arg2 = (char *) 0 ;
  IProgressCtl *arg3 = 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_Load3DO",1,SWIGTYPE_p_Model);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("Model_Load3DO",3,SWIGTYPE_p_IProgressCtl);
  }
  
  result = (bool)(arg1)->Load3DO((char const *)arg2,*arg3);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_Load3DO__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_Load3DO",1,SWIGTYPE_p_Model);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)(arg1)->Load3DO((char const *)arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_Load3DO(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Model, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_Model_Load3DO__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Model, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_IProgressCtl, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Model_Load3DO__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Model_Load3DO'");
  lua_error(L);return 0;
}


static int _wrap_Model_Save3DO__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  char *arg2 = (char *) 0 ;
  IProgressCtl *arg3 = 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_Save3DO",1,SWIGTYPE_p_Model);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("Model_Save3DO",3,SWIGTYPE_p_IProgressCtl);
  }
  
  result = (bool)(arg1)->Save3DO((char const *)arg2,*arg3);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_Save3DO__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_Save3DO",1,SWIGTYPE_p_Model);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)(arg1)->Save3DO((char const *)arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_Save3DO(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Model, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_Model_Save3DO__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Model, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_IProgressCtl, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Model_Save3DO__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Model_Save3DO'");
  lua_error(L);return 0;
}


static int _wrap_Model_LoadS3O__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  char *arg2 = (char *) 0 ;
  IProgressCtl *arg3 = 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_LoadS3O",1,SWIGTYPE_p_Model);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("Model_LoadS3O",3,SWIGTYPE_p_IProgressCtl);
  }
  
  result = (bool)(arg1)->LoadS3O((char const *)arg2,*arg3);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_LoadS3O__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_LoadS3O",1,SWIGTYPE_p_Model);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)(arg1)->LoadS3O((char const *)arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_LoadS3O(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Model, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_Model_LoadS3O__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Model, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_IProgressCtl, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Model_LoadS3O__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Model_LoadS3O'");
  lua_error(L);return 0;
}


static int _wrap_Model_SaveS3O__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  char *arg2 = (char *) 0 ;
  IProgressCtl *arg3 = 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_SaveS3O",1,SWIGTYPE_p_Model);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("Model_SaveS3O",3,SWIGTYPE_p_IProgressCtl);
  }
  
  result = (bool)(arg1)->SaveS3O((char const *)arg2,*arg3);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_SaveS3O__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_SaveS3O",1,SWIGTYPE_p_Model);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)(arg1)->SaveS3O((char const *)arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_SaveS3O(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Model, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_Model_SaveS3O__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Model, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_IProgressCtl, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Model_SaveS3O__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Model_SaveS3O'");
  lua_error(L);return 0;
}


static int _wrap_Model_Load__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  std::string *arg1 = 0 ;
  bool arg2 ;
  IProgressCtl *arg3 = 0 ;
  Model *result = 0 ;
  std::string temp1 ;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  if(!lua_isboolean(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  temp1.assign(lua_tostring(L,1),lua_strlen(L,1)); arg1=&temp1;
  arg2 = (bool)lua_toboolean(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("Model_Load",3,SWIGTYPE_p_IProgressCtl);
  }
  
  result = (Model *)Model::Load((std::string const &)*arg1,arg2,*arg3);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Model,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_Load__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  std::string *arg1 = 0 ;
  bool arg2 ;
  Model *result = 0 ;
  std::string temp1 ;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  if(!lua_isboolean(L,2)) SWIG_fail_arg(2);
  temp1.assign(lua_tostring(L,1),lua_strlen(L,1)); arg1=&temp1;
  arg2 = (bool)lua_toboolean(L, 2);
  result = (Model *)Model::Load((std::string const &)*arg1,arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Model,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_Load__SWIG_2(lua_State* L) {
  int SWIG_arg = -1;
  std::string *arg1 = 0 ;
  Model *result = 0 ;
  std::string temp1 ;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  temp1.assign(lua_tostring(L,1),lua_strlen(L,1)); arg1=&temp1;
  result = (Model *)Model::Load((std::string const &)*arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Model,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_Load(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 1) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      return _wrap_Model_Load__SWIG_2(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        return _wrap_Model_Load__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      _v = lua_isstring(L,argv[0]);
    }
    if (_v) {
      {
        _v = lua_isboolean(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_IProgressCtl, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Model_Load__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Model_Load'");
  lua_error(L);return 0;
}


static int _wrap_Model_Save__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  IProgressCtl *arg3 = 0 ;
  bool result;
  std::string temp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_Save",1,SWIGTYPE_p_Model);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("Model_Save",3,SWIGTYPE_p_IProgressCtl);
  }
  
  result = (bool)Model::Save(arg1,(std::string const &)*arg2,*arg3);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_Save__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  std::string temp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_Save",1,SWIGTYPE_p_Model);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  result = (bool)Model::Save(arg1,(std::string const &)*arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_Save(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Model, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_Model_Save__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Model, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_IProgressCtl, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Model_Save__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Model_Save'");
  lua_error(L);return 0;
}


static int _wrap_Model_ExportUVMesh(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_ExportUVMesh",1,SWIGTYPE_p_Model);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)(arg1)->ExportUVMesh((char const *)arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_ImportUVMesh__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  char *arg2 = (char *) 0 ;
  IProgressCtl *arg3 = 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_ImportUVMesh",1,SWIGTYPE_p_Model);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("Model_ImportUVMesh",3,SWIGTYPE_p_IProgressCtl);
  }
  
  result = (bool)(arg1)->ImportUVMesh((char const *)arg2,*arg3);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_ImportUVMesh__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  char *arg2 = (char *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_ImportUVMesh",1,SWIGTYPE_p_Model);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (bool)(arg1)->ImportUVMesh((char const *)arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_ImportUVMesh(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Model, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        return _wrap_Model_ImportUVMesh__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Model, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_IProgressCtl, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Model_ImportUVMesh__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Model_ImportUVMesh'");
  lua_error(L);return 0;
}


static int _wrap_Model_ImportUVCoords__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  Model *arg2 = (Model *) 0 ;
  IProgressCtl *arg3 = 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_ImportUVCoords",1,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_ImportUVCoords",2,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("Model_ImportUVCoords",3,SWIGTYPE_p_IProgressCtl);
  }
  
  result = (bool)(arg1)->ImportUVCoords(arg2,*arg3);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_ImportUVCoords__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  Model *arg2 = (Model *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_ImportUVCoords",1,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_ImportUVCoords",2,SWIGTYPE_p_Model);
  }
  
  result = (bool)(arg1)->ImportUVCoords(arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_ImportUVCoords(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Model, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Model, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_Model_ImportUVCoords__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_Model, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Model, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        {
          void *ptr;
          if (lua_isuserdata(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_IProgressCtl, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_Model_ImportUVCoords__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'Model_ImportUVCoords'");
  lua_error(L);return 0;
}


static int _wrap_Model_InsertModel(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  MdlObject *arg2 = (MdlObject *) 0 ;
  Model *arg3 = (Model *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_InsertModel",1,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("Model_InsertModel",2,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_InsertModel",3,SWIGTYPE_p_Model);
  }
  
  (arg1)->InsertModel(arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_GetSelectedObjects(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  std::vector<MdlObject * > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_GetSelectedObjects",1,SWIGTYPE_p_Model);
  }
  
  result = (arg1)->GetSelectedObjects();
  SWIG_arg=0;
  {
    std::vector<MdlObject * > * resultptr = new std::vector<MdlObject * >((std::vector<MdlObject * > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorTMdlObject_p_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_GetObjectList(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  std::vector<MdlObject * > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_GetObjectList",1,SWIGTYPE_p_Model);
  }
  
  result = (arg1)->GetObjectList();
  SWIG_arg=0;
  {
    std::vector<MdlObject * > * resultptr = new std::vector<MdlObject * >((std::vector<MdlObject * > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorTMdlObject_p_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_GetPolyMeshList(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  SwigValueWrapper<std::vector<PolyMesh * > > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_GetPolyMeshList",1,SWIGTYPE_p_Model);
  }
  
  result = (arg1)->GetPolyMeshList();
  SWIG_arg=0;
  {
    std::vector<PolyMesh * > * resultptr = new std::vector<PolyMesh * >((std::vector<PolyMesh * > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorTPolyMesh_p_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_DeleteObject(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  MdlObject *arg2 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_DeleteObject",1,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("Model_DeleteObject",2,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->DeleteObject(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_ReplaceObject(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  MdlObject *arg2 = (MdlObject *) 0 ;
  MdlObject *arg3 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_ReplaceObject",1,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("Model_ReplaceObject",2,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("Model_ReplaceObject",3,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->ReplaceObject(arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_EstimateMidPosition(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_EstimateMidPosition",1,SWIGTYPE_p_Model);
  }
  
  (arg1)->EstimateMidPosition();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_CalculateRadius(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_CalculateRadius",1,SWIGTYPE_p_Model);
  }
  
  (arg1)->CalculateRadius();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_SwapObjects(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  MdlObject *arg2 = (MdlObject *) 0 ;
  MdlObject *arg3 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_SwapObjects",1,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("Model_SwapObjects",2,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("Model_SwapObjects",3,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->SwapObjects(arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_Clone(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  Model *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_Clone",1,SWIGTYPE_p_Model);
  }
  
  result = (Model *)(arg1)->Clone();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Model,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_ObjectSelectionHash(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  ulong result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_ObjectSelectionHash",1,SWIGTYPE_p_Model);
  }
  
  result = (arg1)->ObjectSelectionHash();
  SWIG_arg=0;
  {
    ulong * resultptr = new ulong((ulong &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_ulong,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_SetTextureName(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  uint arg2 ;
  char *arg3 = (char *) 0 ;
  uint *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  if(!lua_isstring(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_SetTextureName",1,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_uint,0))){
    SWIG_fail_ptr("Model_SetTextureName",2,SWIGTYPE_uint);
  }
  arg2 = *argp2;
  
  arg3 = (char *)lua_tostring(L, 3);
  (arg1)->SetTextureName(arg2,(char const *)arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_SetTexture(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  uint arg2 ;
  Texture *arg3 = (Texture *) 0 ;
  uint *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_SetTexture",1,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_uint,0))){
    SWIG_fail_ptr("Model_SetTexture",2,SWIGTYPE_uint);
  }
  arg2 = *argp2;
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Texture,0))){
    SWIG_fail_ptr("Model_SetTexture",3,SWIGTYPE_p_Texture);
  }
  
  (arg1)->SetTexture(arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_ConvertToS3O(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  std::string arg2 ;
  int arg3 ;
  int arg4 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  if(!lua_isnumber(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_ConvertToS3O",1,SWIGTYPE_p_Model);
  }
  
  (&arg2)->assign(lua_tostring(L,2),lua_strlen(L,2));
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (bool)(arg1)->ConvertToS3O(arg2,arg3,arg4);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_radius_set(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_radius_set",1,SWIGTYPE_p_Model);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->radius = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_radius_get(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_radius_get",1,SWIGTYPE_p_Model);
  }
  
  result = (float) ((arg1)->radius);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_height_set(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_height_set",1,SWIGTYPE_p_Model);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->height = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_height_get(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_height_get",1,SWIGTYPE_p_Model);
  }
  
  result = (float) ((arg1)->height);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_mid_set(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  Vector3 *arg2 = (Vector3 *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_mid_set",1,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("Model_mid_set",2,SWIGTYPE_p_Vector3);
  }
  
  if (arg1) (arg1)->mid = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_mid_get(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  Vector3 *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_mid_get",1,SWIGTYPE_p_Model);
  }
  
  result = (Vector3 *)& ((arg1)->mid);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Vector3,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_HasTex(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  uint arg2 ;
  bool result;
  uint *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_HasTex",1,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_uint,0))){
    SWIG_fail_ptr("Model_HasTex",2,SWIGTYPE_uint);
  }
  arg2 = *argp2;
  
  result = (bool)(arg1)->HasTex(arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_TextureID(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  uint arg2 ;
  uint result;
  uint *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_TextureID",1,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_uint,0))){
    SWIG_fail_ptr("Model_TextureID",2,SWIGTYPE_uint);
  }
  arg2 = *argp2;
  
  result = (arg1)->TextureID(arg2);
  SWIG_arg=0;
  {
    uint * resultptr = new uint((uint &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_uint,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_TextureName(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  uint arg2 ;
  std::string *result = 0 ;
  uint *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_TextureName",1,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_uint,0))){
    SWIG_fail_ptr("Model_TextureName",2,SWIGTYPE_uint);
  }
  arg2 = *argp2;
  
  {
    std::string &_result_ref = (arg1)->TextureName(arg2);
    result = (std::string *) &_result_ref;
  }
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__string,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_texBindings_set(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  std::vector<TextureBinding > *arg2 = (std::vector<TextureBinding > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_texBindings_set",1,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorTTextureBinding_t,0))){
    SWIG_fail_ptr("Model_texBindings_set",2,SWIGTYPE_p_std__vectorTTextureBinding_t);
  }
  
  if (arg1) (arg1)->texBindings = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_texBindings_get(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  std::vector<TextureBinding > *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_texBindings_get",1,SWIGTYPE_p_Model);
  }
  
  result = (std::vector<TextureBinding > *)& ((arg1)->texBindings);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTTextureBinding_t,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_mapping_set(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  int arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_mapping_set",1,SWIGTYPE_p_Model);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->mapping = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_mapping_get(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_mapping_get",1,SWIGTYPE_p_Model);
  }
  
  result = (int) ((arg1)->mapping);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_root_set(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  MdlObject *arg2 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_root_set",1,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("Model_root_set",2,SWIGTYPE_p_MdlObject);
  }
  
  if (arg1) (arg1)->root = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_root_get(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  MdlObject *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_root_get",1,SWIGTYPE_p_Model);
  }
  
  result = (MdlObject *) ((arg1)->root);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MdlObject,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Model_SetRoot(lua_State* L) {
  int SWIG_arg = -1;
  Model *arg1 = (Model *) 0 ;
  MdlObject *arg2 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("Model_SetRoot",1,SWIGTYPE_p_Model);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("Model_SetRoot",2,SWIGTYPE_p_MdlObject);
  }
  
  Model_SetRoot(arg1,arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Model(void *obj) {
Model *arg1 = (Model *) obj;
delete arg1;
}
static swig_lua_method swig_Model_methods[] = {
    {"PostLoad", _wrap_Model_PostLoad}, 
    {"Load3DO", _wrap_Model_Load3DO}, 
    {"Save3DO", _wrap_Model_Save3DO}, 
    {"LoadS3O", _wrap_Model_LoadS3O}, 
    {"SaveS3O", _wrap_Model_SaveS3O}, 
    {"ExportUVMesh", _wrap_Model_ExportUVMesh}, 
    {"ImportUVMesh", _wrap_Model_ImportUVMesh}, 
    {"ImportUVCoords", _wrap_Model_ImportUVCoords}, 
    {"InsertModel", _wrap_Model_InsertModel}, 
    {"GetSelectedObjects", _wrap_Model_GetSelectedObjects}, 
    {"GetObjectList", _wrap_Model_GetObjectList}, 
    {"GetPolyMeshList", _wrap_Model_GetPolyMeshList}, 
    {"DeleteObject", _wrap_Model_DeleteObject}, 
    {"ReplaceObject", _wrap_Model_ReplaceObject}, 
    {"EstimateMidPosition", _wrap_Model_EstimateMidPosition}, 
    {"CalculateRadius", _wrap_Model_CalculateRadius}, 
    {"SwapObjects", _wrap_Model_SwapObjects}, 
    {"Clone", _wrap_Model_Clone}, 
    {"ObjectSelectionHash", _wrap_Model_ObjectSelectionHash}, 
    {"SetTextureName", _wrap_Model_SetTextureName}, 
    {"SetTexture", _wrap_Model_SetTexture}, 
    {"ConvertToS3O", _wrap_Model_ConvertToS3O}, 
    {"HasTex", _wrap_Model_HasTex}, 
    {"TextureID", _wrap_Model_TextureID}, 
    {"TextureName", _wrap_Model_TextureName}, 
    {"SetRoot", _wrap_Model_SetRoot}, 
    {0,0}
};
static swig_lua_attribute swig_Model_attributes[] = {
    { "radius",_wrap_Model_radius_get, _wrap_Model_radius_set},
    { "height",_wrap_Model_height_get, _wrap_Model_height_set},
    { "mid",_wrap_Model_mid_get, _wrap_Model_mid_set},
    { "texBindings",_wrap_Model_texBindings_get, _wrap_Model_texBindings_set},
    { "mapping",_wrap_Model_mapping_get, _wrap_Model_mapping_set},
    { "root",_wrap_Model_root_get, _wrap_Model_root_set},
    {0,0,0}
};
static swig_lua_class *swig_Model_bases[] = {0};
swig_lua_class _wrap_class_Model = { "Model", &SWIGTYPE_p_Model,_wrap_new_Model, swig_delete_Model, swig_Model_methods, swig_Model_attributes, swig_Model_bases };

static int _wrap_Load3DSObject(lua_State* L) {
  int SWIG_arg = -1;
  char *arg1 = (char *) 0 ;
  IProgressCtl *arg2 = 0 ;
  MdlObject *result = 0 ;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("Load3DSObject",2,SWIGTYPE_p_IProgressCtl);
  }
  
  result = (MdlObject *)Load3DSObject((char const *)arg1,*arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MdlObject,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Save3DSObject(lua_State* L) {
  int SWIG_arg = -1;
  char *arg1 = (char *) 0 ;
  MdlObject *arg2 = (MdlObject *) 0 ;
  IProgressCtl *arg3 = 0 ;
  bool result;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("Save3DSObject",2,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("Save3DSObject",3,SWIGTYPE_p_IProgressCtl);
  }
  
  result = (bool)Save3DSObject((char const *)arg1,arg2,*arg3);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LoadWavefrontObject(lua_State* L) {
  int SWIG_arg = -1;
  char *arg1 = (char *) 0 ;
  IProgressCtl *arg2 = 0 ;
  MdlObject *result = 0 ;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("LoadWavefrontObject",2,SWIGTYPE_p_IProgressCtl);
  }
  
  result = (MdlObject *)LoadWavefrontObject((char const *)arg1,*arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MdlObject,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SaveWavefrontObject(lua_State* L) {
  int SWIG_arg = -1;
  char *arg1 = (char *) 0 ;
  MdlObject *arg2 = (MdlObject *) 0 ;
  IProgressCtl *arg3 = 0 ;
  bool result;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("SaveWavefrontObject",2,SWIGTYPE_p_MdlObject);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_IProgressCtl,0))){
    SWIG_fail_ptr("SaveWavefrontObject",3,SWIGTYPE_p_IProgressCtl);
  }
  
  result = (bool)SaveWavefrontObject((char const *)arg1,arg2,*arg3);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GenerateUniqueVectors(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Vertex > *arg1 = 0 ;
  std::vector<Vector3 > *arg2 = 0 ;
  std::vector<int > *arg3 = 0 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTVertex_t,0))){
    SWIG_fail_ptr("GenerateUniqueVectors",1,SWIGTYPE_p_std__vectorTVertex_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorTVector3_t,0))){
    SWIG_fail_ptr("GenerateUniqueVectors",2,SWIGTYPE_p_std__vectorTVector3_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_std__vectorTint_t,0))){
    SWIG_fail_ptr("GenerateUniqueVectors",3,SWIGTYPE_p_std__vectorTint_t);
  }
  
  GenerateUniqueVectors((std::vector<Vertex > const &)*arg1,*arg2,*arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimProperty__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *result = 0 ;
  
  result = (AnimProperty *)new AnimProperty();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_AnimProperty,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimProperty__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  AnimController *arg1 = (AnimController *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  AnimProperty *result = 0 ;
  std::string temp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimController,0))){
    SWIG_fail_ptr("new_AnimProperty",1,SWIGTYPE_p_AnimController);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  arg3 = (int)lua_tonumber(L, 3);
  result = (AnimProperty *)new AnimProperty(arg1,(std::string const &)*arg2,arg3);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_AnimProperty,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimProperty(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_AnimProperty__SWIG_0(L);
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_AnimController, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isstring(L,argv[1]);
      }
      if (_v) {
        {
          _v = lua_isnumber(L,argv[2]);
        }
        if (_v) {
          return _wrap_new_AnimProperty__SWIG_1(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_AnimProperty'");
  lua_error(L);return 0;
}


static int _wrap_delete_AnimProperty(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("delete_AnimProperty",1,SWIGTYPE_p_AnimProperty);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_GetKeyIndex__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  float arg2 ;
  int *arg3 = (int *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_GetKeyIndex",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("AnimProperty_GetKeyIndex",3,SWIGTYPE_p_int);
  }
  
  result = (int)(arg1)->GetKeyIndex(arg2,arg3);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_GetKeyIndex__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  float arg2 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_GetKeyIndex",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (int)(arg1)->GetKeyIndex(arg2);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_GetKeyIndex(lua_State* L) {
  int argc;
  int argv[4]={
    1,2,3,4
  };
  
  argc = lua_gettop(L);
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_AnimProperty, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        return _wrap_AnimProperty_GetKeyIndex__SWIG_1(L);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_AnimProperty, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, SWIGTYPE_p_int, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_AnimProperty_GetKeyIndex__SWIG_0(L);
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'AnimProperty_GetKeyIndex'");
  lua_error(L);return 0;
}


static int _wrap_AnimProperty_Evaluate__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  float arg2 ;
  void *arg3 = (void *) 0 ;
  int *arg4 = (int *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_Evaluate",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3=(void *)SWIG_MustGetPtr(L,3,0,0,3,"AnimProperty_Evaluate");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("AnimProperty_Evaluate",4,SWIGTYPE_p_int);
  }
  
  (arg1)->Evaluate(arg2,arg3,arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_Evaluate__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  float arg2 ;
  void *arg3 = (void *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_Evaluate",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3=(void *)SWIG_MustGetPtr(L,3,0,0,3,"AnimProperty_Evaluate");
  (arg1)->Evaluate(arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_Evaluate(lua_State* L) {
  int argc;
  int argv[5]={
    1,2,3,4,5
  };
  
  argc = lua_gettop(L);
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_AnimProperty, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, 0, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_AnimProperty_Evaluate__SWIG_1(L);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if (SWIG_isptrtype(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_AnimProperty, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      {
        _v = lua_isnumber(L,argv[1]);
      }
      if (_v) {
        {
          void *ptr;
          if (SWIG_isptrtype(L,argv[2])==0 || SWIG_ConvertPtr(L,argv[2], (void **) &ptr, 0, 0)) {
            _v = 0;
          } else {
            _v = 1;
          }
        }
        if (_v) {
          {
            void *ptr;
            if (SWIG_isptrtype(L,argv[3])==0 || SWIG_ConvertPtr(L,argv[3], (void **) &ptr, SWIGTYPE_p_int, 0)) {
              _v = 0;
            } else {
              _v = 1;
            }
          }
          if (_v) {
            return _wrap_AnimProperty_Evaluate__SWIG_0(L);
          }
        }
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'AnimProperty_Evaluate'");
  lua_error(L);return 0;
}


static int _wrap_AnimProperty_InsertKey(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  void *arg2 = (void *) 0 ;
  float arg3 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_InsertKey",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"AnimProperty_InsertKey");
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->InsertKey(arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_ChopAnimation(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  float arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_ChopAnimation",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  (arg1)->ChopAnimation(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_GetKeyData(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  int arg2 ;
  float *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_GetKeyData",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (float *)(arg1)->GetKeyData(arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_NumKeys(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_NumKeys",1,SWIGTYPE_p_AnimProperty);
  }
  
  result = (int)(arg1)->NumKeys();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_GetKeyTime(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  int arg2 ;
  float *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_GetKeyTime",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  {
    float &_result_ref = (arg1)->GetKeyTime(arg2);
    result = (float *) &_result_ref;
  }
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_SetKeyTime(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  int arg2 ;
  float arg3 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_SetKeyTime",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->SetKeyTime(arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_GetName(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  char *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_GetName",1,SWIGTYPE_p_AnimProperty);
  }
  
  result = (char *)(arg1)->GetName();
  SWIG_arg=0;
  lua_pushstring(L,(const char*)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_Clear(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_Clear",1,SWIGTYPE_p_AnimProperty);
  }
  
  (arg1)->Clear();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_Clone(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  AnimProperty *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_Clone",1,SWIGTYPE_p_AnimProperty);
  }
  
  result = (AnimProperty *)(arg1)->Clone();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_AnimProperty,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_keyData_set(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  std::vector<char > *arg2 = (std::vector<char > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_keyData_set",1,SWIGTYPE_p_AnimProperty);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorTchar_t,0))){
    SWIG_fail_ptr("AnimProperty_keyData_set",2,SWIGTYPE_p_std__vectorTchar_t);
  }
  
  if (arg1) (arg1)->keyData = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_keyData_get(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  std::vector<char > *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_keyData_get",1,SWIGTYPE_p_AnimProperty);
  }
  
  result = (std::vector<char > *)& ((arg1)->keyData);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTchar_t,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_offset_set(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  int arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_offset_set",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->offset = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_offset_get(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_offset_get",1,SWIGTYPE_p_AnimProperty);
  }
  
  result = (int) ((arg1)->offset);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_elemSize_set(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  int arg2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_elemSize_set",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->elemSize = arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_elemSize_get(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_elemSize_get",1,SWIGTYPE_p_AnimProperty);
  }
  
  result = (int) ((arg1)->elemSize);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_name_set(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_name_set",1,SWIGTYPE_p_AnimProperty);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  if (arg1) (arg1)->name = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimProperty_name_get(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = (AnimProperty *) 0 ;
  std::string *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimProperty_name_get",1,SWIGTYPE_p_AnimProperty);
  }
  
  {
    std::string const &_result_ref =  ((arg1)->name);
    result = (std::string *) &_result_ref;
  }
  SWIG_arg=0;
  lua_pushlstring(L,result->data(),result->size()); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_AnimProperty(void *obj) {
AnimProperty *arg1 = (AnimProperty *) obj;
delete arg1;
}
static swig_lua_method swig_AnimProperty_methods[] = {
    {"GetKeyIndex", _wrap_AnimProperty_GetKeyIndex}, 
    {"Evaluate", _wrap_AnimProperty_Evaluate}, 
    {"InsertKey", _wrap_AnimProperty_InsertKey}, 
    {"ChopAnimation", _wrap_AnimProperty_ChopAnimation}, 
    {"GetKeyData", _wrap_AnimProperty_GetKeyData}, 
    {"NumKeys", _wrap_AnimProperty_NumKeys}, 
    {"GetKeyTime", _wrap_AnimProperty_GetKeyTime}, 
    {"SetKeyTime", _wrap_AnimProperty_SetKeyTime}, 
    {"GetName", _wrap_AnimProperty_GetName}, 
    {"Clear", _wrap_AnimProperty_Clear}, 
    {"Clone", _wrap_AnimProperty_Clone}, 
    {0,0}
};
static swig_lua_attribute swig_AnimProperty_attributes[] = {
    { "keyData",_wrap_AnimProperty_keyData_get, _wrap_AnimProperty_keyData_set},
    { "offset",_wrap_AnimProperty_offset_get, _wrap_AnimProperty_offset_set},
    { "elemSize",_wrap_AnimProperty_elemSize_get, _wrap_AnimProperty_elemSize_set},
    { "name",_wrap_AnimProperty_name_get, _wrap_AnimProperty_name_set},
    {0,0,0}
};
static swig_lua_class *swig_AnimProperty_bases[] = {0};
swig_lua_class _wrap_class_AnimProperty = { "AnimProperty", &SWIGTYPE_p_AnimProperty,_wrap_new_AnimProperty, swig_delete_AnimProperty, swig_AnimProperty_methods, swig_AnimProperty_attributes, swig_AnimProperty_bases };

static int _wrap_delete_AnimationInfo(lua_State* L) {
  int SWIG_arg = -1;
  AnimationInfo *arg1 = (AnimationInfo *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("delete_AnimationInfo",1,SWIGTYPE_p_AnimationInfo);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfo_Serialize(lua_State* L) {
  int SWIG_arg = -1;
  AnimationInfo *arg1 = (AnimationInfo *) 0 ;
  creg::ISerializer *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("AnimationInfo_Serialize",1,SWIGTYPE_p_AnimationInfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_creg__ISerializer,0))){
    SWIG_fail_ptr("AnimationInfo_Serialize",2,SWIGTYPE_p_creg__ISerializer);
  }
  
  (arg1)->Serialize(*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfo_AddProperty(lua_State* L) {
  int SWIG_arg = -1;
  AnimationInfo *arg1 = (AnimationInfo *) 0 ;
  AnimController *arg2 = (AnimController *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!lua_isstring(L,3)) SWIG_fail_arg(3);
  if(!lua_isnumber(L,4)) SWIG_fail_arg(4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("AnimationInfo_AddProperty",1,SWIGTYPE_p_AnimationInfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_AnimController,0))){
    SWIG_fail_ptr("AnimationInfo_AddProperty",2,SWIGTYPE_p_AnimController);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  (arg1)->AddProperty(arg2,(char const *)arg3,arg4);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfo_Evaluate(lua_State* L) {
  int SWIG_arg = -1;
  AnimationInfo *arg1 = (AnimationInfo *) 0 ;
  void *arg2 = (void *) 0 ;
  float arg3 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("AnimationInfo_Evaluate",1,SWIGTYPE_p_AnimationInfo);
  }
  
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"AnimationInfo_Evaluate");
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->Evaluate(arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfo_InsertKeyFrames(lua_State* L) {
  int SWIG_arg = -1;
  AnimationInfo *arg1 = (AnimationInfo *) 0 ;
  void *arg2 = (void *) 0 ;
  float arg3 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("AnimationInfo_InsertKeyFrames",1,SWIGTYPE_p_AnimationInfo);
  }
  
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"AnimationInfo_InsertKeyFrames");
  arg3 = (float)lua_tonumber(L, 3);
  (arg1)->InsertKeyFrames(arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfo_ClearAnimData(lua_State* L) {
  int SWIG_arg = -1;
  AnimationInfo *arg1 = (AnimationInfo *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("AnimationInfo_ClearAnimData",1,SWIGTYPE_p_AnimationInfo);
  }
  
  (arg1)->ClearAnimData();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfo_CopyTo(lua_State* L) {
  int SWIG_arg = -1;
  AnimationInfo *arg1 = (AnimationInfo *) 0 ;
  AnimationInfo *arg2 = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("AnimationInfo_CopyTo",1,SWIGTYPE_p_AnimationInfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("AnimationInfo_CopyTo",2,SWIGTYPE_p_AnimationInfo);
  }
  
  (arg1)->CopyTo(*arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfo_properties_set(lua_State* L) {
  int SWIG_arg = -1;
  AnimationInfo *arg1 = (AnimationInfo *) 0 ;
  std::vector<AnimProperty * > *arg2 = (std::vector<AnimProperty * > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("AnimationInfo_properties_set",1,SWIGTYPE_p_AnimationInfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorTAnimProperty_p_t,0))){
    SWIG_fail_ptr("AnimationInfo_properties_set",2,SWIGTYPE_p_std__vectorTAnimProperty_p_t);
  }
  
  if (arg1) (arg1)->properties = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfo_properties_get(lua_State* L) {
  int SWIG_arg = -1;
  AnimationInfo *arg1 = (AnimationInfo *) 0 ;
  std::vector<AnimProperty * > *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("AnimationInfo_properties_get",1,SWIGTYPE_p_AnimationInfo);
  }
  
  result = (std::vector<AnimProperty * > *)& ((arg1)->properties);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTAnimProperty_p_t,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_AnimationInfo(void *obj) {
AnimationInfo *arg1 = (AnimationInfo *) obj;
delete arg1;
}
static swig_lua_method swig_AnimationInfo_methods[] = {
    {"Serialize", _wrap_AnimationInfo_Serialize}, 
    {"AddProperty", _wrap_AnimationInfo_AddProperty}, 
    {"Evaluate", _wrap_AnimationInfo_Evaluate}, 
    {"InsertKeyFrames", _wrap_AnimationInfo_InsertKeyFrames}, 
    {"ClearAnimData", _wrap_AnimationInfo_ClearAnimData}, 
    {"CopyTo", _wrap_AnimationInfo_CopyTo}, 
    {0,0}
};
static swig_lua_attribute swig_AnimationInfo_attributes[] = {
    { "properties",_wrap_AnimationInfo_properties_get, _wrap_AnimationInfo_properties_set},
    {0,0,0}
};
static swig_lua_class *swig_AnimationInfo_bases[] = {0};
swig_lua_class _wrap_class_AnimationInfo = { "AnimationInfo", &SWIGTYPE_p_AnimationInfo,0, swig_delete_AnimationInfo, swig_AnimationInfo_methods, swig_AnimationInfo_attributes, swig_AnimationInfo_bases };

static int _wrap_AnimationSequence_name_set(lua_State* L) {
  int SWIG_arg = -1;
  AnimationSequence *arg1 = (AnimationSequence *) 0 ;
  std::string *arg2 = 0 ;
  std::string temp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimationSequence,0))){
    SWIG_fail_ptr("AnimationSequence_name_set",1,SWIGTYPE_p_AnimationSequence);
  }
  
  temp2.assign(lua_tostring(L,2),lua_strlen(L,2)); arg2=&temp2;
  if (arg1) (arg1)->name = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationSequence_name_get(lua_State* L) {
  int SWIG_arg = -1;
  AnimationSequence *arg1 = (AnimationSequence *) 0 ;
  std::string *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimationSequence,0))){
    SWIG_fail_ptr("AnimationSequence_name_get",1,SWIGTYPE_p_AnimationSequence);
  }
  
  {
    std::string const &_result_ref =  ((arg1)->name);
    result = (std::string *) &_result_ref;
  }
  SWIG_arg=0;
  lua_pushlstring(L,result->data(),result->size()); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationSequence_objects_set(lua_State* L) {
  int SWIG_arg = -1;
  AnimationSequence *arg1 = (AnimationSequence *) 0 ;
  std::vector<AnimationInfo * > *arg2 = (std::vector<AnimationInfo * > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimationSequence,0))){
    SWIG_fail_ptr("AnimationSequence_objects_set",1,SWIGTYPE_p_AnimationSequence);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,0))){
    SWIG_fail_ptr("AnimationSequence_objects_set",2,SWIGTYPE_p_std__vectorTAnimationInfo_p_t);
  }
  
  if (arg1) (arg1)->objects = *arg2;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationSequence_objects_get(lua_State* L) {
  int SWIG_arg = -1;
  AnimationSequence *arg1 = (AnimationSequence *) 0 ;
  std::vector<AnimationInfo * > *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimationSequence,0))){
    SWIG_fail_ptr("AnimationSequence_objects_get",1,SWIGTYPE_p_AnimationSequence);
  }
  
  result = (std::vector<AnimationInfo * > *)& ((arg1)->objects);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimationSequence(lua_State* L) {
  int SWIG_arg = -1;
  AnimationSequence *result = 0 ;
  
  result = (AnimationSequence *)new AnimationSequence();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_AnimationSequence,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_AnimationSequence(lua_State* L) {
  int SWIG_arg = -1;
  AnimationSequence *arg1 = (AnimationSequence *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimationSequence,0))){
    SWIG_fail_ptr("delete_AnimationSequence",1,SWIGTYPE_p_AnimationSequence);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_AnimationSequence(void *obj) {
AnimationSequence *arg1 = (AnimationSequence *) obj;
delete arg1;
}
static swig_lua_method swig_AnimationSequence_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_AnimationSequence_attributes[] = {
    { "name",_wrap_AnimationSequence_name_get, _wrap_AnimationSequence_name_set},
    { "objects",_wrap_AnimationSequence_objects_get, _wrap_AnimationSequence_objects_set},
    {0,0,0}
};
static swig_lua_class *swig_AnimationSequence_bases[] = {0};
swig_lua_class _wrap_class_AnimationSequence = { "AnimationSequence", &SWIGTYPE_p_AnimationSequence,_wrap_new_AnimationSequence, swig_delete_AnimationSequence, swig_AnimationSequence_methods, swig_AnimationSequence_attributes, swig_AnimationSequence_bases };

static int _wrap_IEditor_Update(lua_State* L) {
  int SWIG_arg = -1;
  IEditor *arg1 = (IEditor *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IEditor,0))){
    SWIG_fail_ptr("IEditor_Update",1,SWIGTYPE_p_IEditor);
  }
  
  (arg1)->Update();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IEditor_RedrawViews(lua_State* L) {
  int SWIG_arg = -1;
  IEditor *arg1 = (IEditor *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IEditor,0))){
    SWIG_fail_ptr("IEditor_RedrawViews",1,SWIGTYPE_p_IEditor);
  }
  
  (arg1)->RedrawViews();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IEditor_GetViews(lua_State* L) {
  int SWIG_arg = -1;
  IEditor *arg1 = (IEditor *) 0 ;
  SwigValueWrapper<std::vector<EditorViewWindow * > > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IEditor,0))){
    SWIG_fail_ptr("IEditor_GetViews",1,SWIGTYPE_p_IEditor);
  }
  
  result = (arg1)->GetViews();
  SWIG_arg=0;
  {
    std::vector<EditorViewWindow * > * resultptr = new std::vector<EditorViewWindow * >((std::vector<EditorViewWindow * > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__vectorTEditorViewWindow_p_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IEditor_MergeView(lua_State* L) {
  int SWIG_arg = -1;
  IEditor *arg1 = (IEditor *) 0 ;
  EditorViewWindow *arg2 = (EditorViewWindow *) 0 ;
  EditorViewWindow *arg3 = (EditorViewWindow *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IEditor,0))){
    SWIG_fail_ptr("IEditor_MergeView",1,SWIGTYPE_p_IEditor);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_EditorViewWindow,0))){
    SWIG_fail_ptr("IEditor_MergeView",2,SWIGTYPE_p_EditorViewWindow);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_EditorViewWindow,0))){
    SWIG_fail_ptr("IEditor_MergeView",3,SWIGTYPE_p_EditorViewWindow);
  }
  
  (arg1)->MergeView(arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IEditor_AddView(lua_State* L) {
  int SWIG_arg = -1;
  IEditor *arg1 = (IEditor *) 0 ;
  EditorViewWindow *arg2 = (EditorViewWindow *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IEditor,0))){
    SWIG_fail_ptr("IEditor_AddView",1,SWIGTYPE_p_IEditor);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_EditorViewWindow,0))){
    SWIG_fail_ptr("IEditor_AddView",2,SWIGTYPE_p_EditorViewWindow);
  }
  
  (arg1)->AddView(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IEditor_SelectionUpdated(lua_State* L) {
  int SWIG_arg = -1;
  IEditor *arg1 = (IEditor *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IEditor,0))){
    SWIG_fail_ptr("IEditor_SelectionUpdated",1,SWIGTYPE_p_IEditor);
  }
  
  (arg1)->SelectionUpdated();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IEditor_GetMdl(lua_State* L) {
  int SWIG_arg = -1;
  IEditor *arg1 = (IEditor *) 0 ;
  Model *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IEditor,0))){
    SWIG_fail_ptr("IEditor_GetMdl",1,SWIGTYPE_p_IEditor);
  }
  
  result = (Model *)(arg1)->GetMdl();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Model,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IEditor_GetTool(lua_State* L) {
  int SWIG_arg = -1;
  IEditor *arg1 = (IEditor *) 0 ;
  Tool *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IEditor,0))){
    SWIG_fail_ptr("IEditor_GetTool",1,SWIGTYPE_p_IEditor);
  }
  
  result = (Tool *)(arg1)->GetTool();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Tool,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IEditor_RenderScene(lua_State* L) {
  int SWIG_arg = -1;
  IEditor *arg1 = (IEditor *) 0 ;
  IView *arg2 = (IView *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IEditor,0))){
    SWIG_fail_ptr("IEditor_RenderScene",1,SWIGTYPE_p_IEditor);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_IView,0))){
    SWIG_fail_ptr("IEditor_RenderScene",2,SWIGTYPE_p_IView);
  }
  
  (arg1)->RenderScene(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IEditor_GetTextureHandler(lua_State* L) {
  int SWIG_arg = -1;
  IEditor *arg1 = (IEditor *) 0 ;
  TextureHandler *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IEditor,0))){
    SWIG_fail_ptr("IEditor_GetTextureHandler",1,SWIGTYPE_p_IEditor);
  }
  
  result = (TextureHandler *)(arg1)->GetTextureHandler();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_TextureHandler,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IEditor_SetTextureSelectCallback(lua_State* L) {
  int SWIG_arg = -1;
  IEditor *arg1 = (IEditor *) 0 ;
  void (*arg2)(Texture *,void *) = (void (*)(Texture *,void *)) 0 ;
  void *arg3 = (void *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IEditor,0))){
    SWIG_fail_ptr("IEditor_SetTextureSelectCallback",1,SWIGTYPE_p_IEditor);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_f_p_Texture_p_void__void,0))){
    SWIG_fail_ptr("IEditor_SetTextureSelectCallback",2,SWIGTYPE_p_f_p_Texture_p_void__void);
  }
  
  arg3=(void *)SWIG_MustGetPtr(L,3,0,0,3,"IEditor_SetTextureSelectCallback");
  (arg1)->SetTextureSelectCallback(arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IEditor_GetTime(lua_State* L) {
  int SWIG_arg = -1;
  IEditor *arg1 = (IEditor *) 0 ;
  float result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IEditor,0))){
    SWIG_fail_ptr("IEditor_GetTime",1,SWIGTYPE_p_IEditor);
  }
  
  result = (float)(arg1)->GetTime();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IEditor_SetModel(lua_State* L) {
  int SWIG_arg = -1;
  IEditor *arg1 = (IEditor *) 0 ;
  Model *arg2 = (Model *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IEditor,0))){
    SWIG_fail_ptr("IEditor_SetModel",1,SWIGTYPE_p_IEditor);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Model,0))){
    SWIG_fail_ptr("IEditor_SetModel",2,SWIGTYPE_p_Model);
  }
  
  (arg1)->SetModel(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_IEditor(lua_State* L) {
  int SWIG_arg = -1;
  IEditor *arg1 = (IEditor *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_IEditor,0))){
    SWIG_fail_ptr("delete_IEditor",1,SWIGTYPE_p_IEditor);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_IEditor(void *obj) {
IEditor *arg1 = (IEditor *) obj;
delete arg1;
}
static swig_lua_method swig_IEditor_methods[] = {
    {"Update", _wrap_IEditor_Update}, 
    {"RedrawViews", _wrap_IEditor_RedrawViews}, 
    {"GetViews", _wrap_IEditor_GetViews}, 
    {"MergeView", _wrap_IEditor_MergeView}, 
    {"AddView", _wrap_IEditor_AddView}, 
    {"SelectionUpdated", _wrap_IEditor_SelectionUpdated}, 
    {"GetMdl", _wrap_IEditor_GetMdl}, 
    {"GetTool", _wrap_IEditor_GetTool}, 
    {"RenderScene", _wrap_IEditor_RenderScene}, 
    {"GetTextureHandler", _wrap_IEditor_GetTextureHandler}, 
    {"SetTextureSelectCallback", _wrap_IEditor_SetTextureSelectCallback}, 
    {"GetTime", _wrap_IEditor_GetTime}, 
    {"SetModel", _wrap_IEditor_SetModel}, 
    {0,0}
};
static swig_lua_attribute swig_IEditor_attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_IEditor_bases[] = {0};
swig_lua_class _wrap_class_IEditor = { "IEditor", &SWIGTYPE_p_IEditor,0, swig_delete_IEditor, swig_IEditor_methods, swig_IEditor_attributes, swig_IEditor_bases };

static int _wrap_upsGetEditor(lua_State* L) {
  int SWIG_arg = -1;
  IEditor *result = 0 ;
  
  result = (IEditor *)upsGetEditor();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_IEditor,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_upsAddMenuItem(lua_State* L) {
  int SWIG_arg = -1;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (char *)lua_tostring(L, 2);
  upsAddMenuItem((char const *)arg1,(char const *)arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PolyRefArray__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Poly * > *result = 0 ;
  
  result = (std::vector<Poly * > *)new std::vector<Poly * >();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTPoly_p_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PolyRefArray__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  std::vector<Poly * > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector<Poly * > *)new std::vector<Poly * >(arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTPoly_p_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PolyRefArray__SWIG_2(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Poly * > *arg1 = 0 ;
  std::vector<Poly * > *result = 0 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTPoly_p_t,0))){
    SWIG_fail_ptr("new_PolyRefArray",1,SWIGTYPE_p_std__vectorTPoly_p_t);
  }
  
  result = (std::vector<Poly * > *)new std::vector<Poly * >((std::vector<Poly * > const &)*arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTPoly_p_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PolyRefArray__SWIG_3(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  Poly *arg2 = (Poly *) 0 ;
  std::vector<Poly * > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("new_PolyRefArray",2,SWIGTYPE_p_Poly);
  }
  
  result = (std::vector<Poly * > *)new std::vector<Poly * >(arg1,arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTPoly_p_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PolyRefArray(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_PolyRefArray__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorTPoly_p_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_PolyRefArray__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_PolyRefArray__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_Poly, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_PolyRefArray__SWIG_3(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_PolyRefArray'");
  lua_error(L);return 0;
}


static int _wrap_PolyRefArray_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Poly * > *arg1 = (std::vector<Poly * > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTPoly_p_t,0))){
    SWIG_fail_ptr("PolyRefArray_size",1,SWIGTYPE_p_std__vectorTPoly_p_t);
  }
  
  result = (unsigned int)((std::vector<Poly * > const *)arg1)->size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyRefArray_max_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Poly * > *arg1 = (std::vector<Poly * > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTPoly_p_t,0))){
    SWIG_fail_ptr("PolyRefArray_max_size",1,SWIGTYPE_p_std__vectorTPoly_p_t);
  }
  
  result = (unsigned int)((std::vector<Poly * > const *)arg1)->max_size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyRefArray_empty(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Poly * > *arg1 = (std::vector<Poly * > *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTPoly_p_t,0))){
    SWIG_fail_ptr("PolyRefArray_empty",1,SWIGTYPE_p_std__vectorTPoly_p_t);
  }
  
  result = (bool)((std::vector<Poly * > const *)arg1)->empty();
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyRefArray_clear(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Poly * > *arg1 = (std::vector<Poly * > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTPoly_p_t,0))){
    SWIG_fail_ptr("PolyRefArray_clear",1,SWIGTYPE_p_std__vectorTPoly_p_t);
  }
  
  (arg1)->clear();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyRefArray_push_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Poly * > *arg1 = (std::vector<Poly * > *) 0 ;
  Poly *arg2 = (Poly *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTPoly_p_t,0))){
    SWIG_fail_ptr("PolyRefArray_push_back",1,SWIGTYPE_p_std__vectorTPoly_p_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("PolyRefArray_push_back",2,SWIGTYPE_p_Poly);
  }
  
  (arg1)->push_back(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyRefArray_pop_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Poly * > *arg1 = (std::vector<Poly * > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTPoly_p_t,0))){
    SWIG_fail_ptr("PolyRefArray_pop_back",1,SWIGTYPE_p_std__vectorTPoly_p_t);
  }
  
  (arg1)->pop_back();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyRefArray_front(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Poly * > *arg1 = (std::vector<Poly * > *) 0 ;
  Poly *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTPoly_p_t,0))){
    SWIG_fail_ptr("PolyRefArray_front",1,SWIGTYPE_p_std__vectorTPoly_p_t);
  }
  
  result = (Poly *)((std::vector<Poly * > const *)arg1)->front();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Poly,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyRefArray_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Poly * > *arg1 = (std::vector<Poly * > *) 0 ;
  Poly *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTPoly_p_t,0))){
    SWIG_fail_ptr("PolyRefArray_back",1,SWIGTYPE_p_std__vectorTPoly_p_t);
  }
  
  result = (Poly *)((std::vector<Poly * > const *)arg1)->back();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Poly,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyRefArray___getitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Poly * > *arg1 = (std::vector<Poly * > *) 0 ;
  unsigned int arg2 ;
  Poly *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTPoly_p_t,0))){
    SWIG_fail_ptr("PolyRefArray___getitem",1,SWIGTYPE_p_std__vectorTPoly_p_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  try {
    result = (Poly *)std_vector_Sl_Poly_Sm__Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Poly,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyRefArray___setitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Poly * > *arg1 = (std::vector<Poly * > *) 0 ;
  unsigned int arg2 ;
  Poly *arg3 = (Poly *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTPoly_p_t,0))){
    SWIG_fail_ptr("PolyRefArray___setitem",1,SWIGTYPE_p_std__vectorTPoly_p_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_Poly,0))){
    SWIG_fail_ptr("PolyRefArray___setitem",3,SWIGTYPE_p_Poly);
  }
  
  try {
    std_vector_Sl_Poly_Sm__Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolyRefArray___len(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Poly * > *arg1 = (std::vector<Poly * > *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTPoly_p_t,0))){
    SWIG_fail_ptr("PolyRefArray___len",1,SWIGTYPE_p_std__vectorTPoly_p_t);
  }
  
  result = (int)std_vector_Sl_Poly_Sm__Sg____len(arg1);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_PolyRefArray(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Poly * > *arg1 = (std::vector<Poly * > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTPoly_p_t,0))){
    SWIG_fail_ptr("delete_PolyRefArray",1,SWIGTYPE_p_std__vectorTPoly_p_t);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_PolyRefArray(void *obj) {
std::vector<Poly * > *arg1 = (std::vector<Poly * > *) obj;
delete arg1;
}
static swig_lua_method swig_std_vector_Sl_Poly_Sm__Sg__methods[] = {
    {"size", _wrap_PolyRefArray_size}, 
    {"max_size", _wrap_PolyRefArray_max_size}, 
    {"empty", _wrap_PolyRefArray_empty}, 
    {"clear", _wrap_PolyRefArray_clear}, 
    {"push_back", _wrap_PolyRefArray_push_back}, 
    {"pop_back", _wrap_PolyRefArray_pop_back}, 
    {"front", _wrap_PolyRefArray_front}, 
    {"back", _wrap_PolyRefArray_back}, 
    {"__getitem", _wrap_PolyRefArray___getitem}, 
    {"__setitem", _wrap_PolyRefArray___setitem}, 
    {"__len", _wrap_PolyRefArray___len}, 
    {0,0}
};
static swig_lua_attribute swig_std_vector_Sl_Poly_Sm__Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_vector_Sl_Poly_Sm__Sg__bases[] = {0};
swig_lua_class _wrap_class_std_vector_Sl_Poly_Sm__Sg_ = { "PolyRefArray", &SWIGTYPE_p_std__vectorTPoly_p_t,_wrap_new_PolyRefArray, swig_delete_PolyRefArray, swig_std_vector_Sl_Poly_Sm__Sg__methods, swig_std_vector_Sl_Poly_Sm__Sg__attributes, swig_std_vector_Sl_Poly_Sm__Sg__bases };

static int _wrap_new_VertexArray__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Vertex > *result = 0 ;
  
  result = (std::vector<Vertex > *)new std::vector<Vertex >();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTVertex_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VertexArray__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  std::vector<Vertex > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector<Vertex > *)new std::vector<Vertex >(arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTVertex_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VertexArray__SWIG_2(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Vertex > *arg1 = 0 ;
  std::vector<Vertex > *result = 0 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTVertex_t,0))){
    SWIG_fail_ptr("new_VertexArray",1,SWIGTYPE_p_std__vectorTVertex_t);
  }
  
  result = (std::vector<Vertex > *)new std::vector<Vertex >((std::vector<Vertex > const &)*arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTVertex_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VertexArray__SWIG_3(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  SwigValueWrapper<Vertex > arg2 ;
  std::vector<Vertex > *result = 0 ;
  Vertex *argp2 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Vertex,0))){
    SWIG_fail_ptr("new_VertexArray",2,SWIGTYPE_Vertex);
  }
  arg2 = *argp2;
  
  result = (std::vector<Vertex > *)new std::vector<Vertex >(arg1,arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTVertex_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_VertexArray(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_VertexArray__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorTVertex_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_VertexArray__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_VertexArray__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_Vertex, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_VertexArray__SWIG_3(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_VertexArray'");
  lua_error(L);return 0;
}


static int _wrap_VertexArray_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Vertex > *arg1 = (std::vector<Vertex > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTVertex_t,0))){
    SWIG_fail_ptr("VertexArray_size",1,SWIGTYPE_p_std__vectorTVertex_t);
  }
  
  result = (unsigned int)((std::vector<Vertex > const *)arg1)->size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VertexArray_max_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Vertex > *arg1 = (std::vector<Vertex > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTVertex_t,0))){
    SWIG_fail_ptr("VertexArray_max_size",1,SWIGTYPE_p_std__vectorTVertex_t);
  }
  
  result = (unsigned int)((std::vector<Vertex > const *)arg1)->max_size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VertexArray_empty(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Vertex > *arg1 = (std::vector<Vertex > *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTVertex_t,0))){
    SWIG_fail_ptr("VertexArray_empty",1,SWIGTYPE_p_std__vectorTVertex_t);
  }
  
  result = (bool)((std::vector<Vertex > const *)arg1)->empty();
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VertexArray_clear(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Vertex > *arg1 = (std::vector<Vertex > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTVertex_t,0))){
    SWIG_fail_ptr("VertexArray_clear",1,SWIGTYPE_p_std__vectorTVertex_t);
  }
  
  (arg1)->clear();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VertexArray_push_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Vertex > *arg1 = (std::vector<Vertex > *) 0 ;
  SwigValueWrapper<Vertex > arg2 ;
  Vertex *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTVertex_t,0))){
    SWIG_fail_ptr("VertexArray_push_back",1,SWIGTYPE_p_std__vectorTVertex_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Vertex,0))){
    SWIG_fail_ptr("VertexArray_push_back",2,SWIGTYPE_Vertex);
  }
  arg2 = *argp2;
  
  (arg1)->push_back(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VertexArray_pop_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Vertex > *arg1 = (std::vector<Vertex > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTVertex_t,0))){
    SWIG_fail_ptr("VertexArray_pop_back",1,SWIGTYPE_p_std__vectorTVertex_t);
  }
  
  (arg1)->pop_back();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VertexArray_front(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Vertex > *arg1 = (std::vector<Vertex > *) 0 ;
  SwigValueWrapper<Vertex > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTVertex_t,0))){
    SWIG_fail_ptr("VertexArray_front",1,SWIGTYPE_p_std__vectorTVertex_t);
  }
  
  result = ((std::vector<Vertex > const *)arg1)->front();
  SWIG_arg=0;
  {
    Vertex * resultptr = new Vertex((Vertex &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vertex,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VertexArray_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Vertex > *arg1 = (std::vector<Vertex > *) 0 ;
  SwigValueWrapper<Vertex > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTVertex_t,0))){
    SWIG_fail_ptr("VertexArray_back",1,SWIGTYPE_p_std__vectorTVertex_t);
  }
  
  result = ((std::vector<Vertex > const *)arg1)->back();
  SWIG_arg=0;
  {
    Vertex * resultptr = new Vertex((Vertex &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vertex,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VertexArray___getitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Vertex > *arg1 = (std::vector<Vertex > *) 0 ;
  unsigned int arg2 ;
  SwigValueWrapper<Vertex > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTVertex_t,0))){
    SWIG_fail_ptr("VertexArray___getitem",1,SWIGTYPE_p_std__vectorTVertex_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  try {
    result = std_vector_Sl_Vertex_Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  {
    Vertex * resultptr = new Vertex((Vertex &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vertex,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VertexArray___setitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Vertex > *arg1 = (std::vector<Vertex > *) 0 ;
  unsigned int arg2 ;
  SwigValueWrapper<Vertex > arg3 ;
  Vertex *argp3 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTVertex_t,0))){
    SWIG_fail_ptr("VertexArray___setitem",1,SWIGTYPE_p_std__vectorTVertex_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Vertex,0))){
    SWIG_fail_ptr("VertexArray___setitem",3,SWIGTYPE_Vertex);
  }
  arg3 = *argp3;
  
  try {
    std_vector_Sl_Vertex_Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VertexArray___len(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Vertex > *arg1 = (std::vector<Vertex > *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTVertex_t,0))){
    SWIG_fail_ptr("VertexArray___len",1,SWIGTYPE_p_std__vectorTVertex_t);
  }
  
  result = (int)std_vector_Sl_Vertex_Sg____len(arg1);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_VertexArray(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Vertex > *arg1 = (std::vector<Vertex > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTVertex_t,0))){
    SWIG_fail_ptr("delete_VertexArray",1,SWIGTYPE_p_std__vectorTVertex_t);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_VertexArray(void *obj) {
std::vector<Vertex > *arg1 = (std::vector<Vertex > *) obj;
delete arg1;
}
static swig_lua_method swig_std_vector_Sl_Vertex_Sg__methods[] = {
    {"size", _wrap_VertexArray_size}, 
    {"max_size", _wrap_VertexArray_max_size}, 
    {"empty", _wrap_VertexArray_empty}, 
    {"clear", _wrap_VertexArray_clear}, 
    {"push_back", _wrap_VertexArray_push_back}, 
    {"pop_back", _wrap_VertexArray_pop_back}, 
    {"front", _wrap_VertexArray_front}, 
    {"back", _wrap_VertexArray_back}, 
    {"__getitem", _wrap_VertexArray___getitem}, 
    {"__setitem", _wrap_VertexArray___setitem}, 
    {"__len", _wrap_VertexArray___len}, 
    {0,0}
};
static swig_lua_attribute swig_std_vector_Sl_Vertex_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_vector_Sl_Vertex_Sg__bases[] = {0};
swig_lua_class _wrap_class_std_vector_Sl_Vertex_Sg_ = { "VertexArray", &SWIGTYPE_p_std__vectorTVertex_t,_wrap_new_VertexArray, swig_delete_VertexArray, swig_std_vector_Sl_Vertex_Sg__methods, swig_std_vector_Sl_Vertex_Sg__attributes, swig_std_vector_Sl_Vertex_Sg__bases };

static int _wrap_new_TriArray__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Triangle > *result = 0 ;
  
  result = (std::vector<Triangle > *)new std::vector<Triangle >();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTTriangle_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TriArray__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  std::vector<Triangle > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector<Triangle > *)new std::vector<Triangle >(arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTTriangle_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TriArray__SWIG_2(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Triangle > *arg1 = 0 ;
  std::vector<Triangle > *result = 0 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTTriangle_t,0))){
    SWIG_fail_ptr("new_TriArray",1,SWIGTYPE_p_std__vectorTTriangle_t);
  }
  
  result = (std::vector<Triangle > *)new std::vector<Triangle >((std::vector<Triangle > const &)*arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTTriangle_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TriArray__SWIG_3(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  Triangle arg2 ;
  std::vector<Triangle > *result = 0 ;
  Triangle *argp2 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Triangle,0))){
    SWIG_fail_ptr("new_TriArray",2,SWIGTYPE_Triangle);
  }
  arg2 = *argp2;
  
  result = (std::vector<Triangle > *)new std::vector<Triangle >(arg1,arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTTriangle_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TriArray(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_TriArray__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorTTriangle_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_TriArray__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_TriArray__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_Triangle, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_TriArray__SWIG_3(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_TriArray'");
  lua_error(L);return 0;
}


static int _wrap_TriArray_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Triangle > *arg1 = (std::vector<Triangle > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTTriangle_t,0))){
    SWIG_fail_ptr("TriArray_size",1,SWIGTYPE_p_std__vectorTTriangle_t);
  }
  
  result = (unsigned int)((std::vector<Triangle > const *)arg1)->size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriArray_max_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Triangle > *arg1 = (std::vector<Triangle > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTTriangle_t,0))){
    SWIG_fail_ptr("TriArray_max_size",1,SWIGTYPE_p_std__vectorTTriangle_t);
  }
  
  result = (unsigned int)((std::vector<Triangle > const *)arg1)->max_size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriArray_empty(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Triangle > *arg1 = (std::vector<Triangle > *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTTriangle_t,0))){
    SWIG_fail_ptr("TriArray_empty",1,SWIGTYPE_p_std__vectorTTriangle_t);
  }
  
  result = (bool)((std::vector<Triangle > const *)arg1)->empty();
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriArray_clear(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Triangle > *arg1 = (std::vector<Triangle > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTTriangle_t,0))){
    SWIG_fail_ptr("TriArray_clear",1,SWIGTYPE_p_std__vectorTTriangle_t);
  }
  
  (arg1)->clear();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriArray_push_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Triangle > *arg1 = (std::vector<Triangle > *) 0 ;
  Triangle arg2 ;
  Triangle *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTTriangle_t,0))){
    SWIG_fail_ptr("TriArray_push_back",1,SWIGTYPE_p_std__vectorTTriangle_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_Triangle,0))){
    SWIG_fail_ptr("TriArray_push_back",2,SWIGTYPE_Triangle);
  }
  arg2 = *argp2;
  
  (arg1)->push_back(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriArray_pop_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Triangle > *arg1 = (std::vector<Triangle > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTTriangle_t,0))){
    SWIG_fail_ptr("TriArray_pop_back",1,SWIGTYPE_p_std__vectorTTriangle_t);
  }
  
  (arg1)->pop_back();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriArray_front(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Triangle > *arg1 = (std::vector<Triangle > *) 0 ;
  Triangle result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTTriangle_t,0))){
    SWIG_fail_ptr("TriArray_front",1,SWIGTYPE_p_std__vectorTTriangle_t);
  }
  
  result = ((std::vector<Triangle > const *)arg1)->front();
  SWIG_arg=0;
  {
    Triangle * resultptr = new Triangle((Triangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Triangle,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriArray_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Triangle > *arg1 = (std::vector<Triangle > *) 0 ;
  Triangle result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTTriangle_t,0))){
    SWIG_fail_ptr("TriArray_back",1,SWIGTYPE_p_std__vectorTTriangle_t);
  }
  
  result = ((std::vector<Triangle > const *)arg1)->back();
  SWIG_arg=0;
  {
    Triangle * resultptr = new Triangle((Triangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Triangle,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriArray___getitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Triangle > *arg1 = (std::vector<Triangle > *) 0 ;
  unsigned int arg2 ;
  Triangle result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTTriangle_t,0))){
    SWIG_fail_ptr("TriArray___getitem",1,SWIGTYPE_p_std__vectorTTriangle_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  try {
    result = std_vector_Sl_Triangle_Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  {
    Triangle * resultptr = new Triangle((Triangle &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Triangle,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriArray___setitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Triangle > *arg1 = (std::vector<Triangle > *) 0 ;
  unsigned int arg2 ;
  Triangle arg3 ;
  Triangle *argp3 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTTriangle_t,0))){
    SWIG_fail_ptr("TriArray___setitem",1,SWIGTYPE_p_std__vectorTTriangle_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Triangle,0))){
    SWIG_fail_ptr("TriArray___setitem",3,SWIGTYPE_Triangle);
  }
  arg3 = *argp3;
  
  try {
    std_vector_Sl_Triangle_Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TriArray___len(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Triangle > *arg1 = (std::vector<Triangle > *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTTriangle_t,0))){
    SWIG_fail_ptr("TriArray___len",1,SWIGTYPE_p_std__vectorTTriangle_t);
  }
  
  result = (int)std_vector_Sl_Triangle_Sg____len(arg1);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_TriArray(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<Triangle > *arg1 = (std::vector<Triangle > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTTriangle_t,0))){
    SWIG_fail_ptr("delete_TriArray",1,SWIGTYPE_p_std__vectorTTriangle_t);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_TriArray(void *obj) {
std::vector<Triangle > *arg1 = (std::vector<Triangle > *) obj;
delete arg1;
}
static swig_lua_method swig_std_vector_Sl_Triangle_Sg__methods[] = {
    {"size", _wrap_TriArray_size}, 
    {"max_size", _wrap_TriArray_max_size}, 
    {"empty", _wrap_TriArray_empty}, 
    {"clear", _wrap_TriArray_clear}, 
    {"push_back", _wrap_TriArray_push_back}, 
    {"pop_back", _wrap_TriArray_pop_back}, 
    {"front", _wrap_TriArray_front}, 
    {"back", _wrap_TriArray_back}, 
    {"__getitem", _wrap_TriArray___getitem}, 
    {"__setitem", _wrap_TriArray___setitem}, 
    {"__len", _wrap_TriArray___len}, 
    {0,0}
};
static swig_lua_attribute swig_std_vector_Sl_Triangle_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_vector_Sl_Triangle_Sg__bases[] = {0};
swig_lua_class _wrap_class_std_vector_Sl_Triangle_Sg_ = { "TriArray", &SWIGTYPE_p_std__vectorTTriangle_t,_wrap_new_TriArray, swig_delete_TriArray, swig_std_vector_Sl_Triangle_Sg__methods, swig_std_vector_Sl_Triangle_Sg__attributes, swig_std_vector_Sl_Triangle_Sg__bases };

static int _wrap_new_ObjectRefArray__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<MdlObject * > *result = 0 ;
  
  result = (std::vector<MdlObject * > *)new std::vector<MdlObject * >();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTMdlObject_p_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ObjectRefArray__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  std::vector<MdlObject * > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector<MdlObject * > *)new std::vector<MdlObject * >(arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTMdlObject_p_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ObjectRefArray__SWIG_2(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<MdlObject * > *arg1 = 0 ;
  std::vector<MdlObject * > *result = 0 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTMdlObject_p_t,0))){
    SWIG_fail_ptr("new_ObjectRefArray",1,SWIGTYPE_p_std__vectorTMdlObject_p_t);
  }
  
  result = (std::vector<MdlObject * > *)new std::vector<MdlObject * >((std::vector<MdlObject * > const &)*arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTMdlObject_p_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ObjectRefArray__SWIG_3(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  MdlObject *arg2 = (MdlObject *) 0 ;
  std::vector<MdlObject * > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("new_ObjectRefArray",2,SWIGTYPE_p_MdlObject);
  }
  
  result = (std::vector<MdlObject * > *)new std::vector<MdlObject * >(arg1,arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTMdlObject_p_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ObjectRefArray(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_ObjectRefArray__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorTMdlObject_p_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_ObjectRefArray__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_ObjectRefArray__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_MdlObject, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_ObjectRefArray__SWIG_3(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_ObjectRefArray'");
  lua_error(L);return 0;
}


static int _wrap_ObjectRefArray_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<MdlObject * > *arg1 = (std::vector<MdlObject * > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTMdlObject_p_t,0))){
    SWIG_fail_ptr("ObjectRefArray_size",1,SWIGTYPE_p_std__vectorTMdlObject_p_t);
  }
  
  result = (unsigned int)((std::vector<MdlObject * > const *)arg1)->size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectRefArray_max_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<MdlObject * > *arg1 = (std::vector<MdlObject * > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTMdlObject_p_t,0))){
    SWIG_fail_ptr("ObjectRefArray_max_size",1,SWIGTYPE_p_std__vectorTMdlObject_p_t);
  }
  
  result = (unsigned int)((std::vector<MdlObject * > const *)arg1)->max_size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectRefArray_empty(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<MdlObject * > *arg1 = (std::vector<MdlObject * > *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTMdlObject_p_t,0))){
    SWIG_fail_ptr("ObjectRefArray_empty",1,SWIGTYPE_p_std__vectorTMdlObject_p_t);
  }
  
  result = (bool)((std::vector<MdlObject * > const *)arg1)->empty();
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectRefArray_clear(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<MdlObject * > *arg1 = (std::vector<MdlObject * > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTMdlObject_p_t,0))){
    SWIG_fail_ptr("ObjectRefArray_clear",1,SWIGTYPE_p_std__vectorTMdlObject_p_t);
  }
  
  (arg1)->clear();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectRefArray_push_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<MdlObject * > *arg1 = (std::vector<MdlObject * > *) 0 ;
  MdlObject *arg2 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTMdlObject_p_t,0))){
    SWIG_fail_ptr("ObjectRefArray_push_back",1,SWIGTYPE_p_std__vectorTMdlObject_p_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("ObjectRefArray_push_back",2,SWIGTYPE_p_MdlObject);
  }
  
  (arg1)->push_back(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectRefArray_pop_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<MdlObject * > *arg1 = (std::vector<MdlObject * > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTMdlObject_p_t,0))){
    SWIG_fail_ptr("ObjectRefArray_pop_back",1,SWIGTYPE_p_std__vectorTMdlObject_p_t);
  }
  
  (arg1)->pop_back();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectRefArray_front(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<MdlObject * > *arg1 = (std::vector<MdlObject * > *) 0 ;
  MdlObject *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTMdlObject_p_t,0))){
    SWIG_fail_ptr("ObjectRefArray_front",1,SWIGTYPE_p_std__vectorTMdlObject_p_t);
  }
  
  result = (MdlObject *)((std::vector<MdlObject * > const *)arg1)->front();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MdlObject,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectRefArray_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<MdlObject * > *arg1 = (std::vector<MdlObject * > *) 0 ;
  MdlObject *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTMdlObject_p_t,0))){
    SWIG_fail_ptr("ObjectRefArray_back",1,SWIGTYPE_p_std__vectorTMdlObject_p_t);
  }
  
  result = (MdlObject *)((std::vector<MdlObject * > const *)arg1)->back();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MdlObject,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectRefArray___getitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<MdlObject * > *arg1 = (std::vector<MdlObject * > *) 0 ;
  unsigned int arg2 ;
  MdlObject *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTMdlObject_p_t,0))){
    SWIG_fail_ptr("ObjectRefArray___getitem",1,SWIGTYPE_p_std__vectorTMdlObject_p_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  try {
    result = (MdlObject *)std_vector_Sl_MdlObject_Sm__Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MdlObject,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectRefArray___setitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<MdlObject * > *arg1 = (std::vector<MdlObject * > *) 0 ;
  unsigned int arg2 ;
  MdlObject *arg3 = (MdlObject *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTMdlObject_p_t,0))){
    SWIG_fail_ptr("ObjectRefArray___setitem",1,SWIGTYPE_p_std__vectorTMdlObject_p_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_MdlObject,0))){
    SWIG_fail_ptr("ObjectRefArray___setitem",3,SWIGTYPE_p_MdlObject);
  }
  
  try {
    std_vector_Sl_MdlObject_Sm__Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ObjectRefArray___len(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<MdlObject * > *arg1 = (std::vector<MdlObject * > *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTMdlObject_p_t,0))){
    SWIG_fail_ptr("ObjectRefArray___len",1,SWIGTYPE_p_std__vectorTMdlObject_p_t);
  }
  
  result = (int)std_vector_Sl_MdlObject_Sm__Sg____len(arg1);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_ObjectRefArray(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<MdlObject * > *arg1 = (std::vector<MdlObject * > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTMdlObject_p_t,0))){
    SWIG_fail_ptr("delete_ObjectRefArray",1,SWIGTYPE_p_std__vectorTMdlObject_p_t);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ObjectRefArray(void *obj) {
std::vector<MdlObject * > *arg1 = (std::vector<MdlObject * > *) obj;
delete arg1;
}
static swig_lua_method swig_std_vector_Sl_MdlObject_Sm__Sg__methods[] = {
    {"size", _wrap_ObjectRefArray_size}, 
    {"max_size", _wrap_ObjectRefArray_max_size}, 
    {"empty", _wrap_ObjectRefArray_empty}, 
    {"clear", _wrap_ObjectRefArray_clear}, 
    {"push_back", _wrap_ObjectRefArray_push_back}, 
    {"pop_back", _wrap_ObjectRefArray_pop_back}, 
    {"front", _wrap_ObjectRefArray_front}, 
    {"back", _wrap_ObjectRefArray_back}, 
    {"__getitem", _wrap_ObjectRefArray___getitem}, 
    {"__setitem", _wrap_ObjectRefArray___setitem}, 
    {"__len", _wrap_ObjectRefArray___len}, 
    {0,0}
};
static swig_lua_attribute swig_std_vector_Sl_MdlObject_Sm__Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_vector_Sl_MdlObject_Sm__Sg__bases[] = {0};
swig_lua_class _wrap_class_std_vector_Sl_MdlObject_Sm__Sg_ = { "ObjectRefArray", &SWIGTYPE_p_std__vectorTMdlObject_p_t,_wrap_new_ObjectRefArray, swig_delete_ObjectRefArray, swig_std_vector_Sl_MdlObject_Sm__Sg__methods, swig_std_vector_Sl_MdlObject_Sm__Sg__attributes, swig_std_vector_Sl_MdlObject_Sm__Sg__bases };

static int _wrap_new_AnimationInfoRefArray__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimationInfo * > *result = 0 ;
  
  result = (std::vector<AnimationInfo * > *)new std::vector<AnimationInfo * >();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimationInfoRefArray__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  std::vector<AnimationInfo * > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector<AnimationInfo * > *)new std::vector<AnimationInfo * >(arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimationInfoRefArray__SWIG_2(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimationInfo * > *arg1 = 0 ;
  std::vector<AnimationInfo * > *result = 0 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,0))){
    SWIG_fail_ptr("new_AnimationInfoRefArray",1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t);
  }
  
  result = (std::vector<AnimationInfo * > *)new std::vector<AnimationInfo * >((std::vector<AnimationInfo * > const &)*arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimationInfoRefArray__SWIG_3(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  AnimationInfo *arg2 = (AnimationInfo *) 0 ;
  std::vector<AnimationInfo * > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("new_AnimationInfoRefArray",2,SWIGTYPE_p_AnimationInfo);
  }
  
  result = (std::vector<AnimationInfo * > *)new std::vector<AnimationInfo * >(arg1,arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimationInfoRefArray(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_AnimationInfoRefArray__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorTAnimationInfo_p_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_AnimationInfoRefArray__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_AnimationInfoRefArray__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_AnimationInfo, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_AnimationInfoRefArray__SWIG_3(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_AnimationInfoRefArray'");
  lua_error(L);return 0;
}


static int _wrap_AnimationInfoRefArray_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimationInfo * > *arg1 = (std::vector<AnimationInfo * > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,0))){
    SWIG_fail_ptr("AnimationInfoRefArray_size",1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t);
  }
  
  result = (unsigned int)((std::vector<AnimationInfo * > const *)arg1)->size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoRefArray_max_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimationInfo * > *arg1 = (std::vector<AnimationInfo * > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,0))){
    SWIG_fail_ptr("AnimationInfoRefArray_max_size",1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t);
  }
  
  result = (unsigned int)((std::vector<AnimationInfo * > const *)arg1)->max_size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoRefArray_empty(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimationInfo * > *arg1 = (std::vector<AnimationInfo * > *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,0))){
    SWIG_fail_ptr("AnimationInfoRefArray_empty",1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t);
  }
  
  result = (bool)((std::vector<AnimationInfo * > const *)arg1)->empty();
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoRefArray_clear(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimationInfo * > *arg1 = (std::vector<AnimationInfo * > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,0))){
    SWIG_fail_ptr("AnimationInfoRefArray_clear",1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t);
  }
  
  (arg1)->clear();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoRefArray_push_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimationInfo * > *arg1 = (std::vector<AnimationInfo * > *) 0 ;
  AnimationInfo *arg2 = (AnimationInfo *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,0))){
    SWIG_fail_ptr("AnimationInfoRefArray_push_back",1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("AnimationInfoRefArray_push_back",2,SWIGTYPE_p_AnimationInfo);
  }
  
  (arg1)->push_back(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoRefArray_pop_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimationInfo * > *arg1 = (std::vector<AnimationInfo * > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,0))){
    SWIG_fail_ptr("AnimationInfoRefArray_pop_back",1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t);
  }
  
  (arg1)->pop_back();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoRefArray_front(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimationInfo * > *arg1 = (std::vector<AnimationInfo * > *) 0 ;
  AnimationInfo *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,0))){
    SWIG_fail_ptr("AnimationInfoRefArray_front",1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t);
  }
  
  result = (AnimationInfo *)((std::vector<AnimationInfo * > const *)arg1)->front();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_AnimationInfo,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoRefArray_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimationInfo * > *arg1 = (std::vector<AnimationInfo * > *) 0 ;
  AnimationInfo *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,0))){
    SWIG_fail_ptr("AnimationInfoRefArray_back",1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t);
  }
  
  result = (AnimationInfo *)((std::vector<AnimationInfo * > const *)arg1)->back();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_AnimationInfo,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoRefArray___getitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimationInfo * > *arg1 = (std::vector<AnimationInfo * > *) 0 ;
  unsigned int arg2 ;
  AnimationInfo *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,0))){
    SWIG_fail_ptr("AnimationInfoRefArray___getitem",1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  try {
    result = (AnimationInfo *)std_vector_Sl_AnimationInfo_Sm__Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_AnimationInfo,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoRefArray___setitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimationInfo * > *arg1 = (std::vector<AnimationInfo * > *) 0 ;
  unsigned int arg2 ;
  AnimationInfo *arg3 = (AnimationInfo *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,0))){
    SWIG_fail_ptr("AnimationInfoRefArray___setitem",1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("AnimationInfoRefArray___setitem",3,SWIGTYPE_p_AnimationInfo);
  }
  
  try {
    std_vector_Sl_AnimationInfo_Sm__Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoRefArray___len(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimationInfo * > *arg1 = (std::vector<AnimationInfo * > *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,0))){
    SWIG_fail_ptr("AnimationInfoRefArray___len",1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t);
  }
  
  result = (int)std_vector_Sl_AnimationInfo_Sm__Sg____len(arg1);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_AnimationInfoRefArray(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimationInfo * > *arg1 = (std::vector<AnimationInfo * > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t,0))){
    SWIG_fail_ptr("delete_AnimationInfoRefArray",1,SWIGTYPE_p_std__vectorTAnimationInfo_p_t);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_AnimationInfoRefArray(void *obj) {
std::vector<AnimationInfo * > *arg1 = (std::vector<AnimationInfo * > *) obj;
delete arg1;
}
static swig_lua_method swig_std_vector_Sl_AnimationInfo_Sm__Sg__methods[] = {
    {"size", _wrap_AnimationInfoRefArray_size}, 
    {"max_size", _wrap_AnimationInfoRefArray_max_size}, 
    {"empty", _wrap_AnimationInfoRefArray_empty}, 
    {"clear", _wrap_AnimationInfoRefArray_clear}, 
    {"push_back", _wrap_AnimationInfoRefArray_push_back}, 
    {"pop_back", _wrap_AnimationInfoRefArray_pop_back}, 
    {"front", _wrap_AnimationInfoRefArray_front}, 
    {"back", _wrap_AnimationInfoRefArray_back}, 
    {"__getitem", _wrap_AnimationInfoRefArray___getitem}, 
    {"__setitem", _wrap_AnimationInfoRefArray___setitem}, 
    {"__len", _wrap_AnimationInfoRefArray___len}, 
    {0,0}
};
static swig_lua_attribute swig_std_vector_Sl_AnimationInfo_Sm__Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_vector_Sl_AnimationInfo_Sm__Sg__bases[] = {0};
swig_lua_class _wrap_class_std_vector_Sl_AnimationInfo_Sm__Sg_ = { "AnimationInfoRefArray", &SWIGTYPE_p_std__vectorTAnimationInfo_p_t,_wrap_new_AnimationInfoRefArray, swig_delete_AnimationInfoRefArray, swig_std_vector_Sl_AnimationInfo_Sm__Sg__methods, swig_std_vector_Sl_AnimationInfo_Sm__Sg__attributes, swig_std_vector_Sl_AnimationInfo_Sm__Sg__bases };

static int _wrap_new_AnimationInfoList__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *result = 0 ;
  
  result = (std::list<AnimationInfo > *)new std::list<AnimationInfo >();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__listTAnimationInfo_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimationInfoList__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *arg1 = 0 ;
  std::list<AnimationInfo > *result = 0 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimationInfo_t,0))){
    SWIG_fail_ptr("new_AnimationInfoList",1,SWIGTYPE_p_std__listTAnimationInfo_t);
  }
  
  result = (std::list<AnimationInfo > *)new std::list<AnimationInfo >((std::list<AnimationInfo > const &)*arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__listTAnimationInfo_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimationInfoList__SWIG_2(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  SwigValueWrapper<AnimationInfo > arg2 ;
  std::list<AnimationInfo > *result = 0 ;
  AnimationInfo *argp2 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("new_AnimationInfoList",2,SWIGTYPE_AnimationInfo);
  }
  arg2 = *argp2;
  
  result = (std::list<AnimationInfo > *)new std::list<AnimationInfo >(arg1,arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__listTAnimationInfo_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimationInfoList(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_AnimationInfoList__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__listTAnimationInfo_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_AnimationInfoList__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_AnimationInfo, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_AnimationInfoList__SWIG_2(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_AnimationInfoList'");
  lua_error(L);return 0;
}


static int _wrap_AnimationInfoList_size(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *arg1 = (std::list<AnimationInfo > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimationInfoList_size",1,SWIGTYPE_p_std__listTAnimationInfo_t);
  }
  
  result = (unsigned int)((std::list<AnimationInfo > const *)arg1)->size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoList_empty(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *arg1 = (std::list<AnimationInfo > *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimationInfoList_empty",1,SWIGTYPE_p_std__listTAnimationInfo_t);
  }
  
  result = (bool)((std::list<AnimationInfo > const *)arg1)->empty();
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoList_clear(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *arg1 = (std::list<AnimationInfo > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimationInfoList_clear",1,SWIGTYPE_p_std__listTAnimationInfo_t);
  }
  
  (arg1)->clear();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoList_push_back(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *arg1 = (std::list<AnimationInfo > *) 0 ;
  SwigValueWrapper<AnimationInfo > arg2 ;
  AnimationInfo *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimationInfoList_push_back",1,SWIGTYPE_p_std__listTAnimationInfo_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("AnimationInfoList_push_back",2,SWIGTYPE_AnimationInfo);
  }
  arg2 = *argp2;
  
  (arg1)->push_back(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoList_pop_back(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *arg1 = (std::list<AnimationInfo > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimationInfoList_pop_back",1,SWIGTYPE_p_std__listTAnimationInfo_t);
  }
  
  (arg1)->pop_back();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoList_push_front(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *arg1 = (std::list<AnimationInfo > *) 0 ;
  SwigValueWrapper<AnimationInfo > arg2 ;
  AnimationInfo *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimationInfoList_push_front",1,SWIGTYPE_p_std__listTAnimationInfo_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_AnimationInfo,0))){
    SWIG_fail_ptr("AnimationInfoList_push_front",2,SWIGTYPE_AnimationInfo);
  }
  arg2 = *argp2;
  
  (arg1)->push_front(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoList_pop_front(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *arg1 = (std::list<AnimationInfo > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimationInfoList_pop_front",1,SWIGTYPE_p_std__listTAnimationInfo_t);
  }
  
  (arg1)->pop_front();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoList_front(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *arg1 = (std::list<AnimationInfo > *) 0 ;
  SwigValueWrapper<AnimationInfo > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimationInfoList_front",1,SWIGTYPE_p_std__listTAnimationInfo_t);
  }
  
  result = ((std::list<AnimationInfo > const *)arg1)->front();
  SWIG_arg=0;
  {
    AnimationInfo * resultptr = new AnimationInfo((AnimationInfo &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_AnimationInfo,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoList_back(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *arg1 = (std::list<AnimationInfo > *) 0 ;
  SwigValueWrapper<AnimationInfo > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimationInfoList_back",1,SWIGTYPE_p_std__listTAnimationInfo_t);
  }
  
  result = ((std::list<AnimationInfo > const *)arg1)->back();
  SWIG_arg=0;
  {
    AnimationInfo * resultptr = new AnimationInfo((AnimationInfo &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_AnimationInfo,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoList_begin_it(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *arg1 = (std::list<AnimationInfo > *) 0 ;
  std::list_iterator<AnimationInfo > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimationInfoList_begin_it",1,SWIGTYPE_p_std__listTAnimationInfo_t);
  }
  
  result = (arg1)->begin();
  SWIG_arg=0;
  {
    std::list_iterator<AnimationInfo > * resultptr = new std::list_iterator<AnimationInfo >((std::list_iterator<AnimationInfo > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__list_iteratorTAnimationInfo_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoList_end_it(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *arg1 = (std::list<AnimationInfo > *) 0 ;
  std::list_iterator<AnimationInfo > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimationInfoList_end_it",1,SWIGTYPE_p_std__listTAnimationInfo_t);
  }
  
  result = (arg1)->end();
  SWIG_arg=0;
  {
    std::list_iterator<AnimationInfo > * resultptr = new std::list_iterator<AnimationInfo >((std::list_iterator<AnimationInfo > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__list_iteratorTAnimationInfo_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoList_rbegin_it(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *arg1 = (std::list<AnimationInfo > *) 0 ;
  std::list_reverse_iterator<AnimationInfo > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimationInfoList_rbegin_it",1,SWIGTYPE_p_std__listTAnimationInfo_t);
  }
  
  result = (arg1)->rbegin();
  SWIG_arg=0;
  {
    std::list_reverse_iterator<AnimationInfo > * resultptr = new std::list_reverse_iterator<AnimationInfo >((std::list_reverse_iterator<AnimationInfo > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoList_rend_it(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *arg1 = (std::list<AnimationInfo > *) 0 ;
  std::list_reverse_iterator<AnimationInfo > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimationInfoList_rend_it",1,SWIGTYPE_p_std__listTAnimationInfo_t);
  }
  
  result = (arg1)->rend();
  SWIG_arg=0;
  {
    std::list_reverse_iterator<AnimationInfo > * resultptr = new std::list_reverse_iterator<AnimationInfo >((std::list_reverse_iterator<AnimationInfo > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimationInfoList___len(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *arg1 = (std::list<AnimationInfo > *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimationInfoList___len",1,SWIGTYPE_p_std__listTAnimationInfo_t);
  }
  
  result = (int)std_list_Sl_AnimationInfo_Sg____len(arg1);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_AnimationInfoList(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimationInfo > *arg1 = (std::list<AnimationInfo > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimationInfo_t,0))){
    SWIG_fail_ptr("delete_AnimationInfoList",1,SWIGTYPE_p_std__listTAnimationInfo_t);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_AnimationInfoList(void *obj) {
std::list<AnimationInfo > *arg1 = (std::list<AnimationInfo > *) obj;
delete arg1;
}
static swig_lua_method swig_std_list_Sl_AnimationInfo_Sg__methods[] = {
    {"size", _wrap_AnimationInfoList_size}, 
    {"empty", _wrap_AnimationInfoList_empty}, 
    {"clear", _wrap_AnimationInfoList_clear}, 
    {"push_back", _wrap_AnimationInfoList_push_back}, 
    {"pop_back", _wrap_AnimationInfoList_pop_back}, 
    {"push_front", _wrap_AnimationInfoList_push_front}, 
    {"pop_front", _wrap_AnimationInfoList_pop_front}, 
    {"front", _wrap_AnimationInfoList_front}, 
    {"back", _wrap_AnimationInfoList_back}, 
    {"begin_it", _wrap_AnimationInfoList_begin_it}, 
    {"end_it", _wrap_AnimationInfoList_end_it}, 
    {"rbegin_it", _wrap_AnimationInfoList_rbegin_it}, 
    {"rend_it", _wrap_AnimationInfoList_rend_it}, 
    {"__len", _wrap_AnimationInfoList___len}, 
    {0,0}
};
static swig_lua_attribute swig_std_list_Sl_AnimationInfo_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_list_Sl_AnimationInfo_Sg__bases[] = {0};
swig_lua_class _wrap_class_std_list_Sl_AnimationInfo_Sg_ = { "AnimationInfoList", &SWIGTYPE_p_std__listTAnimationInfo_t,_wrap_new_AnimationInfoList, swig_delete_AnimationInfoList, swig_std_list_Sl_AnimationInfo_Sg__methods, swig_std_list_Sl_AnimationInfo_Sg__attributes, swig_std_list_Sl_AnimationInfo_Sg__bases };

static int _wrap_AnimInfoListIt_value(lua_State* L) {
  int SWIG_arg = -1;
  std::list_iterator<AnimationInfo > *arg1 = (std::list_iterator<AnimationInfo > *) 0 ;
  SwigValueWrapper<AnimationInfo > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_iteratorTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimInfoListIt_value",1,SWIGTYPE_p_std__list_iteratorTAnimationInfo_t);
  }
  
  result = std_list_iterator_Sl_AnimationInfo_Sg__value(arg1);
  SWIG_arg=0;
  {
    AnimationInfo * resultptr = new AnimationInfo((AnimationInfo &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_AnimationInfo,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimInfoListIt_next(lua_State* L) {
  int SWIG_arg = -1;
  std::list_iterator<AnimationInfo > *arg1 = (std::list_iterator<AnimationInfo > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_iteratorTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimInfoListIt_next",1,SWIGTYPE_p_std__list_iteratorTAnimationInfo_t);
  }
  
  std_list_iterator_Sl_AnimationInfo_Sg__next(arg1);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimInfoListIt_prev(lua_State* L) {
  int SWIG_arg = -1;
  std::list_iterator<AnimationInfo > *arg1 = (std::list_iterator<AnimationInfo > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_iteratorTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimInfoListIt_prev",1,SWIGTYPE_p_std__list_iteratorTAnimationInfo_t);
  }
  
  std_list_iterator_Sl_AnimationInfo_Sg__prev(arg1);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimInfoListIt___eq(lua_State* L) {
  int SWIG_arg = -1;
  std::list_iterator<AnimationInfo > *arg1 = (std::list_iterator<AnimationInfo > *) 0 ;
  std::list_iterator<AnimationInfo > *arg2 = 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_iteratorTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimInfoListIt___eq",1,SWIGTYPE_p_std__list_iteratorTAnimationInfo_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__list_iteratorTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimInfoListIt___eq",2,SWIGTYPE_p_std__list_iteratorTAnimationInfo_t);
  }
  
  result = (bool)std_list_iterator_Sl_AnimationInfo_Sg__operator_Se__Se_(arg1,(std::list_iterator<AnimationInfo > const &)*arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimInfoListIt(lua_State* L) {
  int SWIG_arg = -1;
  std::list_iterator<AnimationInfo > *result = 0 ;
  
  result = (std::list_iterator<AnimationInfo > *)new std::list_iterator<AnimationInfo >();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__list_iteratorTAnimationInfo_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_AnimInfoListIt(lua_State* L) {
  int SWIG_arg = -1;
  std::list_iterator<AnimationInfo > *arg1 = (std::list_iterator<AnimationInfo > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_iteratorTAnimationInfo_t,0))){
    SWIG_fail_ptr("delete_AnimInfoListIt",1,SWIGTYPE_p_std__list_iteratorTAnimationInfo_t);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_AnimInfoListIt(void *obj) {
std::list_iterator<AnimationInfo > *arg1 = (std::list_iterator<AnimationInfo > *) obj;
delete arg1;
}
static swig_lua_method swig_std_list_iterator_Sl_AnimationInfo_Sg__methods[] = {
    {"value", _wrap_AnimInfoListIt_value}, 
    {"next", _wrap_AnimInfoListIt_next}, 
    {"prev", _wrap_AnimInfoListIt_prev}, 
    {"__eq", _wrap_AnimInfoListIt___eq}, 
    {0,0}
};
static swig_lua_attribute swig_std_list_iterator_Sl_AnimationInfo_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_list_iterator_Sl_AnimationInfo_Sg__bases[] = {0};
swig_lua_class _wrap_class_std_list_iterator_Sl_AnimationInfo_Sg_ = { "AnimInfoListIt", &SWIGTYPE_p_std__list_iteratorTAnimationInfo_t,_wrap_new_AnimInfoListIt, swig_delete_AnimInfoListIt, swig_std_list_iterator_Sl_AnimationInfo_Sg__methods, swig_std_list_iterator_Sl_AnimationInfo_Sg__attributes, swig_std_list_iterator_Sl_AnimationInfo_Sg__bases };

static int _wrap_AnimInfoListRevIt_value(lua_State* L) {
  int SWIG_arg = -1;
  std::list_reverse_iterator<AnimationInfo > *arg1 = (std::list_reverse_iterator<AnimationInfo > *) 0 ;
  SwigValueWrapper<AnimationInfo > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimInfoListRevIt_value",1,SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t);
  }
  
  result = std_list_reverse_iterator_Sl_AnimationInfo_Sg__value(arg1);
  SWIG_arg=0;
  {
    AnimationInfo * resultptr = new AnimationInfo((AnimationInfo &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_AnimationInfo,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimInfoListRevIt_next(lua_State* L) {
  int SWIG_arg = -1;
  std::list_reverse_iterator<AnimationInfo > *arg1 = (std::list_reverse_iterator<AnimationInfo > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimInfoListRevIt_next",1,SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t);
  }
  
  std_list_reverse_iterator_Sl_AnimationInfo_Sg__next(arg1);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimInfoListRevIt_prev(lua_State* L) {
  int SWIG_arg = -1;
  std::list_reverse_iterator<AnimationInfo > *arg1 = (std::list_reverse_iterator<AnimationInfo > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimInfoListRevIt_prev",1,SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t);
  }
  
  std_list_reverse_iterator_Sl_AnimationInfo_Sg__prev(arg1);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimInfoListRevIt___eq(lua_State* L) {
  int SWIG_arg = -1;
  std::list_reverse_iterator<AnimationInfo > *arg1 = (std::list_reverse_iterator<AnimationInfo > *) 0 ;
  std::list_reverse_iterator<AnimationInfo > *arg2 = 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimInfoListRevIt___eq",1,SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t,0))){
    SWIG_fail_ptr("AnimInfoListRevIt___eq",2,SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t);
  }
  
  result = (bool)std_list_reverse_iterator_Sl_AnimationInfo_Sg__operator_Se__Se_(arg1,(std::list_reverse_iterator<AnimationInfo > const &)*arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimInfoListRevIt(lua_State* L) {
  int SWIG_arg = -1;
  std::list_reverse_iterator<AnimationInfo > *result = 0 ;
  
  result = (std::list_reverse_iterator<AnimationInfo > *)new std::list_reverse_iterator<AnimationInfo >();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_AnimInfoListRevIt(lua_State* L) {
  int SWIG_arg = -1;
  std::list_reverse_iterator<AnimationInfo > *arg1 = (std::list_reverse_iterator<AnimationInfo > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t,0))){
    SWIG_fail_ptr("delete_AnimInfoListRevIt",1,SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_AnimInfoListRevIt(void *obj) {
std::list_reverse_iterator<AnimationInfo > *arg1 = (std::list_reverse_iterator<AnimationInfo > *) obj;
delete arg1;
}
static swig_lua_method swig_std_list_reverse_iterator_Sl_AnimationInfo_Sg__methods[] = {
    {"value", _wrap_AnimInfoListRevIt_value}, 
    {"next", _wrap_AnimInfoListRevIt_next}, 
    {"prev", _wrap_AnimInfoListRevIt_prev}, 
    {"__eq", _wrap_AnimInfoListRevIt___eq}, 
    {0,0}
};
static swig_lua_attribute swig_std_list_reverse_iterator_Sl_AnimationInfo_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_list_reverse_iterator_Sl_AnimationInfo_Sg__bases[] = {0};
swig_lua_class _wrap_class_std_list_reverse_iterator_Sl_AnimationInfo_Sg_ = { "AnimInfoListRevIt", &SWIGTYPE_p_std__list_reverse_iteratorTAnimationInfo_t,_wrap_new_AnimInfoListRevIt, swig_delete_AnimInfoListRevIt, swig_std_list_reverse_iterator_Sl_AnimationInfo_Sg__methods, swig_std_list_reverse_iterator_Sl_AnimationInfo_Sg__attributes, swig_std_list_reverse_iterator_Sl_AnimationInfo_Sg__bases };

static int _wrap_new_AnimPropertyList__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *result = 0 ;
  
  result = (std::list<AnimProperty > *)new std::list<AnimProperty >();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__listTAnimProperty_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimPropertyList__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *arg1 = 0 ;
  std::list<AnimProperty > *result = 0 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimProperty_t,0))){
    SWIG_fail_ptr("new_AnimPropertyList",1,SWIGTYPE_p_std__listTAnimProperty_t);
  }
  
  result = (std::list<AnimProperty > *)new std::list<AnimProperty >((std::list<AnimProperty > const &)*arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__listTAnimProperty_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimPropertyList__SWIG_2(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  AnimProperty arg2 ;
  std::list<AnimProperty > *result = 0 ;
  AnimProperty *argp2 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("new_AnimPropertyList",2,SWIGTYPE_AnimProperty);
  }
  arg2 = *argp2;
  
  result = (std::list<AnimProperty > *)new std::list<AnimProperty >(arg1,arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__listTAnimProperty_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimPropertyList(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_AnimPropertyList__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__listTAnimProperty_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_AnimPropertyList__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (lua_isuserdata(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_AnimProperty, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_AnimPropertyList__SWIG_2(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_AnimPropertyList'");
  lua_error(L);return 0;
}


static int _wrap_AnimPropertyList_size(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *arg1 = (std::list<AnimProperty > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropertyList_size",1,SWIGTYPE_p_std__listTAnimProperty_t);
  }
  
  result = (unsigned int)((std::list<AnimProperty > const *)arg1)->size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyList_empty(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *arg1 = (std::list<AnimProperty > *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropertyList_empty",1,SWIGTYPE_p_std__listTAnimProperty_t);
  }
  
  result = (bool)((std::list<AnimProperty > const *)arg1)->empty();
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyList_clear(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *arg1 = (std::list<AnimProperty > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropertyList_clear",1,SWIGTYPE_p_std__listTAnimProperty_t);
  }
  
  (arg1)->clear();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyList_push_back(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *arg1 = (std::list<AnimProperty > *) 0 ;
  AnimProperty arg2 ;
  AnimProperty *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropertyList_push_back",1,SWIGTYPE_p_std__listTAnimProperty_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimPropertyList_push_back",2,SWIGTYPE_AnimProperty);
  }
  arg2 = *argp2;
  
  (arg1)->push_back(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyList_pop_back(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *arg1 = (std::list<AnimProperty > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropertyList_pop_back",1,SWIGTYPE_p_std__listTAnimProperty_t);
  }
  
  (arg1)->pop_back();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyList_push_front(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *arg1 = (std::list<AnimProperty > *) 0 ;
  AnimProperty arg2 ;
  AnimProperty *argp2 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropertyList_push_front",1,SWIGTYPE_p_std__listTAnimProperty_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&argp2,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimPropertyList_push_front",2,SWIGTYPE_AnimProperty);
  }
  arg2 = *argp2;
  
  (arg1)->push_front(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyList_pop_front(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *arg1 = (std::list<AnimProperty > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropertyList_pop_front",1,SWIGTYPE_p_std__listTAnimProperty_t);
  }
  
  (arg1)->pop_front();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyList_front(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *arg1 = (std::list<AnimProperty > *) 0 ;
  AnimProperty result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropertyList_front",1,SWIGTYPE_p_std__listTAnimProperty_t);
  }
  
  result = ((std::list<AnimProperty > const *)arg1)->front();
  SWIG_arg=0;
  {
    AnimProperty * resultptr = new AnimProperty((AnimProperty &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_AnimProperty,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyList_back(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *arg1 = (std::list<AnimProperty > *) 0 ;
  AnimProperty result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropertyList_back",1,SWIGTYPE_p_std__listTAnimProperty_t);
  }
  
  result = ((std::list<AnimProperty > const *)arg1)->back();
  SWIG_arg=0;
  {
    AnimProperty * resultptr = new AnimProperty((AnimProperty &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_AnimProperty,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyList_begin_it(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *arg1 = (std::list<AnimProperty > *) 0 ;
  std::list_iterator<AnimProperty > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropertyList_begin_it",1,SWIGTYPE_p_std__listTAnimProperty_t);
  }
  
  result = (arg1)->begin();
  SWIG_arg=0;
  {
    std::list_iterator<AnimProperty > * resultptr = new std::list_iterator<AnimProperty >((std::list_iterator<AnimProperty > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__list_iteratorTAnimProperty_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyList_end_it(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *arg1 = (std::list<AnimProperty > *) 0 ;
  std::list_iterator<AnimProperty > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropertyList_end_it",1,SWIGTYPE_p_std__listTAnimProperty_t);
  }
  
  result = (arg1)->end();
  SWIG_arg=0;
  {
    std::list_iterator<AnimProperty > * resultptr = new std::list_iterator<AnimProperty >((std::list_iterator<AnimProperty > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__list_iteratorTAnimProperty_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyList_rbegin_it(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *arg1 = (std::list<AnimProperty > *) 0 ;
  std::list_reverse_iterator<AnimProperty > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropertyList_rbegin_it",1,SWIGTYPE_p_std__listTAnimProperty_t);
  }
  
  result = (arg1)->rbegin();
  SWIG_arg=0;
  {
    std::list_reverse_iterator<AnimProperty > * resultptr = new std::list_reverse_iterator<AnimProperty >((std::list_reverse_iterator<AnimProperty > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyList_rend_it(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *arg1 = (std::list<AnimProperty > *) 0 ;
  std::list_reverse_iterator<AnimProperty > result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropertyList_rend_it",1,SWIGTYPE_p_std__listTAnimProperty_t);
  }
  
  result = (arg1)->rend();
  SWIG_arg=0;
  {
    std::list_reverse_iterator<AnimProperty > * resultptr = new std::list_reverse_iterator<AnimProperty >((std::list_reverse_iterator<AnimProperty > &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyList___len(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *arg1 = (std::list<AnimProperty > *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropertyList___len",1,SWIGTYPE_p_std__listTAnimProperty_t);
  }
  
  result = (int)std_list_Sl_AnimProperty_Sg____len(arg1);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_AnimPropertyList(lua_State* L) {
  int SWIG_arg = -1;
  std::list<AnimProperty > *arg1 = (std::list<AnimProperty > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__listTAnimProperty_t,0))){
    SWIG_fail_ptr("delete_AnimPropertyList",1,SWIGTYPE_p_std__listTAnimProperty_t);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_AnimPropertyList(void *obj) {
std::list<AnimProperty > *arg1 = (std::list<AnimProperty > *) obj;
delete arg1;
}
static swig_lua_method swig_std_list_Sl_AnimProperty_Sg__methods[] = {
    {"size", _wrap_AnimPropertyList_size}, 
    {"empty", _wrap_AnimPropertyList_empty}, 
    {"clear", _wrap_AnimPropertyList_clear}, 
    {"push_back", _wrap_AnimPropertyList_push_back}, 
    {"pop_back", _wrap_AnimPropertyList_pop_back}, 
    {"push_front", _wrap_AnimPropertyList_push_front}, 
    {"pop_front", _wrap_AnimPropertyList_pop_front}, 
    {"front", _wrap_AnimPropertyList_front}, 
    {"back", _wrap_AnimPropertyList_back}, 
    {"begin_it", _wrap_AnimPropertyList_begin_it}, 
    {"end_it", _wrap_AnimPropertyList_end_it}, 
    {"rbegin_it", _wrap_AnimPropertyList_rbegin_it}, 
    {"rend_it", _wrap_AnimPropertyList_rend_it}, 
    {"__len", _wrap_AnimPropertyList___len}, 
    {0,0}
};
static swig_lua_attribute swig_std_list_Sl_AnimProperty_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_list_Sl_AnimProperty_Sg__bases[] = {0};
swig_lua_class _wrap_class_std_list_Sl_AnimProperty_Sg_ = { "AnimPropertyList", &SWIGTYPE_p_std__listTAnimProperty_t,_wrap_new_AnimPropertyList, swig_delete_AnimPropertyList, swig_std_list_Sl_AnimProperty_Sg__methods, swig_std_list_Sl_AnimProperty_Sg__attributes, swig_std_list_Sl_AnimProperty_Sg__bases };

static int _wrap_AnimPropListIt_value(lua_State* L) {
  int SWIG_arg = -1;
  std::list_iterator<AnimProperty > *arg1 = (std::list_iterator<AnimProperty > *) 0 ;
  AnimProperty result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_iteratorTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropListIt_value",1,SWIGTYPE_p_std__list_iteratorTAnimProperty_t);
  }
  
  result = std_list_iterator_Sl_AnimProperty_Sg__value(arg1);
  SWIG_arg=0;
  {
    AnimProperty * resultptr = new AnimProperty((AnimProperty &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_AnimProperty,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropListIt_next(lua_State* L) {
  int SWIG_arg = -1;
  std::list_iterator<AnimProperty > *arg1 = (std::list_iterator<AnimProperty > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_iteratorTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropListIt_next",1,SWIGTYPE_p_std__list_iteratorTAnimProperty_t);
  }
  
  std_list_iterator_Sl_AnimProperty_Sg__next(arg1);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropListIt_prev(lua_State* L) {
  int SWIG_arg = -1;
  std::list_iterator<AnimProperty > *arg1 = (std::list_iterator<AnimProperty > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_iteratorTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropListIt_prev",1,SWIGTYPE_p_std__list_iteratorTAnimProperty_t);
  }
  
  std_list_iterator_Sl_AnimProperty_Sg__prev(arg1);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropListIt___eq(lua_State* L) {
  int SWIG_arg = -1;
  std::list_iterator<AnimProperty > *arg1 = (std::list_iterator<AnimProperty > *) 0 ;
  std::list_iterator<AnimProperty > *arg2 = 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_iteratorTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropListIt___eq",1,SWIGTYPE_p_std__list_iteratorTAnimProperty_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__list_iteratorTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropListIt___eq",2,SWIGTYPE_p_std__list_iteratorTAnimProperty_t);
  }
  
  result = (bool)std_list_iterator_Sl_AnimProperty_Sg__operator_Se__Se_(arg1,(std::list_iterator<AnimProperty > const &)*arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimPropListIt(lua_State* L) {
  int SWIG_arg = -1;
  std::list_iterator<AnimProperty > *result = 0 ;
  
  result = (std::list_iterator<AnimProperty > *)new std::list_iterator<AnimProperty >();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__list_iteratorTAnimProperty_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_AnimPropListIt(lua_State* L) {
  int SWIG_arg = -1;
  std::list_iterator<AnimProperty > *arg1 = (std::list_iterator<AnimProperty > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_iteratorTAnimProperty_t,0))){
    SWIG_fail_ptr("delete_AnimPropListIt",1,SWIGTYPE_p_std__list_iteratorTAnimProperty_t);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_AnimPropListIt(void *obj) {
std::list_iterator<AnimProperty > *arg1 = (std::list_iterator<AnimProperty > *) obj;
delete arg1;
}
static swig_lua_method swig_std_list_iterator_Sl_AnimProperty_Sg__methods[] = {
    {"value", _wrap_AnimPropListIt_value}, 
    {"next", _wrap_AnimPropListIt_next}, 
    {"prev", _wrap_AnimPropListIt_prev}, 
    {"__eq", _wrap_AnimPropListIt___eq}, 
    {0,0}
};
static swig_lua_attribute swig_std_list_iterator_Sl_AnimProperty_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_list_iterator_Sl_AnimProperty_Sg__bases[] = {0};
swig_lua_class _wrap_class_std_list_iterator_Sl_AnimProperty_Sg_ = { "AnimPropListIt", &SWIGTYPE_p_std__list_iteratorTAnimProperty_t,_wrap_new_AnimPropListIt, swig_delete_AnimPropListIt, swig_std_list_iterator_Sl_AnimProperty_Sg__methods, swig_std_list_iterator_Sl_AnimProperty_Sg__attributes, swig_std_list_iterator_Sl_AnimProperty_Sg__bases };

static int _wrap_AnimPropListRevIt_value(lua_State* L) {
  int SWIG_arg = -1;
  std::list_reverse_iterator<AnimProperty > *arg1 = (std::list_reverse_iterator<AnimProperty > *) 0 ;
  AnimProperty result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropListRevIt_value",1,SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t);
  }
  
  result = std_list_reverse_iterator_Sl_AnimProperty_Sg__value(arg1);
  SWIG_arg=0;
  {
    AnimProperty * resultptr = new AnimProperty((AnimProperty &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_AnimProperty,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropListRevIt_next(lua_State* L) {
  int SWIG_arg = -1;
  std::list_reverse_iterator<AnimProperty > *arg1 = (std::list_reverse_iterator<AnimProperty > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropListRevIt_next",1,SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t);
  }
  
  std_list_reverse_iterator_Sl_AnimProperty_Sg__next(arg1);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropListRevIt_prev(lua_State* L) {
  int SWIG_arg = -1;
  std::list_reverse_iterator<AnimProperty > *arg1 = (std::list_reverse_iterator<AnimProperty > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropListRevIt_prev",1,SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t);
  }
  
  std_list_reverse_iterator_Sl_AnimProperty_Sg__prev(arg1);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropListRevIt___eq(lua_State* L) {
  int SWIG_arg = -1;
  std::list_reverse_iterator<AnimProperty > *arg1 = (std::list_reverse_iterator<AnimProperty > *) 0 ;
  std::list_reverse_iterator<AnimProperty > *arg2 = 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isuserdata(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropListRevIt___eq",1,SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t,0))){
    SWIG_fail_ptr("AnimPropListRevIt___eq",2,SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t);
  }
  
  result = (bool)std_list_reverse_iterator_Sl_AnimProperty_Sg__operator_Se__Se_(arg1,(std::list_reverse_iterator<AnimProperty > const &)*arg2);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimPropListRevIt(lua_State* L) {
  int SWIG_arg = -1;
  std::list_reverse_iterator<AnimProperty > *result = 0 ;
  
  result = (std::list_reverse_iterator<AnimProperty > *)new std::list_reverse_iterator<AnimProperty >();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_AnimPropListRevIt(lua_State* L) {
  int SWIG_arg = -1;
  std::list_reverse_iterator<AnimProperty > *arg1 = (std::list_reverse_iterator<AnimProperty > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t,0))){
    SWIG_fail_ptr("delete_AnimPropListRevIt",1,SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_AnimPropListRevIt(void *obj) {
std::list_reverse_iterator<AnimProperty > *arg1 = (std::list_reverse_iterator<AnimProperty > *) obj;
delete arg1;
}
static swig_lua_method swig_std_list_reverse_iterator_Sl_AnimProperty_Sg__methods[] = {
    {"value", _wrap_AnimPropListRevIt_value}, 
    {"next", _wrap_AnimPropListRevIt_next}, 
    {"prev", _wrap_AnimPropListRevIt_prev}, 
    {"__eq", _wrap_AnimPropListRevIt___eq}, 
    {0,0}
};
static swig_lua_attribute swig_std_list_reverse_iterator_Sl_AnimProperty_Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_list_reverse_iterator_Sl_AnimProperty_Sg__bases[] = {0};
swig_lua_class _wrap_class_std_list_reverse_iterator_Sl_AnimProperty_Sg_ = { "AnimPropListRevIt", &SWIGTYPE_p_std__list_reverse_iteratorTAnimProperty_t,_wrap_new_AnimPropListRevIt, swig_delete_AnimPropListRevIt, swig_std_list_reverse_iterator_Sl_AnimProperty_Sg__methods, swig_std_list_reverse_iterator_Sl_AnimProperty_Sg__attributes, swig_std_list_reverse_iterator_Sl_AnimProperty_Sg__bases };

static int _wrap_new_AnimPropertyRefArray__SWIG_0(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimProperty * > *result = 0 ;
  
  result = (std::vector<AnimProperty * > *)new std::vector<AnimProperty * >();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTAnimProperty_p_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimPropertyRefArray__SWIG_1(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  std::vector<AnimProperty * > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  result = (std::vector<AnimProperty * > *)new std::vector<AnimProperty * >(arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTAnimProperty_p_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimPropertyRefArray__SWIG_2(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimProperty * > *arg1 = 0 ;
  std::vector<AnimProperty * > *result = 0 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimProperty_p_t,0))){
    SWIG_fail_ptr("new_AnimPropertyRefArray",1,SWIGTYPE_p_std__vectorTAnimProperty_p_t);
  }
  
  result = (std::vector<AnimProperty * > *)new std::vector<AnimProperty * >((std::vector<AnimProperty * > const &)*arg1);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTAnimProperty_p_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimPropertyRefArray__SWIG_3(lua_State* L) {
  int SWIG_arg = -1;
  unsigned int arg1 ;
  AnimProperty *arg2 = (AnimProperty *) 0 ;
  std::vector<AnimProperty * > *result = 0 ;
  
  if(!lua_isnumber(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  arg1 = (unsigned int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("new_AnimPropertyRefArray",2,SWIGTYPE_p_AnimProperty);
  }
  
  result = (std::vector<AnimProperty * > *)new std::vector<AnimProperty * >(arg1,arg2);
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std__vectorTAnimProperty_p_t,1); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnimPropertyRefArray(lua_State* L) {
  int argc;
  int argv[3]={
    1,2,3
  };
  
  argc = lua_gettop(L);
  if (argc == 0) {
    return _wrap_new_AnimPropertyRefArray__SWIG_0(L);
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if (lua_isuserdata(L,argv[0])==0 || SWIG_ConvertPtr(L,argv[0], (void **) &ptr, SWIGTYPE_p_std__vectorTAnimProperty_p_t, 0)) {
        _v = 0;
      } else {
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_AnimPropertyRefArray__SWIG_2(L);
    }
  }
  if (argc == 1) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      return _wrap_new_AnimPropertyRefArray__SWIG_1(L);
    }
  }
  if (argc == 2) {
    int _v;
    {
      _v = lua_isnumber(L,argv[0]);
    }
    if (_v) {
      {
        void *ptr;
        if (SWIG_isptrtype(L,argv[1])==0 || SWIG_ConvertPtr(L,argv[1], (void **) &ptr, SWIGTYPE_p_AnimProperty, 0)) {
          _v = 0;
        } else {
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_new_AnimPropertyRefArray__SWIG_3(L);
      }
    }
  }
  
  lua_pushstring(L,"No matching function for overloaded 'new_AnimPropertyRefArray'");
  lua_error(L);return 0;
}


static int _wrap_AnimPropertyRefArray_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimProperty * > *arg1 = (std::vector<AnimProperty * > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimProperty_p_t,0))){
    SWIG_fail_ptr("AnimPropertyRefArray_size",1,SWIGTYPE_p_std__vectorTAnimProperty_p_t);
  }
  
  result = (unsigned int)((std::vector<AnimProperty * > const *)arg1)->size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyRefArray_max_size(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimProperty * > *arg1 = (std::vector<AnimProperty * > *) 0 ;
  unsigned int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimProperty_p_t,0))){
    SWIG_fail_ptr("AnimPropertyRefArray_max_size",1,SWIGTYPE_p_std__vectorTAnimProperty_p_t);
  }
  
  result = (unsigned int)((std::vector<AnimProperty * > const *)arg1)->max_size();
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyRefArray_empty(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimProperty * > *arg1 = (std::vector<AnimProperty * > *) 0 ;
  bool result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimProperty_p_t,0))){
    SWIG_fail_ptr("AnimPropertyRefArray_empty",1,SWIGTYPE_p_std__vectorTAnimProperty_p_t);
  }
  
  result = (bool)((std::vector<AnimProperty * > const *)arg1)->empty();
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyRefArray_clear(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimProperty * > *arg1 = (std::vector<AnimProperty * > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimProperty_p_t,0))){
    SWIG_fail_ptr("AnimPropertyRefArray_clear",1,SWIGTYPE_p_std__vectorTAnimProperty_p_t);
  }
  
  (arg1)->clear();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyRefArray_push_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimProperty * > *arg1 = (std::vector<AnimProperty * > *) 0 ;
  AnimProperty *arg2 = (AnimProperty *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimProperty_p_t,0))){
    SWIG_fail_ptr("AnimPropertyRefArray_push_back",1,SWIGTYPE_p_std__vectorTAnimProperty_p_t);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimPropertyRefArray_push_back",2,SWIGTYPE_p_AnimProperty);
  }
  
  (arg1)->push_back(arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyRefArray_pop_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimProperty * > *arg1 = (std::vector<AnimProperty * > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimProperty_p_t,0))){
    SWIG_fail_ptr("AnimPropertyRefArray_pop_back",1,SWIGTYPE_p_std__vectorTAnimProperty_p_t);
  }
  
  (arg1)->pop_back();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyRefArray_front(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimProperty * > *arg1 = (std::vector<AnimProperty * > *) 0 ;
  AnimProperty *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimProperty_p_t,0))){
    SWIG_fail_ptr("AnimPropertyRefArray_front",1,SWIGTYPE_p_std__vectorTAnimProperty_p_t);
  }
  
  result = (AnimProperty *)((std::vector<AnimProperty * > const *)arg1)->front();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_AnimProperty,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyRefArray_back(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimProperty * > *arg1 = (std::vector<AnimProperty * > *) 0 ;
  AnimProperty *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimProperty_p_t,0))){
    SWIG_fail_ptr("AnimPropertyRefArray_back",1,SWIGTYPE_p_std__vectorTAnimProperty_p_t);
  }
  
  result = (AnimProperty *)((std::vector<AnimProperty * > const *)arg1)->back();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_AnimProperty,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyRefArray___getitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimProperty * > *arg1 = (std::vector<AnimProperty * > *) 0 ;
  unsigned int arg2 ;
  AnimProperty *result = 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimProperty_p_t,0))){
    SWIG_fail_ptr("AnimPropertyRefArray___getitem",1,SWIGTYPE_p_std__vectorTAnimProperty_p_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  try {
    result = (AnimProperty *)std_vector_Sl_AnimProperty_Sm__Sg____getitem__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_AnimProperty,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyRefArray___setitem(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimProperty * > *arg1 = (std::vector<AnimProperty * > *) 0 ;
  unsigned int arg2 ;
  AnimProperty *arg3 = (AnimProperty *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimProperty_p_t,0))){
    SWIG_fail_ptr("AnimPropertyRefArray___setitem",1,SWIGTYPE_p_std__vectorTAnimProperty_p_t);
  }
  
  arg2 = (unsigned int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("AnimPropertyRefArray___setitem",3,SWIGTYPE_p_AnimProperty);
  }
  
  try {
    std_vector_Sl_AnimProperty_Sm__Sg____setitem__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception(SWIG_IndexError, (&_e)->what()); 
  }
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnimPropertyRefArray___len(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimProperty * > *arg1 = (std::vector<AnimProperty * > *) 0 ;
  int result;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimProperty_p_t,0))){
    SWIG_fail_ptr("AnimPropertyRefArray___len",1,SWIGTYPE_p_std__vectorTAnimProperty_p_t);
  }
  
  result = (int)std_vector_Sl_AnimProperty_Sm__Sg____len(arg1);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_AnimPropertyRefArray(lua_State* L) {
  int SWIG_arg = -1;
  std::vector<AnimProperty * > *arg1 = (std::vector<AnimProperty * > *) 0 ;
  
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std__vectorTAnimProperty_p_t,0))){
    SWIG_fail_ptr("delete_AnimPropertyRefArray",1,SWIGTYPE_p_std__vectorTAnimProperty_p_t);
  }
  
  delete arg1;
  
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_AnimPropertyRefArray(void *obj) {
std::vector<AnimProperty * > *arg1 = (std::vector<AnimProperty * > *) obj;
delete arg1;
}
static swig_lua_method swig_std_vector_Sl_AnimProperty_Sm__Sg__methods[] = {
    {"size", _wrap_AnimPropertyRefArray_size}, 
    {"max_size", _wrap_AnimPropertyRefArray_max_size}, 
    {"empty", _wrap_AnimPropertyRefArray_empty}, 
    {"clear", _wrap_AnimPropertyRefArray_clear}, 
    {"push_back", _wrap_AnimPropertyRefArray_push_back}, 
    {"pop_back", _wrap_AnimPropertyRefArray_pop_back}, 
    {"front", _wrap_AnimPropertyRefArray_front}, 
    {"back", _wrap_AnimPropertyRefArray_back}, 
    {"__getitem", _wrap_AnimPropertyRefArray___getitem}, 
    {"__setitem", _wrap_AnimPropertyRefArray___setitem}, 
    {"__len", _wrap_AnimPropertyRefArray___len}, 
    {0,0}
};
static swig_lua_attribute swig_std_vector_Sl_AnimProperty_Sm__Sg__attributes[] = {
    {0,0,0}
};
static swig_lua_class *swig_std_vector_Sl_AnimProperty_Sm__Sg__bases[] = {0};
swig_lua_class _wrap_class_std_vector_Sl_AnimProperty_Sm__Sg_ = { "AnimPropertyRefArray", &SWIGTYPE_p_std__vectorTAnimProperty_p_t,_wrap_new_AnimPropertyRefArray, swig_delete_AnimPropertyRefArray, swig_std_vector_Sl_AnimProperty_Sm__Sg__methods, swig_std_vector_Sl_AnimProperty_Sm__Sg__attributes, swig_std_vector_Sl_AnimProperty_Sm__Sg__bases };

static int _wrap_message(lua_State* L) {
  int SWIG_arg = -1;
  char *arg1 = (char *) 0 ;
  void *arg2 = 0 ;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  arg1 = (char *)lua_tostring(L, 1);
  fltk::message((char const *)arg1,arg2);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_input(lua_State* L) {
  int SWIG_arg = -1;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *result = 0 ;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (char *)lua_tostring(L, 2);
  result = (char *)fltk::input((char const *)arg1,(char const *)arg2);
  SWIG_arg=0;
  lua_pushstring(L,(const char*)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_upsGetModel(lua_State* L) {
  int SWIG_arg = -1;
  Model *result = 0 ;
  
  result = (Model *)upsGetModel();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Model,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_upsGetRootObj(lua_State* L) {
  int SWIG_arg = -1;
  MdlObject *result = 0 ;
  
  result = (MdlObject *)upsGetRootObj();
  SWIG_arg=0;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MdlObject,0); SWIG_arg++; 
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_upsUpdateViews(lua_State* L) {
  int SWIG_arg = -1;
  
  upsUpdateViews();
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__upsFileSaveDlg(lua_State* L) {
  int SWIG_arg = -1;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  std::string *arg3 = 0 ;
  bool result;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("_upsFileSaveDlg",3,SWIGTYPE_p_std__string);
  }
  
  result = (bool)_upsFileSaveDlg((char const *)arg1,(char const *)arg2,*arg3);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__upsFileOpenDlg(lua_State* L) {
  int SWIG_arg = -1;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  std::string *arg3 = 0 ;
  bool result;
  
  if(!lua_isstring(L,1)) SWIG_fail_arg(1);
  if(!lua_isstring(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_std__string,0))){
    SWIG_fail_ptr("_upsFileOpenDlg",3,SWIGTYPE_p_std__string);
  }
  
  result = (bool)_upsFileOpenDlg((char const *)arg1,(char const *)arg2,*arg3);
  SWIG_arg=0;
  lua_pushboolean(L,(int)result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_upsAnimGetType(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = 0 ;
  int result;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("upsAnimGetType",1,SWIGTYPE_p_AnimProperty);
  }
  
  result = (int)upsAnimGetType(*arg1);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_upsAnimGetKeyIndex(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = 0 ;
  float arg2 ;
  int result;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("upsAnimGetKeyIndex",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (int)upsAnimGetKeyIndex(*arg1,arg2);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_upsAnimGetNumKeys(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = 0 ;
  int result;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("upsAnimGetNumKeys",1,SWIGTYPE_p_AnimProperty);
  }
  
  result = (int)upsAnimGetNumKeys(*arg1);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_upsAnimGetKeyTime(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = 0 ;
  int arg2 ;
  float result;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("upsAnimGetKeyTime",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (float)upsAnimGetKeyTime(*arg1,arg2);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_upsAnimGetFloatKey(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = 0 ;
  int arg2 ;
  float result;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("upsAnimGetFloatKey",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (float)upsAnimGetFloatKey(*arg1,arg2);
  SWIG_arg=0;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_upsAnimGetVector3Key(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = 0 ;
  int arg2 ;
  Vector3 result;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("upsAnimGetVector3Key",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = upsAnimGetVector3Key(*arg1,arg2);
  SWIG_arg=0;
  {
    Vector3 * resultptr = new Vector3((Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_upsAnimGetRotationKey(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = 0 ;
  int arg2 ;
  Vector3 result;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("upsAnimGetRotationKey",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = upsAnimGetRotationKey(*arg1,arg2);
  SWIG_arg=0;
  {
    Vector3 * resultptr = new Vector3((Vector3 &) result);
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_Vector3,1); SWIG_arg++;
  }
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_upsAnimInsertVectorKey(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = 0 ;
  float arg2 ;
  Vector3 arg3 ;
  Vector3 *argp3 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("upsAnimInsertVectorKey",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Vector3,0))){
    SWIG_fail_ptr("upsAnimInsertVectorKey",3,SWIGTYPE_Vector3);
  }
  arg3 = *argp3;
  
  upsAnimInsertVectorKey(*arg1,arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_upsAnimInsertRotatorKey(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = 0 ;
  float arg2 ;
  Rotator arg3 ;
  Rotator *argp3 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isuserdata(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("upsAnimInsertRotatorKey",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_Rotator,0))){
    SWIG_fail_ptr("upsAnimInsertRotatorKey",3,SWIGTYPE_Rotator);
  }
  arg3 = *argp3;
  
  upsAnimInsertRotatorKey(*arg1,arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_upsAnimInsertFloatKey(lua_State* L) {
  int SWIG_arg = -1;
  AnimProperty *arg1 = 0 ;
  float arg2 ;
  float arg3 ;
  
  if(!lua_isuserdata(L,1)) SWIG_fail_arg(1);
  if(!lua_isnumber(L,2)) SWIG_fail_arg(2);
  if(!lua_isnumber(L,3)) SWIG_fail_arg(3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_AnimProperty,0))){
    SWIG_fail_ptr("upsAnimInsertFloatKey",1,SWIGTYPE_p_AnimProperty);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  upsAnimInsertFloatKey(*arg1,arg2,arg3);
  SWIG_arg=0;
  
  return SWIG_arg;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


#ifdef __cplusplus
}
#endif

static const struct luaL_reg swig_commands[] = {
    { "new_cppstring",_wrap_new_cppstring},
    { "cppstring_size", _wrap_cppstring_size},
    { "cppstring_length", _wrap_cppstring_length},
    { "cppstring_empty", _wrap_cppstring_empty},
    { "cppstring_c_str", _wrap_cppstring_c_str},
    { "cppstring_data", _wrap_cppstring_data},
    { "cppstring_assign", _wrap_cppstring_assign},
    { "delete_cppstring", _wrap_delete_cppstring},
    { "new_IntArray",_wrap_new_IntArray},
    { "IntArray_size", _wrap_IntArray_size},
    { "IntArray_max_size", _wrap_IntArray_max_size},
    { "IntArray_empty", _wrap_IntArray_empty},
    { "IntArray_clear", _wrap_IntArray_clear},
    { "IntArray_push_back", _wrap_IntArray_push_back},
    { "IntArray_pop_back", _wrap_IntArray_pop_back},
    { "IntArray_front", _wrap_IntArray_front},
    { "IntArray_back", _wrap_IntArray_back},
    { "IntArray___getitem", _wrap_IntArray___getitem},
    { "IntArray___setitem", _wrap_IntArray___setitem},
    { "IntArray___len", _wrap_IntArray___len},
    { "delete_IntArray", _wrap_delete_IntArray},
    { "new_FloatArray",_wrap_new_FloatArray},
    { "FloatArray_size", _wrap_FloatArray_size},
    { "FloatArray_max_size", _wrap_FloatArray_max_size},
    { "FloatArray_empty", _wrap_FloatArray_empty},
    { "FloatArray_clear", _wrap_FloatArray_clear},
    { "FloatArray_push_back", _wrap_FloatArray_push_back},
    { "FloatArray_pop_back", _wrap_FloatArray_pop_back},
    { "FloatArray_front", _wrap_FloatArray_front},
    { "FloatArray_back", _wrap_FloatArray_back},
    { "FloatArray___getitem", _wrap_FloatArray___getitem},
    { "FloatArray___setitem", _wrap_FloatArray___setitem},
    { "FloatArray___len", _wrap_FloatArray___len},
    { "delete_FloatArray", _wrap_delete_FloatArray},
    { "new_CharArray",_wrap_new_CharArray},
    { "CharArray_size", _wrap_CharArray_size},
    { "CharArray_max_size", _wrap_CharArray_max_size},
    { "CharArray_empty", _wrap_CharArray_empty},
    { "CharArray_clear", _wrap_CharArray_clear},
    { "CharArray_push_back", _wrap_CharArray_push_back},
    { "CharArray_pop_back", _wrap_CharArray_pop_back},
    { "CharArray_front", _wrap_CharArray_front},
    { "CharArray_back", _wrap_CharArray_back},
    { "CharArray___getitem", _wrap_CharArray___getitem},
    { "CharArray___setitem", _wrap_CharArray___setitem},
    { "CharArray___len", _wrap_CharArray___len},
    { "delete_CharArray", _wrap_delete_CharArray},
    { "new_ShortArray",_wrap_new_ShortArray},
    { "ShortArray_size", _wrap_ShortArray_size},
    { "ShortArray_max_size", _wrap_ShortArray_max_size},
    { "ShortArray_empty", _wrap_ShortArray_empty},
    { "ShortArray_clear", _wrap_ShortArray_clear},
    { "ShortArray_push_back", _wrap_ShortArray_push_back},
    { "ShortArray_pop_back", _wrap_ShortArray_pop_back},
    { "ShortArray_front", _wrap_ShortArray_front},
    { "ShortArray_back", _wrap_ShortArray_back},
    { "ShortArray___getitem", _wrap_ShortArray___getitem},
    { "ShortArray___setitem", _wrap_ShortArray___setitem},
    { "ShortArray___len", _wrap_ShortArray___len},
    { "delete_ShortArray", _wrap_delete_ShortArray},
    { "d_trace", _wrap_d_trace},
    { "d_puts", _wrap_d_puts},
    { "d_assert", _wrap_d_assert},
    { "d_clearlog", _wrap_d_clearlog},
    { "d_setlogfile", _wrap_d_setlogfile},
    { "new_Vector3",_wrap_new_Vector3},
    { "Vector3_set",_wrap_Vector3_set},
    { "Vector3_sub", _wrap_Vector3_sub},
    { "Vector3_mul", _wrap_Vector3_mul},
    { "Vector3_add", _wrap_Vector3_add},
    { "Vector3_dot",_wrap_Vector3_dot},
    { "Vector3___add", _wrap_Vector3___add},
    { "Vector3___sub", _wrap_Vector3___sub},
    { "Vector3___mul",_wrap_Vector3___mul},
    { "Vector3___eq", _wrap_Vector3___eq},
    { "Vector3___unm", _wrap_Vector3___unm},
    { "Vector3___div", _wrap_Vector3___div},
    { "Vector3_crossproduct", _wrap_Vector3_crossproduct},
    { "Vector3_length", _wrap_Vector3_length},
    { "Vector3_project", _wrap_Vector3_project},
    { "Vector3_projectf", _wrap_Vector3_projectf},
    { "Vector3_normalize", _wrap_Vector3_normalize},
    { "Vector3_distance", _wrap_Vector3_distance},
    { "Vector3_get_normal", _wrap_Vector3_get_normal},
    { "Vector3_getf", _wrap_Vector3_getf},
    { "Vector3_incboundingmin", _wrap_Vector3_incboundingmin},
    { "Vector3_incboundingmax", _wrap_Vector3_incboundingmax},
    { "Vector3_epsilon_compare", _wrap_Vector3_epsilon_compare},
    { "Vector3_copy",_wrap_Vector3_copy},
    { "Vector3_x_set", _wrap_Vector3_x_set},
    { "Vector3_x_get", _wrap_Vector3_x_get},
    { "Vector3_y_set", _wrap_Vector3_y_set},
    { "Vector3_y_get", _wrap_Vector3_y_get},
    { "Vector3_z_set", _wrap_Vector3_z_set},
    { "Vector3_z_get", _wrap_Vector3_z_get},
    { "delete_Vector3", _wrap_delete_Vector3},
    { "new_Vector2",_wrap_new_Vector2},
    { "Vector2_x_set", _wrap_Vector2_x_set},
    { "Vector2_x_get", _wrap_Vector2_x_get},
    { "Vector2_y_set", _wrap_Vector2_y_set},
    { "Vector2_y_get", _wrap_Vector2_y_get},
    { "delete_Vector2", _wrap_delete_Vector2},
    { "new_Vector4",_wrap_new_Vector4},
    { "Vector4_x_set", _wrap_Vector4_x_set},
    { "Vector4_x_get", _wrap_Vector4_x_get},
    { "Vector4_y_set", _wrap_Vector4_y_set},
    { "Vector4_y_get", _wrap_Vector4_y_get},
    { "Vector4_z_set", _wrap_Vector4_z_set},
    { "Vector4_z_get", _wrap_Vector4_z_get},
    { "Vector4_w_set", _wrap_Vector4_w_set},
    { "Vector4_w_get", _wrap_Vector4_w_get},
    { "delete_Vector4", _wrap_delete_Vector4},
    { "Plane_a_set", _wrap_Plane_a_set},
    { "Plane_a_get", _wrap_Plane_a_get},
    { "Plane_b_set", _wrap_Plane_b_set},
    { "Plane_b_get", _wrap_Plane_b_get},
    { "Plane_c_set", _wrap_Plane_c_set},
    { "Plane_c_get", _wrap_Plane_c_get},
    { "Plane_d_set", _wrap_Plane_d_set},
    { "Plane_d_get", _wrap_Plane_d_get},
    { "new_Plane",_wrap_new_Plane},
    { "Plane_Dis",_wrap_Plane_Dis},
    { "Plane_EpsilonCompare", _wrap_Plane_EpsilonCompare},
    { "Plane_MakePlane", _wrap_Plane_MakePlane},
    { "Plane_Inverse", _wrap_Plane_Inverse},
    { "Plane_SetVec", _wrap_Plane_SetVec},
    { "Plane_CalcDis", _wrap_Plane_CalcDis},
    { "Plane_copy", _wrap_Plane_copy},
    { "Plane_GetVector", _wrap_Plane_GetVector},
    { "Plane_GetCenter", _wrap_Plane_GetCenter},
    { "delete_Plane", _wrap_delete_Plane},
    { "new_Matrix", _wrap_new_Matrix},
    { "Matrix_vector_rotation", _wrap_Matrix_vector_rotation},
    { "Matrix_translation",_wrap_Matrix_translation},
    { "Matrix_addtranslation", _wrap_Matrix_addtranslation},
    { "Matrix_addscale",_wrap_Matrix_addscale},
    { "Matrix_scale",_wrap_Matrix_scale},
    { "Matrix_camera", _wrap_Matrix_camera},
    { "Matrix_transpose", _wrap_Matrix_transpose},
    { "Matrix_apply",_wrap_Matrix_apply},
    { "Matrix_camera_pos", _wrap_Matrix_camera_pos},
    { "Matrix___mul",_wrap_Matrix___mul},
    { "Matrix_align", _wrap_Matrix_align},
    { "Matrix_xrotate", _wrap_Matrix_xrotate},
    { "Matrix_yrotate", _wrap_Matrix_yrotate},
    { "Matrix_zrotate", _wrap_Matrix_zrotate},
    { "Matrix_eulerZXY",_wrap_Matrix_eulerZXY},
    { "Matrix_eulerYXZ",_wrap_Matrix_eulerYXZ},
    { "Matrix_calcEulerZXY", _wrap_Matrix_calcEulerZXY},
    { "Matrix_calcEulerYXZ", _wrap_Matrix_calcEulerYXZ},
    { "Matrix_makequat", _wrap_Matrix_makequat},
    { "Matrix_identity", _wrap_Matrix_identity},
    { "Matrix_clear", _wrap_Matrix_clear},
    { "Matrix_inverse", _wrap_Matrix_inverse},
    { "Matrix_determinant", _wrap_Matrix_determinant},
    { "Matrix_adjoint", _wrap_Matrix_adjoint},
    { "Matrix_copy",_wrap_Matrix_copy},
    { "Matrix_perspective_lh", _wrap_Matrix_perspective_lh},
    { "Matrix_multiply",_wrap_Matrix_multiply},
    { "Matrix_v",_wrap_Matrix_v},
    { "Matrix_t",_wrap_Matrix_t},
    { "Matrix___call",_wrap_Matrix___call},
    { "Matrix_getx",_wrap_Matrix_getx},
    { "Matrix_gety",_wrap_Matrix_gety},
    { "Matrix_getz",_wrap_Matrix_getz},
    { "Matrix_getw",_wrap_Matrix_getw},
    { "Matrix_getcx", _wrap_Matrix_getcx},
    { "Matrix_getcy", _wrap_Matrix_getcy},
    { "Matrix_getcz", _wrap_Matrix_getcz},
    { "Matrix_getcw", _wrap_Matrix_getcw},
    { "Matrix_setcx", _wrap_Matrix_setcx},
    { "Matrix_setcy", _wrap_Matrix_setcy},
    { "Matrix_setcz", _wrap_Matrix_setcz},
    { "Matrix_setcw", _wrap_Matrix_setcw},
    { "Matrix_m_set", _wrap_Matrix_m_set},
    { "Matrix_m_get", _wrap_Matrix_m_get},
    { "delete_Matrix", _wrap_delete_Matrix},
    { "new_Quaternion",_wrap_new_Quaternion},
    { "Quaternion_identity", _wrap_Quaternion_identity},
    { "Quaternion_copy", _wrap_Quaternion_copy},
    { "Quaternion_normal", _wrap_Quaternion_normal},
    { "Quaternion_conjugate",_wrap_Quaternion_conjugate},
    { "Quaternion_normalize", _wrap_Quaternion_normalize},
    { "Quaternion___mul", _wrap_Quaternion___mul},
    { "Quaternion_mul", _wrap_Quaternion_mul},
    { "Quaternion_xrotate", _wrap_Quaternion_xrotate},
    { "Quaternion_yrotate", _wrap_Quaternion_yrotate},
    { "Quaternion_zrotate", _wrap_Quaternion_zrotate},
    { "Quaternion_rotation", _wrap_Quaternion_rotation},
    { "Quaternion_vector_rot", _wrap_Quaternion_vector_rot},
    { "Quaternion_slerp", _wrap_Quaternion_slerp},
    { "Quaternion_apply",_wrap_Quaternion_apply},
    { "Quaternion_makematrix", _wrap_Quaternion_makematrix},
    { "Quaternion_inverse", _wrap_Quaternion_inverse},
    { "Quaternion_x_set", _wrap_Quaternion_x_set},
    { "Quaternion_x_get", _wrap_Quaternion_x_get},
    { "Quaternion_y_set", _wrap_Quaternion_y_set},
    { "Quaternion_y_get", _wrap_Quaternion_y_get},
    { "Quaternion_z_set", _wrap_Quaternion_z_set},
    { "Quaternion_z_get", _wrap_Quaternion_z_get},
    { "Quaternion_w_set", _wrap_Quaternion_w_set},
    { "Quaternion_w_get", _wrap_Quaternion_w_get},
    { "delete_Quaternion", _wrap_delete_Quaternion},
    { "SamePoint", _wrap_SamePoint},
    { "NearestBoxVertex", _wrap_NearestBoxVertex},
    { "ComputeOrientation",_wrap_ComputeOrientation},
    { "NearestBoxPoint", _wrap_NearestBoxPoint},
    { "GetTransform", _wrap_GetTransform},
    { "new_Triangle", _wrap_new_Triangle},
    { "Triangle_vrt_set", _wrap_Triangle_vrt_set},
    { "Triangle_vrt_get", _wrap_Triangle_vrt_get},
    { "delete_Triangle", _wrap_delete_Triangle},
    { "Vertex_pos_set", _wrap_Vertex_pos_set},
    { "Vertex_pos_get", _wrap_Vertex_pos_get},
    { "Vertex_normal_set", _wrap_Vertex_normal_set},
    { "Vertex_normal_get", _wrap_Vertex_normal_get},
    { "Vertex_tc_set", _wrap_Vertex_tc_set},
    { "Vertex_tc_get", _wrap_Vertex_tc_get},
    { "delete_Vertex", _wrap_delete_Vertex},
    { "new_Poly", _wrap_new_Poly},
    { "delete_Poly", _wrap_delete_Poly},
    { "Poly_CalcPlane", _wrap_Poly_CalcPlane},
    { "Poly_Flip", _wrap_Poly_Flip},
    { "Poly_Clone", _wrap_Poly_Clone},
    { "Poly_RotateVerts", _wrap_Poly_RotateVerts},
    { "Poly_verts_set", _wrap_Poly_verts_set},
    { "Poly_verts_get", _wrap_Poly_verts_get},
    { "Poly_texname_set", _wrap_Poly_texname_set},
    { "Poly_texname_get", _wrap_Poly_texname_get},
    { "Poly_color_set", _wrap_Poly_color_set},
    { "Poly_color_get", _wrap_Poly_color_get},
    { "Poly_taColor_set", _wrap_Poly_taColor_set},
    { "Poly_taColor_get", _wrap_Poly_taColor_get},
    { "Poly_texture_set", _wrap_Poly_texture_set},
    { "Poly_texture_get", _wrap_Poly_texture_get},
    { "Poly_isCurved_set", _wrap_Poly_isCurved_set},
    { "Poly_isCurved_get", _wrap_Poly_isCurved_get},
    { "Poly_isSelected_set", _wrap_Poly_isSelected_set},
    { "Poly_isSelected_get", _wrap_Poly_isSelected_get},
    { "delete_BaseJoint", _wrap_delete_BaseJoint},
    { "HingeJoint_axis_set", _wrap_HingeJoint_axis_set},
    { "HingeJoint_axis_get", _wrap_HingeJoint_axis_get},
    { "delete_HingeJoint", _wrap_delete_HingeJoint},
    { "UniversalJoint_axis_set", _wrap_UniversalJoint_axis_set},
    { "UniversalJoint_axis_get", _wrap_UniversalJoint_axis_get},
    { "delete_UniversalJoint", _wrap_delete_UniversalJoint},
    { "new_IKinfo", _wrap_new_IKinfo},
    { "delete_IKinfo", _wrap_delete_IKinfo},
    { "IKinfo_jointType_set", _wrap_IKinfo_jointType_set},
    { "IKinfo_jointType_get", _wrap_IKinfo_jointType_get},
    { "IKinfo_joint_set", _wrap_IKinfo_joint_set},
    { "IKinfo_joint_get", _wrap_IKinfo_joint_get},
    { "delete_IRenderData", _wrap_delete_IRenderData},
    { "IRenderData_Invalidate", _wrap_IRenderData_Invalidate},
    { "new_Rotator", _wrap_new_Rotator},
    { "Rotator_AddEulerAbsolute", _wrap_Rotator_AddEulerAbsolute},
    { "Rotator_AddEulerRelative", _wrap_Rotator_AddEulerRelative},
    { "Rotator_GetEuler", _wrap_Rotator_GetEuler},
    { "Rotator_SetEuler", _wrap_Rotator_SetEuler},
    { "Rotator_ToMatrix", _wrap_Rotator_ToMatrix},
    { "Rotator_FromMatrix", _wrap_Rotator_FromMatrix},
    { "Rotator_GetQuat", _wrap_Rotator_GetQuat},
    { "Rotator_SetQuat", _wrap_Rotator_SetQuat},
    { "Rotator_euler_set", _wrap_Rotator_euler_set},
    { "Rotator_euler_get", _wrap_Rotator_euler_get},
    { "Rotator_eulerInterp_set", _wrap_Rotator_eulerInterp_set},
    { "Rotator_eulerInterp_get", _wrap_Rotator_eulerInterp_get},
    { "delete_Rotator", _wrap_delete_Rotator},
    { "delete_Geometry", _wrap_delete_Geometry},
    { "Geometry_Draw", _wrap_Geometry_Draw},
    { "Geometry_Clone", _wrap_Geometry_Clone},
    { "Geometry_Transform", _wrap_Geometry_Transform},
    { "Geometry_ToPolyMesh", _wrap_Geometry_ToPolyMesh},
    { "Geometry_InvalidateRenderData", _wrap_Geometry_InvalidateRenderData},
    { "Geometry_CalculateRadius", _wrap_Geometry_CalculateRadius},
    { "delete_PolyMesh", _wrap_delete_PolyMesh},
    { "PolyMesh_verts_set", _wrap_PolyMesh_verts_set},
    { "PolyMesh_verts_get", _wrap_PolyMesh_verts_get},
    { "PolyMesh_poly_set", _wrap_PolyMesh_poly_set},
    { "PolyMesh_poly_get", _wrap_PolyMesh_poly_get},
    { "PolyMesh_Draw", _wrap_PolyMesh_Draw},
    { "PolyMesh_Clone", _wrap_PolyMesh_Clone},
    { "PolyMesh_Transform", _wrap_PolyMesh_Transform},
    { "PolyMesh_ToPolyMesh", _wrap_PolyMesh_ToPolyMesh},
    { "PolyMesh_MakeTris", _wrap_PolyMesh_MakeTris},
    { "PolyMesh_IsEqualVertexTC", _wrap_PolyMesh_IsEqualVertexTC},
    { "PolyMesh_IsEqualVertexTCNormal", _wrap_PolyMesh_IsEqualVertexTCNormal},
    { "PolyMesh_OptimizeVertices", _wrap_PolyMesh_OptimizeVertices},
    { "PolyMesh_Optimize", _wrap_PolyMesh_Optimize},
    { "PolyMesh_MoveGeometry", _wrap_PolyMesh_MoveGeometry},
    { "PolyMesh_FlipPolygons", _wrap_PolyMesh_FlipPolygons},
    { "PolyMesh_CalculateRadius", _wrap_PolyMesh_CalculateRadius},
    { "PolyMesh_CalculateNormals", _wrap_PolyMesh_CalculateNormals},
    { "PolyMesh_CalculateNormals2", _wrap_PolyMesh_CalculateNormals2},
    { "new_MdlObject", _wrap_new_MdlObject},
    { "delete_MdlObject", _wrap_delete_MdlObject},
    { "MdlObject_IsEmpty", _wrap_MdlObject_IsEmpty},
    { "MdlObject_Dump",_wrap_MdlObject_Dump},
    { "MdlObject_MergeChild", _wrap_MdlObject_MergeChild},
    { "MdlObject_FullMerge", _wrap_MdlObject_FullMerge},
    { "MdlObject_GetTransform", _wrap_MdlObject_GetTransform},
    { "MdlObject_GetFullTransform", _wrap_MdlObject_GetFullTransform},
    { "MdlObject_GetChildObjects", _wrap_MdlObject_GetChildObjects},
    { "MdlObject_UnlinkFromParent", _wrap_MdlObject_UnlinkFromParent},
    { "MdlObject_LinkToParent", _wrap_MdlObject_LinkToParent},
    { "MdlObject_FlipPolygons", _wrap_MdlObject_FlipPolygons},
    { "MdlObject_Load3DOTextures", _wrap_MdlObject_Load3DOTextures},
    { "MdlObject_HasSelectedParent", _wrap_MdlObject_HasSelectedParent},
    { "MdlObject_ApplyTransform", _wrap_MdlObject_ApplyTransform},
    { "MdlObject_ApplyParentSpaceTransform", _wrap_MdlObject_ApplyParentSpaceTransform},
    { "MdlObject_TransformVertices", _wrap_MdlObject_TransformVertices},
    { "MdlObject_ApproximateOffset", _wrap_MdlObject_ApproximateOffset},
    { "MdlObject_SetPropertiesFromMatrix", _wrap_MdlObject_SetPropertiesFromMatrix},
    { "MdlObject_Transform", _wrap_MdlObject_Transform},
    { "MdlObject_InvalidateRenderData", _wrap_MdlObject_InvalidateRenderData},
    { "MdlObject_NormalizeNormals", _wrap_MdlObject_NormalizeNormals},
    { "MdlObject_MoveOrigin", _wrap_MdlObject_MoveOrigin},
    { "MdlObject_AddChild", _wrap_MdlObject_AddChild},
    { "MdlObject_RemoveChild", _wrap_MdlObject_RemoveChild},
    { "MdlObject_GetPolyMesh", _wrap_MdlObject_GetPolyMesh},
    { "MdlObject_ToPolyMesh", _wrap_MdlObject_ToPolyMesh},
    { "MdlObject_GetOrCreatePolyMesh", _wrap_MdlObject_GetOrCreatePolyMesh},
    { "MdlObject_InitAnimationInfo", _wrap_MdlObject_InitAnimationInfo},
    { "MdlObject_UpdateAnimation", _wrap_MdlObject_UpdateAnimation},
    { "MdlObject_Clone", _wrap_MdlObject_Clone},
    { "MdlObject_position_set", _wrap_MdlObject_position_set},
    { "MdlObject_position_get", _wrap_MdlObject_position_get},
    { "MdlObject_rotation_set", _wrap_MdlObject_rotation_set},
    { "MdlObject_rotation_get", _wrap_MdlObject_rotation_get},
    { "MdlObject_scale_set", _wrap_MdlObject_scale_set},
    { "MdlObject_scale_get", _wrap_MdlObject_scale_get},
    { "MdlObject_geometry_set", _wrap_MdlObject_geometry_set},
    { "MdlObject_geometry_get", _wrap_MdlObject_geometry_get},
    { "MdlObject_animInfo_set", _wrap_MdlObject_animInfo_set},
    { "MdlObject_animInfo_get", _wrap_MdlObject_animInfo_get},
    { "MdlObject_name_set", _wrap_MdlObject_name_set},
    { "MdlObject_name_get", _wrap_MdlObject_name_get},
    { "MdlObject_isSelected_set", _wrap_MdlObject_isSelected_set},
    { "MdlObject_isSelected_get", _wrap_MdlObject_isSelected_get},
    { "MdlObject_isOpen_set", _wrap_MdlObject_isOpen_set},
    { "MdlObject_isOpen_get", _wrap_MdlObject_isOpen_get},
    { "MdlObject_ikInfo_set", _wrap_MdlObject_ikInfo_set},
    { "MdlObject_ikInfo_get", _wrap_MdlObject_ikInfo_get},
    { "MdlObject_parent_set", _wrap_MdlObject_parent_set},
    { "MdlObject_parent_get", _wrap_MdlObject_parent_get},
    { "MdlObject_childs_set", _wrap_MdlObject_childs_set},
    { "MdlObject_childs_get", _wrap_MdlObject_childs_get},
    { "MdlObject_NewPolyMesh", _wrap_MdlObject_NewPolyMesh},
    { "IterateObjects", _wrap_IterateObjects},
    { "new_IProgressCtl", _wrap_new_IProgressCtl},
    { "IProgressCtl_Update", _wrap_IProgressCtl_Update},
    { "IProgressCtl_cb_set", _wrap_IProgressCtl_cb_set},
    { "IProgressCtl_cb_get", _wrap_IProgressCtl_cb_get},
    { "IProgressCtl_data_set", _wrap_IProgressCtl_data_set},
    { "IProgressCtl_data_get", _wrap_IProgressCtl_data_get},
    { "delete_IProgressCtl", _wrap_delete_IProgressCtl},
    { "TextureBinding_name_set", _wrap_TextureBinding_name_set},
    { "TextureBinding_name_get", _wrap_TextureBinding_name_get},
    { "TextureBinding_SetTexture", _wrap_TextureBinding_SetTexture},
    { "TextureBinding_GetTexture", _wrap_TextureBinding_GetTexture},
    { "delete_TextureBinding", _wrap_delete_TextureBinding},
    { "new_Model", _wrap_new_Model},
    { "delete_Model", _wrap_delete_Model},
    { "Model_PostLoad", _wrap_Model_PostLoad},
    { "Model_Load3DO",_wrap_Model_Load3DO},
    { "Model_Save3DO",_wrap_Model_Save3DO},
    { "Model_LoadS3O",_wrap_Model_LoadS3O},
    { "Model_SaveS3O",_wrap_Model_SaveS3O},
    { "Model_Load",_wrap_Model_Load},
    { "Model_Save",_wrap_Model_Save},
    { "Model_ExportUVMesh", _wrap_Model_ExportUVMesh},
    { "Model_ImportUVMesh",_wrap_Model_ImportUVMesh},
    { "Model_ImportUVCoords",_wrap_Model_ImportUVCoords},
    { "Model_InsertModel", _wrap_Model_InsertModel},
    { "Model_GetSelectedObjects", _wrap_Model_GetSelectedObjects},
    { "Model_GetObjectList", _wrap_Model_GetObjectList},
    { "Model_GetPolyMeshList", _wrap_Model_GetPolyMeshList},
    { "Model_DeleteObject", _wrap_Model_DeleteObject},
    { "Model_ReplaceObject", _wrap_Model_ReplaceObject},
    { "Model_EstimateMidPosition", _wrap_Model_EstimateMidPosition},
    { "Model_CalculateRadius", _wrap_Model_CalculateRadius},
    { "Model_SwapObjects", _wrap_Model_SwapObjects},
    { "Model_Clone", _wrap_Model_Clone},
    { "Model_ObjectSelectionHash", _wrap_Model_ObjectSelectionHash},
    { "Model_SetTextureName", _wrap_Model_SetTextureName},
    { "Model_SetTexture", _wrap_Model_SetTexture},
    { "Model_ConvertToS3O", _wrap_Model_ConvertToS3O},
    { "Model_radius_set", _wrap_Model_radius_set},
    { "Model_radius_get", _wrap_Model_radius_get},
    { "Model_height_set", _wrap_Model_height_set},
    { "Model_height_get", _wrap_Model_height_get},
    { "Model_mid_set", _wrap_Model_mid_set},
    { "Model_mid_get", _wrap_Model_mid_get},
    { "Model_HasTex", _wrap_Model_HasTex},
    { "Model_TextureID", _wrap_Model_TextureID},
    { "Model_TextureName", _wrap_Model_TextureName},
    { "Model_texBindings_set", _wrap_Model_texBindings_set},
    { "Model_texBindings_get", _wrap_Model_texBindings_get},
    { "Model_mapping_set", _wrap_Model_mapping_set},
    { "Model_mapping_get", _wrap_Model_mapping_get},
    { "Model_root_set", _wrap_Model_root_set},
    { "Model_root_get", _wrap_Model_root_get},
    { "Model_SetRoot", _wrap_Model_SetRoot},
    { "Load3DSObject", _wrap_Load3DSObject},
    { "Save3DSObject", _wrap_Save3DSObject},
    { "LoadWavefrontObject", _wrap_LoadWavefrontObject},
    { "SaveWavefrontObject", _wrap_SaveWavefrontObject},
    { "GenerateUniqueVectors", _wrap_GenerateUniqueVectors},
    { "new_AnimProperty",_wrap_new_AnimProperty},
    { "delete_AnimProperty", _wrap_delete_AnimProperty},
    { "AnimProperty_GetKeyIndex",_wrap_AnimProperty_GetKeyIndex},
    { "AnimProperty_Evaluate",_wrap_AnimProperty_Evaluate},
    { "AnimProperty_InsertKey", _wrap_AnimProperty_InsertKey},
    { "AnimProperty_ChopAnimation", _wrap_AnimProperty_ChopAnimation},
    { "AnimProperty_GetKeyData", _wrap_AnimProperty_GetKeyData},
    { "AnimProperty_NumKeys", _wrap_AnimProperty_NumKeys},
    { "AnimProperty_GetKeyTime", _wrap_AnimProperty_GetKeyTime},
    { "AnimProperty_SetKeyTime", _wrap_AnimProperty_SetKeyTime},
    { "AnimProperty_GetName", _wrap_AnimProperty_GetName},
    { "AnimProperty_Clear", _wrap_AnimProperty_Clear},
    { "AnimProperty_Clone", _wrap_AnimProperty_Clone},
    { "AnimProperty_keyData_set", _wrap_AnimProperty_keyData_set},
    { "AnimProperty_keyData_get", _wrap_AnimProperty_keyData_get},
    { "AnimProperty_offset_set", _wrap_AnimProperty_offset_set},
    { "AnimProperty_offset_get", _wrap_AnimProperty_offset_get},
    { "AnimProperty_elemSize_set", _wrap_AnimProperty_elemSize_set},
    { "AnimProperty_elemSize_get", _wrap_AnimProperty_elemSize_get},
    { "AnimProperty_name_set", _wrap_AnimProperty_name_set},
    { "AnimProperty_name_get", _wrap_AnimProperty_name_get},
    { "delete_AnimationInfo", _wrap_delete_AnimationInfo},
    { "AnimationInfo_Serialize", _wrap_AnimationInfo_Serialize},
    { "AnimationInfo_AddProperty", _wrap_AnimationInfo_AddProperty},
    { "AnimationInfo_Evaluate", _wrap_AnimationInfo_Evaluate},
    { "AnimationInfo_InsertKeyFrames", _wrap_AnimationInfo_InsertKeyFrames},
    { "AnimationInfo_ClearAnimData", _wrap_AnimationInfo_ClearAnimData},
    { "AnimationInfo_CopyTo", _wrap_AnimationInfo_CopyTo},
    { "AnimationInfo_properties_set", _wrap_AnimationInfo_properties_set},
    { "AnimationInfo_properties_get", _wrap_AnimationInfo_properties_get},
    { "AnimationSequence_name_set", _wrap_AnimationSequence_name_set},
    { "AnimationSequence_name_get", _wrap_AnimationSequence_name_get},
    { "AnimationSequence_objects_set", _wrap_AnimationSequence_objects_set},
    { "AnimationSequence_objects_get", _wrap_AnimationSequence_objects_get},
    { "new_AnimationSequence", _wrap_new_AnimationSequence},
    { "delete_AnimationSequence", _wrap_delete_AnimationSequence},
    { "IEditor_Update", _wrap_IEditor_Update},
    { "IEditor_RedrawViews", _wrap_IEditor_RedrawViews},
    { "IEditor_GetViews", _wrap_IEditor_GetViews},
    { "IEditor_MergeView", _wrap_IEditor_MergeView},
    { "IEditor_AddView", _wrap_IEditor_AddView},
    { "IEditor_SelectionUpdated", _wrap_IEditor_SelectionUpdated},
    { "IEditor_GetMdl", _wrap_IEditor_GetMdl},
    { "IEditor_GetTool", _wrap_IEditor_GetTool},
    { "IEditor_RenderScene", _wrap_IEditor_RenderScene},
    { "IEditor_GetTextureHandler", _wrap_IEditor_GetTextureHandler},
    { "IEditor_SetTextureSelectCallback", _wrap_IEditor_SetTextureSelectCallback},
    { "IEditor_GetTime", _wrap_IEditor_GetTime},
    { "IEditor_SetModel", _wrap_IEditor_SetModel},
    { "delete_IEditor", _wrap_delete_IEditor},
    { "upsGetEditor", _wrap_upsGetEditor},
    { "upsAddMenuItem", _wrap_upsAddMenuItem},
    { "new_PolyRefArray",_wrap_new_PolyRefArray},
    { "PolyRefArray_size", _wrap_PolyRefArray_size},
    { "PolyRefArray_max_size", _wrap_PolyRefArray_max_size},
    { "PolyRefArray_empty", _wrap_PolyRefArray_empty},
    { "PolyRefArray_clear", _wrap_PolyRefArray_clear},
    { "PolyRefArray_push_back", _wrap_PolyRefArray_push_back},
    { "PolyRefArray_pop_back", _wrap_PolyRefArray_pop_back},
    { "PolyRefArray_front", _wrap_PolyRefArray_front},
    { "PolyRefArray_back", _wrap_PolyRefArray_back},
    { "PolyRefArray___getitem", _wrap_PolyRefArray___getitem},
    { "PolyRefArray___setitem", _wrap_PolyRefArray___setitem},
    { "PolyRefArray___len", _wrap_PolyRefArray___len},
    { "delete_PolyRefArray", _wrap_delete_PolyRefArray},
    { "new_VertexArray",_wrap_new_VertexArray},
    { "VertexArray_size", _wrap_VertexArray_size},
    { "VertexArray_max_size", _wrap_VertexArray_max_size},
    { "VertexArray_empty", _wrap_VertexArray_empty},
    { "VertexArray_clear", _wrap_VertexArray_clear},
    { "VertexArray_push_back", _wrap_VertexArray_push_back},
    { "VertexArray_pop_back", _wrap_VertexArray_pop_back},
    { "VertexArray_front", _wrap_VertexArray_front},
    { "VertexArray_back", _wrap_VertexArray_back},
    { "VertexArray___getitem", _wrap_VertexArray___getitem},
    { "VertexArray___setitem", _wrap_VertexArray___setitem},
    { "VertexArray___len", _wrap_VertexArray___len},
    { "delete_VertexArray", _wrap_delete_VertexArray},
    { "new_TriArray",_wrap_new_TriArray},
    { "TriArray_size", _wrap_TriArray_size},
    { "TriArray_max_size", _wrap_TriArray_max_size},
    { "TriArray_empty", _wrap_TriArray_empty},
    { "TriArray_clear", _wrap_TriArray_clear},
    { "TriArray_push_back", _wrap_TriArray_push_back},
    { "TriArray_pop_back", _wrap_TriArray_pop_back},
    { "TriArray_front", _wrap_TriArray_front},
    { "TriArray_back", _wrap_TriArray_back},
    { "TriArray___getitem", _wrap_TriArray___getitem},
    { "TriArray___setitem", _wrap_TriArray___setitem},
    { "TriArray___len", _wrap_TriArray___len},
    { "delete_TriArray", _wrap_delete_TriArray},
    { "new_ObjectRefArray",_wrap_new_ObjectRefArray},
    { "ObjectRefArray_size", _wrap_ObjectRefArray_size},
    { "ObjectRefArray_max_size", _wrap_ObjectRefArray_max_size},
    { "ObjectRefArray_empty", _wrap_ObjectRefArray_empty},
    { "ObjectRefArray_clear", _wrap_ObjectRefArray_clear},
    { "ObjectRefArray_push_back", _wrap_ObjectRefArray_push_back},
    { "ObjectRefArray_pop_back", _wrap_ObjectRefArray_pop_back},
    { "ObjectRefArray_front", _wrap_ObjectRefArray_front},
    { "ObjectRefArray_back", _wrap_ObjectRefArray_back},
    { "ObjectRefArray___getitem", _wrap_ObjectRefArray___getitem},
    { "ObjectRefArray___setitem", _wrap_ObjectRefArray___setitem},
    { "ObjectRefArray___len", _wrap_ObjectRefArray___len},
    { "delete_ObjectRefArray", _wrap_delete_ObjectRefArray},
    { "new_AnimationInfoRefArray",_wrap_new_AnimationInfoRefArray},
    { "AnimationInfoRefArray_size", _wrap_AnimationInfoRefArray_size},
    { "AnimationInfoRefArray_max_size", _wrap_AnimationInfoRefArray_max_size},
    { "AnimationInfoRefArray_empty", _wrap_AnimationInfoRefArray_empty},
    { "AnimationInfoRefArray_clear", _wrap_AnimationInfoRefArray_clear},
    { "AnimationInfoRefArray_push_back", _wrap_AnimationInfoRefArray_push_back},
    { "AnimationInfoRefArray_pop_back", _wrap_AnimationInfoRefArray_pop_back},
    { "AnimationInfoRefArray_front", _wrap_AnimationInfoRefArray_front},
    { "AnimationInfoRefArray_back", _wrap_AnimationInfoRefArray_back},
    { "AnimationInfoRefArray___getitem", _wrap_AnimationInfoRefArray___getitem},
    { "AnimationInfoRefArray___setitem", _wrap_AnimationInfoRefArray___setitem},
    { "AnimationInfoRefArray___len", _wrap_AnimationInfoRefArray___len},
    { "delete_AnimationInfoRefArray", _wrap_delete_AnimationInfoRefArray},
    { "new_AnimationInfoList",_wrap_new_AnimationInfoList},
    { "AnimationInfoList_size", _wrap_AnimationInfoList_size},
    { "AnimationInfoList_empty", _wrap_AnimationInfoList_empty},
    { "AnimationInfoList_clear", _wrap_AnimationInfoList_clear},
    { "AnimationInfoList_push_back", _wrap_AnimationInfoList_push_back},
    { "AnimationInfoList_pop_back", _wrap_AnimationInfoList_pop_back},
    { "AnimationInfoList_push_front", _wrap_AnimationInfoList_push_front},
    { "AnimationInfoList_pop_front", _wrap_AnimationInfoList_pop_front},
    { "AnimationInfoList_front", _wrap_AnimationInfoList_front},
    { "AnimationInfoList_back", _wrap_AnimationInfoList_back},
    { "AnimationInfoList_begin_it", _wrap_AnimationInfoList_begin_it},
    { "AnimationInfoList_end_it", _wrap_AnimationInfoList_end_it},
    { "AnimationInfoList_rbegin_it", _wrap_AnimationInfoList_rbegin_it},
    { "AnimationInfoList_rend_it", _wrap_AnimationInfoList_rend_it},
    { "AnimationInfoList___len", _wrap_AnimationInfoList___len},
    { "delete_AnimationInfoList", _wrap_delete_AnimationInfoList},
    { "AnimInfoListIt_value", _wrap_AnimInfoListIt_value},
    { "AnimInfoListIt_next", _wrap_AnimInfoListIt_next},
    { "AnimInfoListIt_prev", _wrap_AnimInfoListIt_prev},
    { "AnimInfoListIt___eq", _wrap_AnimInfoListIt___eq},
    { "new_AnimInfoListIt", _wrap_new_AnimInfoListIt},
    { "delete_AnimInfoListIt", _wrap_delete_AnimInfoListIt},
    { "AnimInfoListRevIt_value", _wrap_AnimInfoListRevIt_value},
    { "AnimInfoListRevIt_next", _wrap_AnimInfoListRevIt_next},
    { "AnimInfoListRevIt_prev", _wrap_AnimInfoListRevIt_prev},
    { "AnimInfoListRevIt___eq", _wrap_AnimInfoListRevIt___eq},
    { "new_AnimInfoListRevIt", _wrap_new_AnimInfoListRevIt},
    { "delete_AnimInfoListRevIt", _wrap_delete_AnimInfoListRevIt},
    { "new_AnimPropertyList",_wrap_new_AnimPropertyList},
    { "AnimPropertyList_size", _wrap_AnimPropertyList_size},
    { "AnimPropertyList_empty", _wrap_AnimPropertyList_empty},
    { "AnimPropertyList_clear", _wrap_AnimPropertyList_clear},
    { "AnimPropertyList_push_back", _wrap_AnimPropertyList_push_back},
    { "AnimPropertyList_pop_back", _wrap_AnimPropertyList_pop_back},
    { "AnimPropertyList_push_front", _wrap_AnimPropertyList_push_front},
    { "AnimPropertyList_pop_front", _wrap_AnimPropertyList_pop_front},
    { "AnimPropertyList_front", _wrap_AnimPropertyList_front},
    { "AnimPropertyList_back", _wrap_AnimPropertyList_back},
    { "AnimPropertyList_begin_it", _wrap_AnimPropertyList_begin_it},
    { "AnimPropertyList_end_it", _wrap_AnimPropertyList_end_it},
    { "AnimPropertyList_rbegin_it", _wrap_AnimPropertyList_rbegin_it},
    { "AnimPropertyList_rend_it", _wrap_AnimPropertyList_rend_it},
    { "AnimPropertyList___len", _wrap_AnimPropertyList___len},
    { "delete_AnimPropertyList", _wrap_delete_AnimPropertyList},
    { "AnimPropListIt_value", _wrap_AnimPropListIt_value},
    { "AnimPropListIt_next", _wrap_AnimPropListIt_next},
    { "AnimPropListIt_prev", _wrap_AnimPropListIt_prev},
    { "AnimPropListIt___eq", _wrap_AnimPropListIt___eq},
    { "new_AnimPropListIt", _wrap_new_AnimPropListIt},
    { "delete_AnimPropListIt", _wrap_delete_AnimPropListIt},
    { "AnimPropListRevIt_value", _wrap_AnimPropListRevIt_value},
    { "AnimPropListRevIt_next", _wrap_AnimPropListRevIt_next},
    { "AnimPropListRevIt_prev", _wrap_AnimPropListRevIt_prev},
    { "AnimPropListRevIt___eq", _wrap_AnimPropListRevIt___eq},
    { "new_AnimPropListRevIt", _wrap_new_AnimPropListRevIt},
    { "delete_AnimPropListRevIt", _wrap_delete_AnimPropListRevIt},
    { "new_AnimPropertyRefArray",_wrap_new_AnimPropertyRefArray},
    { "AnimPropertyRefArray_size", _wrap_AnimPropertyRefArray_size},
    { "AnimPropertyRefArray_max_size", _wrap_AnimPropertyRefArray_max_size},
    { "AnimPropertyRefArray_empty", _wrap_AnimPropertyRefArray_empty},
    { "AnimPropertyRefArray_clear", _wrap_AnimPropertyRefArray_clear},
    { "AnimPropertyRefArray_push_back", _wrap_AnimPropertyRefArray_push_back},
    { "AnimPropertyRefArray_pop_back", _wrap_AnimPropertyRefArray_pop_back},
    { "AnimPropertyRefArray_front", _wrap_AnimPropertyRefArray_front},
    { "AnimPropertyRefArray_back", _wrap_AnimPropertyRefArray_back},
    { "AnimPropertyRefArray___getitem", _wrap_AnimPropertyRefArray___getitem},
    { "AnimPropertyRefArray___setitem", _wrap_AnimPropertyRefArray___setitem},
    { "AnimPropertyRefArray___len", _wrap_AnimPropertyRefArray___len},
    { "delete_AnimPropertyRefArray", _wrap_delete_AnimPropertyRefArray},
    { "message", _wrap_message},
    { "input", _wrap_input},
    { "upsGetModel", _wrap_upsGetModel},
    { "upsGetRootObj", _wrap_upsGetRootObj},
    { "upsUpdateViews", _wrap_upsUpdateViews},
    { "_upsFileSaveDlg", _wrap__upsFileSaveDlg},
    { "_upsFileOpenDlg", _wrap__upsFileOpenDlg},
    { "upsAnimGetType", _wrap_upsAnimGetType},
    { "upsAnimGetKeyIndex", _wrap_upsAnimGetKeyIndex},
    { "upsAnimGetNumKeys", _wrap_upsAnimGetNumKeys},
    { "upsAnimGetKeyTime", _wrap_upsAnimGetKeyTime},
    { "upsAnimGetFloatKey", _wrap_upsAnimGetFloatKey},
    { "upsAnimGetVector3Key", _wrap_upsAnimGetVector3Key},
    { "upsAnimGetRotationKey", _wrap_upsAnimGetRotationKey},
    { "upsAnimInsertVectorKey", _wrap_upsAnimInsertVectorKey},
    { "upsAnimInsertRotatorKey", _wrap_upsAnimInsertRotatorKey},
    { "upsAnimInsertFloatKey", _wrap_upsAnimInsertFloatKey},
    {0,0}
};

static swig_lua_var_info swig_variables[] = {
    {0,0,0}
};

static swig_lua_const_info swig_constants[] = {
{ SWIG_LUA_FLOAT,   (char *)"M_PI", 0, (double) 3.1415926536f, 0, 0},
{ SWIG_LUA_FLOAT,   (char *)"EPSILON", 0, (double) (0.01f), 0, 0},
{ SWIG_LUA_INT,     (char *)"Quaternion_qshort", (long) Quaternion::qshort, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Quaternion_qlong", (long) Quaternion::qlong, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Quaternion_qcw", (long) Quaternion::qcw, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Quaternion_qccw", (long) Quaternion::qccw, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"Quaternion_quser", (long) Quaternion::quser, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"MAPPING_S3O", (long) 0, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"MAPPING_3DO", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"IKJT_Fixed", (long) IKJT_Fixed, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"IKJT_Hinge", (long) IKJT_Hinge, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"IKJT_Universal", (long) IKJT_Universal, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SCRIPT_GETNAME", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SCRIPT_SHOWHELP", (long) 2, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"SCRIPT_EXEC", (long) 3, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"ANIMTYPE_FLOAT", (long) 0, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"ANIMTYPE_VECTOR3", (long) 1, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"ANIMTYPE_ROTATION", (long) 2, 0, 0, 0},
{ SWIG_LUA_INT,     (char *)"ANIMTYPE_OTHER", (long) 3, 0, 0, 0},
    {0,0,0,0,0,0}
};

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_PolyMeshTo_p_Geometry(void *x) {
    return (void *)((Geometry *)  ((PolyMesh *) x));
}
static void *_p_HingeJointTo_p_BaseJoint(void *x) {
    return (void *)((BaseJoint *)  ((HingeJoint *) x));
}
static void *_p_UniversalJointTo_p_BaseJoint(void *x) {
    return (void *)((BaseJoint *)  ((UniversalJoint *) x));
}
static swig_type_info _swigt__AnimProperty = {"_AnimProperty", "AnimProperty", 0, 0, (void*)0, 0};
static swig_type_info _swigt__AnimationInfo = {"_AnimationInfo", "AnimationInfo", 0, 0, (void*)0, 0};
static swig_type_info _swigt__Quaternion = {"_Quaternion", "Quaternion", 0, 0, (void*)0, 0};
static swig_type_info _swigt__Rotator = {"_Rotator", "Rotator", 0, 0, (void*)0, 0};
static swig_type_info _swigt__Triangle = {"_Triangle", "Triangle", 0, 0, (void*)0, 0};
static swig_type_info _swigt__Vector3 = {"_Vector3", "Vector3", 0, 0, (void*)0, 0};
static swig_type_info _swigt__Vertex = {"_Vertex", "Vertex", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_AnimController = {"_p_AnimController", "AnimController *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_AnimProperty = {"_p_AnimProperty", "AnimProperty *", 0, 0, (void*)&_wrap_class_AnimProperty, 0};
static swig_type_info _swigt__p_AnimationInfo = {"_p_AnimationInfo", "AnimationInfo *", 0, 0, (void*)&_wrap_class_AnimationInfo, 0};
static swig_type_info _swigt__p_AnimationSequence = {"_p_AnimationSequence", "AnimationSequence *", 0, 0, (void*)&_wrap_class_AnimationSequence, 0};
static swig_type_info _swigt__p_BaseJoint = {"_p_BaseJoint", "BaseJoint *", 0, 0, (void*)&_wrap_class_BaseJoint, 0};
static swig_type_info _swigt__p_EditorViewWindow = {"_p_EditorViewWindow", "EditorViewWindow *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Geometry = {"_p_Geometry", "Geometry *", 0, 0, (void*)&_wrap_class_Geometry, 0};
static swig_type_info _swigt__p_HingeJoint = {"_p_HingeJoint", "HingeJoint *", 0, 0, (void*)&_wrap_class_HingeJoint, 0};
static swig_type_info _swigt__p_IEditor = {"_p_IEditor", "IEditor *", 0, 0, (void*)&_wrap_class_IEditor, 0};
static swig_type_info _swigt__p_IKinfo = {"_p_IKinfo", "IKinfo *", 0, 0, (void*)&_wrap_class_IKinfo, 0};
static swig_type_info _swigt__p_IProgressCtl = {"_p_IProgressCtl", "IProgressCtl *", 0, 0, (void*)&_wrap_class_IProgressCtl, 0};
static swig_type_info _swigt__p_IRenderData = {"_p_IRenderData", "IRenderData *", 0, 0, (void*)&_wrap_class_IRenderData, 0};
static swig_type_info _swigt__p_IView = {"_p_IView", "IView *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Matrix = {"_p_Matrix", "Matrix *", 0, 0, (void*)&_wrap_class_Matrix, 0};
static swig_type_info _swigt__p_MdlObject = {"_p_MdlObject", "MdlObject *", 0, 0, (void*)&_wrap_class_MdlObject, 0};
static swig_type_info _swigt__p_Model = {"_p_Model", "Model *", 0, 0, (void*)&_wrap_class_Model, 0};
static swig_type_info _swigt__p_ModelDrawer = {"_p_ModelDrawer", "ModelDrawer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Plane = {"_p_Plane", "Plane *", 0, 0, (void*)&_wrap_class_Plane, 0};
static swig_type_info _swigt__p_Poly = {"_p_Poly", "Poly *", 0, 0, (void*)&_wrap_class_Poly, 0};
static swig_type_info _swigt__p_PolyMesh = {"_p_PolyMesh", "PolyMesh *", 0, 0, (void*)&_wrap_class_PolyMesh, 0};
static swig_type_info _swigt__p_Quaternion = {"_p_Quaternion", "Quaternion *", 0, 0, (void*)&_wrap_class_Quaternion, 0};
static swig_type_info _swigt__p_RefPtrTTexture_t = {"_p_RefPtrTTexture_t", "RefPtr<Texture > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Rotator = {"_p_Rotator", "Rotator *", 0, 0, (void*)&_wrap_class_Rotator, 0};
static swig_type_info _swigt__p_Texture = {"_p_Texture", "Texture *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TextureBinding = {"_p_TextureBinding", "TextureBinding *", 0, 0, (void*)&_wrap_class_TextureBinding, 0};
static swig_type_info _swigt__p_TextureHandler = {"_p_TextureHandler", "TextureHandler *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Tool = {"_p_Tool", "Tool *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Triangle = {"_p_Triangle", "Triangle *", 0, 0, (void*)&_wrap_class_Triangle, 0};
static swig_type_info _swigt__p_UniversalJoint = {"_p_UniversalJoint", "UniversalJoint *", 0, 0, (void*)&_wrap_class_UniversalJoint, 0};
static swig_type_info _swigt__p_Vector2 = {"_p_Vector2", "Vector2 *", 0, 0, (void*)&_wrap_class_Vector2, 0};
static swig_type_info _swigt__p_Vector3 = {"_p_Vector3", "Vector3 *", 0, 0, (void*)&_wrap_class_Vector3, 0};
static swig_type_info _swigt__p_Vector4 = {"_p_Vector4", "Vector4 *", 0, 0, (void*)&_wrap_class_Vector4, 0};
static swig_type_info _swigt__p_Vertex = {"_p_Vertex", "Vertex *", 0, 0, (void*)&_wrap_class_Vertex, 0};
static swig_type_info _swigt__p_creg__ISerializer = {"_p_creg__ISerializer", "creg::ISerializer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_float_p_void__void = {"_p_f_float_p_void__void", "void (*)(float,void *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_MdlObject__void = {"_p_f_p_MdlObject__void", "void (*)(MdlObject *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_Texture_p_void__void = {"_p_f_p_Texture_p_void__void", "void (*)(Texture *,void *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_r_Vertex_r_Vertex__bool = {"_p_f_r_Vertex_r_Vertex__bool", "bool (*)(Vertex &,Vertex &)|PolyMesh::IsEqualVertexCB", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_float = {"_p_float", "float *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_t = {"_p_size_t", "size_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__listTAnimProperty_t = {"_p_std__listTAnimProperty_t", "std::list<AnimProperty > *", 0, 0, (void*)&_wrap_class_std_list_Sl_AnimProperty_Sg_, 0};
static swig_type_info _swigt__p_std__listTAnimationInfo_t = {"_p_std__listTAnimationInfo_t", "std::list<AnimationInfo > *", 0, 0, (void*)&_wrap_class_std_list_Sl_AnimationInfo_Sg_, 0};
static swig_type_info _swigt__p_std__list_iteratorTAnimProperty_t = {"_p_std__list_iteratorTAnimProperty_t", "std::list_iterator<AnimProperty > *", 0, 0, (void*)&_wrap_class_std_list_iterator_Sl_AnimProperty_Sg_, 0};
static swig_type_info _swigt__p_std__list_iteratorTAnimationInfo_t = {"_p_std__list_iteratorTAnimationInfo_t", "std::list_iterator<AnimationInfo > *", 0, 0, (void*)&_wrap_class_std_list_iterator_Sl_AnimationInfo_Sg_, 0};
static swig_type_info _swigt__p_std__list_reverse_iteratorTAnimProperty_t = {"_p_std__list_reverse_iteratorTAnimProperty_t", "std::list_reverse_iterator<AnimProperty > *", 0, 0, (void*)&_wrap_class_std_list_reverse_iterator_Sl_AnimProperty_Sg_, 0};
static swig_type_info _swigt__p_std__list_reverse_iteratorTAnimationInfo_t = {"_p_std__list_reverse_iteratorTAnimationInfo_t", "std::list_reverse_iterator<AnimationInfo > *", 0, 0, (void*)&_wrap_class_std_list_reverse_iterator_Sl_AnimationInfo_Sg_, 0};
static swig_type_info _swigt__p_std__string = {"_p_std__string", "std::string *", 0, 0, (void*)&_wrap_class_std_string, 0};
static swig_type_info _swigt__p_std__vectorTAnimProperty_p_t = {"_p_std__vectorTAnimProperty_p_t", "std::vector<AnimProperty * > *", 0, 0, (void*)&_wrap_class_std_vector_Sl_AnimProperty_Sm__Sg_, 0};
static swig_type_info _swigt__p_std__vectorTAnimationInfo_p_t = {"_p_std__vectorTAnimationInfo_p_t", "std::vector<AnimationInfo * > *", 0, 0, (void*)&_wrap_class_std_vector_Sl_AnimationInfo_Sm__Sg_, 0};
static swig_type_info _swigt__p_std__vectorTEditorViewWindow_p_t = {"_p_std__vectorTEditorViewWindow_p_t", "std::vector<EditorViewWindow * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTMdlObject_p_t = {"_p_std__vectorTMdlObject_p_t", "std::vector<MdlObject * > *", 0, 0, (void*)&_wrap_class_std_vector_Sl_MdlObject_Sm__Sg_, 0};
static swig_type_info _swigt__p_std__vectorTPolyMesh_p_t = {"_p_std__vectorTPolyMesh_p_t", "std::vector<PolyMesh * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTPoly_p_t = {"_p_std__vectorTPoly_p_t", "std::vector<Poly * > *", 0, 0, (void*)&_wrap_class_std_vector_Sl_Poly_Sm__Sg_, 0};
static swig_type_info _swigt__p_std__vectorTTextureBinding_t = {"_p_std__vectorTTextureBinding_t", "std::vector<TextureBinding > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTTriangle_t = {"_p_std__vectorTTriangle_t", "std::vector<Triangle > *", 0, 0, (void*)&_wrap_class_std_vector_Sl_Triangle_Sg_, 0};
static swig_type_info _swigt__p_std__vectorTVector3_t = {"_p_std__vectorTVector3_t", "std::vector<Vector3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorTVertex_t = {"_p_std__vectorTVertex_t", "std::vector<Vertex > *", 0, 0, (void*)&_wrap_class_std_vector_Sl_Vertex_Sg_, 0};
static swig_type_info _swigt__p_std__vectorTchar_t = {"_p_std__vectorTchar_t", "std::vector<char > *", 0, 0, (void*)&_wrap_class_std_vector_Sl_char_Sg_, 0};
static swig_type_info _swigt__p_std__vectorTfloat_t = {"_p_std__vectorTfloat_t", "std::vector<float > *", 0, 0, (void*)&_wrap_class_std_vector_Sl_float_Sg_, 0};
static swig_type_info _swigt__p_std__vectorTint_t = {"_p_std__vectorTint_t", "std::vector<int > *", 0, 0, (void*)&_wrap_class_std_vector_Sl_int_Sg_, 0};
static swig_type_info _swigt__p_std__vectorTshort_t = {"_p_std__vectorTshort_t", "std::vector<short > *", 0, 0, (void*)&_wrap_class_std_vector_Sl_short_Sg_, 0};
static swig_type_info _swigt__p_uint = {"_p_uint", "uint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ulong = {"_p_ulong", "ulong *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_void = {"_p_void", "void *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__size_t = {"_size_t", "size_t", 0, 0, (void*)0, 0};
static swig_type_info _swigt__uint = {"_uint", "uint", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__AnimProperty,
  &_swigt__AnimationInfo,
  &_swigt__Quaternion,
  &_swigt__Rotator,
  &_swigt__Triangle,
  &_swigt__Vector3,
  &_swigt__Vertex,
  &_swigt__p_AnimController,
  &_swigt__p_AnimProperty,
  &_swigt__p_AnimationInfo,
  &_swigt__p_AnimationSequence,
  &_swigt__p_BaseJoint,
  &_swigt__p_EditorViewWindow,
  &_swigt__p_Geometry,
  &_swigt__p_HingeJoint,
  &_swigt__p_IEditor,
  &_swigt__p_IKinfo,
  &_swigt__p_IProgressCtl,
  &_swigt__p_IRenderData,
  &_swigt__p_IView,
  &_swigt__p_Matrix,
  &_swigt__p_MdlObject,
  &_swigt__p_Model,
  &_swigt__p_ModelDrawer,
  &_swigt__p_Plane,
  &_swigt__p_Poly,
  &_swigt__p_PolyMesh,
  &_swigt__p_Quaternion,
  &_swigt__p_RefPtrTTexture_t,
  &_swigt__p_Rotator,
  &_swigt__p_Texture,
  &_swigt__p_TextureBinding,
  &_swigt__p_TextureHandler,
  &_swigt__p_Tool,
  &_swigt__p_Triangle,
  &_swigt__p_UniversalJoint,
  &_swigt__p_Vector2,
  &_swigt__p_Vector3,
  &_swigt__p_Vector4,
  &_swigt__p_Vertex,
  &_swigt__p_creg__ISerializer,
  &_swigt__p_f_float_p_void__void,
  &_swigt__p_f_p_MdlObject__void,
  &_swigt__p_f_p_Texture_p_void__void,
  &_swigt__p_f_r_Vertex_r_Vertex__bool,
  &_swigt__p_float,
  &_swigt__p_int,
  &_swigt__p_size_t,
  &_swigt__p_std__listTAnimProperty_t,
  &_swigt__p_std__listTAnimationInfo_t,
  &_swigt__p_std__list_iteratorTAnimProperty_t,
  &_swigt__p_std__list_iteratorTAnimationInfo_t,
  &_swigt__p_std__list_reverse_iteratorTAnimProperty_t,
  &_swigt__p_std__list_reverse_iteratorTAnimationInfo_t,
  &_swigt__p_std__string,
  &_swigt__p_std__vectorTAnimProperty_p_t,
  &_swigt__p_std__vectorTAnimationInfo_p_t,
  &_swigt__p_std__vectorTEditorViewWindow_p_t,
  &_swigt__p_std__vectorTMdlObject_p_t,
  &_swigt__p_std__vectorTPolyMesh_p_t,
  &_swigt__p_std__vectorTPoly_p_t,
  &_swigt__p_std__vectorTTextureBinding_t,
  &_swigt__p_std__vectorTTriangle_t,
  &_swigt__p_std__vectorTVector3_t,
  &_swigt__p_std__vectorTVertex_t,
  &_swigt__p_std__vectorTchar_t,
  &_swigt__p_std__vectorTfloat_t,
  &_swigt__p_std__vectorTint_t,
  &_swigt__p_std__vectorTshort_t,
  &_swigt__p_uint,
  &_swigt__p_ulong,
  &_swigt__p_void,
  &_swigt__size_t,
  &_swigt__uint,
};

static swig_cast_info _swigc__AnimProperty[] = {  {&_swigt__AnimProperty, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__AnimationInfo[] = {  {&_swigt__AnimationInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__Quaternion[] = {  {&_swigt__Quaternion, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__Rotator[] = {  {&_swigt__Rotator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__Triangle[] = {  {&_swigt__Triangle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__Vector3[] = {  {&_swigt__Vector3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__Vertex[] = {  {&_swigt__Vertex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AnimController[] = {  {&_swigt__p_AnimController, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AnimProperty[] = {  {&_swigt__p_AnimProperty, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AnimationInfo[] = {  {&_swigt__p_AnimationInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AnimationSequence[] = {  {&_swigt__p_AnimationSequence, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BaseJoint[] = {  {&_swigt__p_BaseJoint, 0, 0, 0},  {&_swigt__p_HingeJoint, _p_HingeJointTo_p_BaseJoint, 0, 0},  {&_swigt__p_UniversalJoint, _p_UniversalJointTo_p_BaseJoint, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EditorViewWindow[] = {  {&_swigt__p_EditorViewWindow, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Geometry[] = {  {&_swigt__p_PolyMesh, _p_PolyMeshTo_p_Geometry, 0, 0},  {&_swigt__p_Geometry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_HingeJoint[] = {  {&_swigt__p_HingeJoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IEditor[] = {  {&_swigt__p_IEditor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IKinfo[] = {  {&_swigt__p_IKinfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IProgressCtl[] = {  {&_swigt__p_IProgressCtl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IRenderData[] = {  {&_swigt__p_IRenderData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IView[] = {  {&_swigt__p_IView, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Matrix[] = {  {&_swigt__p_Matrix, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MdlObject[] = {  {&_swigt__p_MdlObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Model[] = {  {&_swigt__p_Model, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ModelDrawer[] = {  {&_swigt__p_ModelDrawer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Plane[] = {  {&_swigt__p_Plane, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Poly[] = {  {&_swigt__p_Poly, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PolyMesh[] = {  {&_swigt__p_PolyMesh, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Quaternion[] = {  {&_swigt__p_Quaternion, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RefPtrTTexture_t[] = {  {&_swigt__p_RefPtrTTexture_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Rotator[] = {  {&_swigt__p_Rotator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Texture[] = {  {&_swigt__p_Texture, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TextureBinding[] = {  {&_swigt__p_TextureBinding, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TextureHandler[] = {  {&_swigt__p_TextureHandler, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Tool[] = {  {&_swigt__p_Tool, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Triangle[] = {  {&_swigt__p_Triangle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_UniversalJoint[] = {  {&_swigt__p_UniversalJoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Vector2[] = {  {&_swigt__p_Vector2, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Vector3[] = {  {&_swigt__p_Vector3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Vector4[] = {  {&_swigt__p_Vector4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Vertex[] = {  {&_swigt__p_Vertex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_creg__ISerializer[] = {  {&_swigt__p_creg__ISerializer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_float_p_void__void[] = {  {&_swigt__p_f_float_p_void__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_MdlObject__void[] = {  {&_swigt__p_f_p_MdlObject__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_Texture_p_void__void[] = {  {&_swigt__p_f_p_Texture_p_void__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_r_Vertex_r_Vertex__bool[] = {  {&_swigt__p_f_r_Vertex_r_Vertex__bool, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_t[] = {  {&_swigt__p_size_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__listTAnimProperty_t[] = {  {&_swigt__p_std__listTAnimProperty_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__listTAnimationInfo_t[] = {  {&_swigt__p_std__listTAnimationInfo_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__list_iteratorTAnimProperty_t[] = {  {&_swigt__p_std__list_iteratorTAnimProperty_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__list_iteratorTAnimationInfo_t[] = {  {&_swigt__p_std__list_iteratorTAnimationInfo_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__list_reverse_iteratorTAnimProperty_t[] = {  {&_swigt__p_std__list_reverse_iteratorTAnimProperty_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__list_reverse_iteratorTAnimationInfo_t[] = {  {&_swigt__p_std__list_reverse_iteratorTAnimationInfo_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAnimProperty_p_t[] = {  {&_swigt__p_std__vectorTAnimProperty_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTAnimationInfo_p_t[] = {  {&_swigt__p_std__vectorTAnimationInfo_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTEditorViewWindow_p_t[] = {  {&_swigt__p_std__vectorTEditorViewWindow_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTMdlObject_p_t[] = {  {&_swigt__p_std__vectorTMdlObject_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTPolyMesh_p_t[] = {  {&_swigt__p_std__vectorTPolyMesh_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTPoly_p_t[] = {  {&_swigt__p_std__vectorTPoly_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTTextureBinding_t[] = {  {&_swigt__p_std__vectorTTextureBinding_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTTriangle_t[] = {  {&_swigt__p_std__vectorTTriangle_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTVector3_t[] = {  {&_swigt__p_std__vectorTVector3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTVertex_t[] = {  {&_swigt__p_std__vectorTVertex_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTchar_t[] = {  {&_swigt__p_std__vectorTchar_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTfloat_t[] = {  {&_swigt__p_std__vectorTfloat_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTint_t[] = {  {&_swigt__p_std__vectorTint_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorTshort_t[] = {  {&_swigt__p_std__vectorTshort_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_uint[] = {  {&_swigt__p_uint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ulong[] = {  {&_swigt__p_ulong, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__size_t[] = {  {&_swigt__size_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__uint[] = {  {&_swigt__uint, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__AnimProperty,
  _swigc__AnimationInfo,
  _swigc__Quaternion,
  _swigc__Rotator,
  _swigc__Triangle,
  _swigc__Vector3,
  _swigc__Vertex,
  _swigc__p_AnimController,
  _swigc__p_AnimProperty,
  _swigc__p_AnimationInfo,
  _swigc__p_AnimationSequence,
  _swigc__p_BaseJoint,
  _swigc__p_EditorViewWindow,
  _swigc__p_Geometry,
  _swigc__p_HingeJoint,
  _swigc__p_IEditor,
  _swigc__p_IKinfo,
  _swigc__p_IProgressCtl,
  _swigc__p_IRenderData,
  _swigc__p_IView,
  _swigc__p_Matrix,
  _swigc__p_MdlObject,
  _swigc__p_Model,
  _swigc__p_ModelDrawer,
  _swigc__p_Plane,
  _swigc__p_Poly,
  _swigc__p_PolyMesh,
  _swigc__p_Quaternion,
  _swigc__p_RefPtrTTexture_t,
  _swigc__p_Rotator,
  _swigc__p_Texture,
  _swigc__p_TextureBinding,
  _swigc__p_TextureHandler,
  _swigc__p_Tool,
  _swigc__p_Triangle,
  _swigc__p_UniversalJoint,
  _swigc__p_Vector2,
  _swigc__p_Vector3,
  _swigc__p_Vector4,
  _swigc__p_Vertex,
  _swigc__p_creg__ISerializer,
  _swigc__p_f_float_p_void__void,
  _swigc__p_f_p_MdlObject__void,
  _swigc__p_f_p_Texture_p_void__void,
  _swigc__p_f_r_Vertex_r_Vertex__bool,
  _swigc__p_float,
  _swigc__p_int,
  _swigc__p_size_t,
  _swigc__p_std__listTAnimProperty_t,
  _swigc__p_std__listTAnimationInfo_t,
  _swigc__p_std__list_iteratorTAnimProperty_t,
  _swigc__p_std__list_iteratorTAnimationInfo_t,
  _swigc__p_std__list_reverse_iteratorTAnimProperty_t,
  _swigc__p_std__list_reverse_iteratorTAnimationInfo_t,
  _swigc__p_std__string,
  _swigc__p_std__vectorTAnimProperty_p_t,
  _swigc__p_std__vectorTAnimationInfo_p_t,
  _swigc__p_std__vectorTEditorViewWindow_p_t,
  _swigc__p_std__vectorTMdlObject_p_t,
  _swigc__p_std__vectorTPolyMesh_p_t,
  _swigc__p_std__vectorTPoly_p_t,
  _swigc__p_std__vectorTTextureBinding_t,
  _swigc__p_std__vectorTTriangle_t,
  _swigc__p_std__vectorTVector3_t,
  _swigc__p_std__vectorTVertex_t,
  _swigc__p_std__vectorTchar_t,
  _swigc__p_std__vectorTfloat_t,
  _swigc__p_std__vectorTint_t,
  _swigc__p_std__vectorTshort_t,
  _swigc__p_uint,
  _swigc__p_ulong,
  _swigc__p_void,
  _swigc__size_t,
  _swigc__uint,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found;

  clientdata = clientdata;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
  
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
    
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif



/* Forward declaration of where the user's %init{} gets inserted */
#ifdef __cplusplus
extern "C" {
#endif
void SWIG_init_user(lua_State* L );

/* this is the initialization function
	added at the very end of the code
	the function is always called SWIG_init, but an eariler #define will rename it
*/
SWIGEXPORT int SWIG_init(lua_State* L)
{
	int i;

	/* start with global table */
	lua_pushvalue(L,LUA_GLOBALSINDEX);

	SWIG_InitializeModule((void*)L);
	SWIG_PropagateClientData();

	/* invoke user-specific initialization */
	SWIG_init_user(L);

	/* add a global fn */
	SWIG_Lua_add_function(L,"swig_type",SWIG_Lua_type);
	SWIG_Lua_add_function(L,"swig_equals",SWIG_Lua_equal);

	/* begin the module (its a table with the same name as the module) */
	SWIG_Lua_module_begin(L,SWIG_name);
	/* add commands/functions */
	for (i = 0; swig_commands[i].name; i++){
		SWIG_Lua_module_add_function(L,swig_commands[i].name,swig_commands[i].func);
	}
	/*luaL_openlib(L,NULL,swig_commands,0);*/
	/* all in one */
	/*luaL_openlib(L,SWIG_name,swig_commands,0);*/
	/* add variables */
	for (i = 0; swig_variables[i].name; i++){
		SWIG_Lua_module_add_variable(L,swig_variables[i].name,swig_variables[i].get,swig_variables[i].set);
	}

	/* additional registration structs & classes in lua: */
	for (i = 0; swig_types[i]; i++){
		if (swig_types[i]->clientdata){
			SWIG_Lua_class_register(L,(swig_lua_class*)(swig_types[i]->clientdata));
		}
	}

	/* constants */
	SWIG_Lua_InstallConstants(L,swig_constants);

	/* end module */
	/*SWIG_Lua_module_end(L);*/
	lua_pop(L,1);  /* tidy stack (remove module table)*/
	lua_pop(L,1);  /* tidy stack (remove global table)*/

	return 1;
}

/* Lua 5.1 has a different name for importing libraries
luaopen_XXX, where XXX is the name of the module (not capitalised)
this function will allow Lua 5.1 to import correctly.
There is a #define in the wrapper to rename 'SWIG_import' to the correct name
*/

SWIGEXPORT int SWIG_import(lua_State* L)
{
	return SWIG_init(L);
}

#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
extern "C"
#endif
void SWIG_init_user(lua_State* L)
{
  
}

